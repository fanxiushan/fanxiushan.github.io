<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Objective-C 语言里的拷贝就是对象拷贝，即创建一个跟之前的实例对象一模一样的对象。一般来说数据模型类是需要支持拷贝的。Objective-C 里拷贝又分为浅拷贝（shallow-copy）和深拷贝（deep-copy）。 浅拷贝和深拷贝区别浅拷贝只是复制一下对象指针，但是拷贝前和拷贝后的对象指针均指向同一内存区域，只不过是对象的内存引用计数加一。深拷贝为拷贝前和拷贝后的对象指针指向不同的">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C 里的拷贝">
<meta property="og:url" content="http://yoursite.com/2018/03/05/Objective-C-里的拷贝/index.html">
<meta property="og:site_name" content="FanFrank&#39;s Site">
<meta property="og:description" content="Objective-C 语言里的拷贝就是对象拷贝，即创建一个跟之前的实例对象一模一样的对象。一般来说数据模型类是需要支持拷贝的。Objective-C 里拷贝又分为浅拷贝（shallow-copy）和深拷贝（deep-copy）。 浅拷贝和深拷贝区别浅拷贝只是复制一下对象指针，但是拷贝前和拷贝后的对象指针均指向同一内存区域，只不过是对象的内存引用计数加一。深拷贝为拷贝前和拷贝后的对象指针指向不同的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/media/Jietu20180305-184629.png">
<meta property="og:image" content="http://yoursite.com/media/15203089948766.jpg">
<meta property="og:updated_time" content="2019-12-29T14:00:30.803Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C 里的拷贝">
<meta name="twitter:description" content="Objective-C 语言里的拷贝就是对象拷贝，即创建一个跟之前的实例对象一模一样的对象。一般来说数据模型类是需要支持拷贝的。Objective-C 里拷贝又分为浅拷贝（shallow-copy）和深拷贝（deep-copy）。 浅拷贝和深拷贝区别浅拷贝只是复制一下对象指针，但是拷贝前和拷贝后的对象指针均指向同一内存区域，只不过是对象的内存引用计数加一。深拷贝为拷贝前和拷贝后的对象指针指向不同的">
<meta name="twitter:image" content="http://yoursite.com/media/Jietu20180305-184629.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/05/Objective-C-里的拷贝/">





  <title>FanFrank's Site</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-111759275-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FanFrank's Site</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/29/App-Store-隐私政策网址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/29/App-Store-隐私政策网址/" itemprop="url">App Store 隐私政策网址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-29T22:13:44+08:00">2019-12-29</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/12/29/App-Store-隐私政策网址/" class="leancloud_visitors" data-flag-title="App Store 隐私政策网址">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。</p>
<p>1.适用范围</p>
<p>a)在您使用本软件网络服务，本软件自动接收并记录的您的手机上的信息，包括但不限于您的健康数据、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p>
<p>2.信息的使用</p>
<p>a)在获得您的数据之后，本软件会将其上传至服务器，以生成您的排行榜数据，以便您能够更好地使用服务。</p>
<p>3.信息披露</p>
<p>a)本软件不会将您的信息披露给不受信任的第三方。</p>
<p>b)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p>
<p>c)如您出现违反中国有关法律、法规或者相关规则的情况，需要向第三方披露；</p>
<p>4.信息存储和交换</p>
<p>本软件收集的有关您的信息和资料将保存在本软件及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本软件收集信息和资料所在地的境外并在境外被访问、存储和展示。</p>
<p>5.信息安全</p>
<p>a)在使用本软件网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，请您立即联络本软件客服，以便本软件采取相应措施。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/macOS-XPC-上手/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/macOS-XPC-上手/" itemprop="url">macOS XPC 上手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T10:59:29+08:00">2018-05-30</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/05/30/macOS-XPC-上手/" class="leancloud_visitors" data-flag-title="macOS XPC 上手">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>XPC 是 macOS 里经常用到的进程间通信机制。本文不关注 XPC 的内部机制，而是一篇教你如何上手 XPC 的文章。</p>
<ol>
<li><p>创建 <code>macOS</code> 工程 <code>FRTestXPC</code>，选择 <code>Cocoa App Template</code>。</p>
</li>
<li><p>在工程 <code>FRTestXPC</code> 里点击增加 <code>Target</code>，在弹出框搜索 <code>XPC</code>, 选择搜索结果中的 <code>XPC Service</code>，然后命名 <code>Target</code> 为 <code>FRTestXPC_Helper</code> 并将 <code>target</code> 对应的 info.plist 文件中 <code>bundle id</code> 修改为 ‘com.frank.xpchelper’</p>
</li>
<li><p>选择 <code>FRTestXPC Target</code> -&gt; <code>Build Phases</code> 然后新增 <code>CopyFiles</code> 项目，将刚刚的 <code>FRTestXPC_Helper.xpc</code> 加进去，注意 <code>Destination</code> 必须要选择 <code>XPC Services</code>。否则后续主程序和 XPC 会无法建立连接。</p>
</li>
<li><p>回过头来看工程目录里 <code>FRTestXPC_Helper</code> -&gt; <code>main.m</code> 文件，这里 <code>main</code> 函数是 <code>XPC</code> 程序的入口函数。可以看到 <code>Xcode</code> 已经帮助生成很多 demo code。我们已经不需要做太多。</p>
</li>
<li><p>在主程序的窗口里增加一个 button,在点击方法里实现如下代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSXPCConnection *con = [[NSXPCConnection alloc]     initWithServiceName:@&quot;com.frank.xpchelper&quot;];</span><br><span class="line">NSXPCInterface *remoteInterface = [NSXPCInterface interfaceWithProtocol:@protocol(FRTestXPC_HelperProtocol)];</span><br><span class="line">con.remoteObjectInterface = remoteInterface;</span><br><span class="line">[[con remoteObjectProxy]  upperCaseString:@&quot;hello&quot; withReply:^(NSString *reply) &#123;</span><br><span class="line">NSLog(@&quot;reply = %@&quot;,reply);</span><br><span class="line">    &#125;];</span><br><span class="line">[con resume];</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动程序，点击 button，观察终端输出为 HELLO</p>
</li>
</ol>
<h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><ol>
<li>Tips :作为 demo 可以删除掉 <code>Project</code> 里的各种 <code>Test Target</code> 和 Test 文件，保持工程清爽直观。</li>
<li>我用的是 <code>Xcode9.1</code>版本，创建好的 XPC 中的代码完全为 Xcode 自动生成的，<code>(void)upperCaseString:(NSString *)aString withReply:(void (^)(NSString *))reply;</code> 这个协议也是 Xcode 生成的，所以看上面代码不要太突兀，你自己试试就知道了。</li>
<li>初始化主程序 <code>NSXPCConnection</code> 的时候必须写正确 XPC 的 <code>service name.</code></li>
</ol>
<h2 id="一些-QA"><a href="#一些-QA" class="headerlink" title="一些 QA"></a>一些 QA</h2><p><strong>Q: 什么场景下会用到 XPC? 具体到项目中说一下。</strong><br>A: 我觉得用到 XPC 的地方主要还是希望让别的进程分担自己的任务，同时又能够及时的和主进程进行通信。(比如一些网络处理的服务)</p>
<blockquote>
<p>Apple WWDC 的讲解也是这么说的 So if you just have some background piece of work that needs to happen every so often, you can use XPC to talk to it, initiate it, and get it running.</p>
</blockquote>
<p>其次是考虑一些其他因素，比如</p>
<ul>
<li>增加程序稳定性(XPC Service crash 但主程序不 crash).</li>
<li>XPC 服务处理一些不够安全的东西，这时候我们不提供 XPC 任何权限，比如网络访问，文件访问等，但是主程序还是保留所有的权限。<br>  相当于让小弟干活儿，但是不给小弟太多权利，干的了就干，干不了就别干…..</li>
<li>很重要一点：是这是 App Store 允许的多进程的方式。</li>
</ul>
<p><strong>Q: XPC 服务有界面吗?</strong><br>A: 一般都是后台进程。没见过有人用 XPC 搭建界面的。</p>
<p><strong>Q: 系统是怎么通过以下这些 API 方法找到 XPC 服务的 ？</strong></p>
<pre><code>NSXPCInterface *myCookieInterface = [NSXPCInterfaceinterfaceWithProtocol:@protocol(XPC_HelperProtocol)];
NSXPCConnection *myConnection = [[NSXPCConnection alloc]    initWithServiceName:@&quot;com.frank.xpchelper&quot;];</code></pre><p>A: 当 app 启动的时候，系统自动注册 app 中可见的 XPC 服务，当 app 与某个 XPC 服务建立连接，然后向他发送包含事件服务的消息。</p>
<blockquote>
<p> When the app is launched, the system automatically registers each XPC service it finds into the namespace visible to the app. An app establishes a connection with one of its XPC services and sends it messages containing events that the service then handles</p>
</blockquote>
<h2 id="一个-Demo"><a href="#一个-Demo" class="headerlink" title="一个 Demo"></a>一个 Demo</h2><p>以上的 demo 是最简单的，一般 XPC 用来做后台下载处理比较合适，所以写了一个比上面代码复杂一点点(不过还是很简单)的 demo 放到 github 上，这个 demo 是 XPC 双向同步的。即 <code>XPC Service</code> 可以不依赖于代理方法的回调而是直接给 <code>Client app</code> 发送消息。</p>
<p><code>NSXPCConnection</code> 是最主要的 API，其余的 API 比如 <code>NSXPCInterface</code>，都是依附于 <code>Connection</code>。构建双向通信的 XPC Demo 在 <code>ClientApp</code> 和 XPC 里有一些代码非常相似。即互相暴露接口，互相暴露交接的对象。Demo 也提供了一些非常实用的构建 XPC 时用的 API。</p>
<p>Demo 地址: <a href="https://github.com/fanxiushan/Demo.XPCTestDemo" target="_blank" rel="noopener">https://github.com/fanxiushan/Demo.XPCTestDemo</a></p>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#//apple_ref/doc/uid/10000172i-SW6-SW1" target="_blank" rel="noopener">Creating XPC Services</a><br><a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/OSX_Technology_Overview/SystemTechnology/SystemTechnology.html" target="_blank" rel="noopener">Mac Technology Overview -&gt; Kernel and Device Drivers Layer -&gt; High-Level Features -&gt; XPC Interprocess Communication and Services</a><br><a href="https://developer.apple.com/videos/wwdc2013" target="_blank" rel="noopener">WWDC</a><br><a href="https://developer.apple.com/documentation/xpc" target="_blank" rel="noopener">XPC</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/07/Block-理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/Block-理解/" itemprop="url">Block 理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T10:05:25+08:00">2018-04-07</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/04/07/Block-理解/" class="leancloud_visitors" data-flag-title="Block 理解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文将按照如下顺序逐个说明</p>
<ol>
<li>Block 的本质</li>
<li>Block 捕获成员变量</li>
<li>Block 的存储域以及内存生命周期分析</li>
<li>Block 捕获成员变量的生命周期</li>
<li>GCD 里面的 Block 分析</li>
<li>MRC &amp; ARC 下 Block 内存管理区别</li>
<li>Block __weak 分析 / __strongSelf 分析</li>
<li>一些常问的关于 Block 的面试题回答</li>
</ol>
<p>本文不关注 Block 的语法，只尝试说明 Block 捕获变量的方式，Block 捕获的变量的生命周期以及 Block 自身的生命周期。最后对一些常见的自己的疑问进行一些梳理归纳。</p>
<h2 id="Block-的本质"><a href="#Block-的本质" class="headerlink" title="Block 的本质"></a>Block 的本质</h2><p>使用 <code>clang -rewrite-objc main.m</code> 编译如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    void(^block)(void) = ^() &#123; NSLog(@&quot;hello world&quot;); &#125;;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//---</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">//---</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">//---</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    //初始化 block </span><br><span class="line">    void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    //执行 block 对应方法</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//---</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_aef28d_mi_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面编译后的文件里可以看到一些信息<code>block</code>实现的主体就是<code>__main_block_impl_0</code>，这个结构体里面嵌套了一个名字为<code>__block_impl</code>的结构体以及名为<code>__main_block_desc_0</code>的结构体指针。闭包里面的代码部分被抽出来生成了一个 <code>C</code> 语言的函数实现 <code>__main_block_func_0</code>，注意的是这个函数的参数就是结构体本身，这么做有啥用呢？方法实现里根本没用到 <code>block</code> 实例啊，后面会用到的…</p>
<p>说明一下这个 <code>__block_impl</code> 结构体: </p>
<ul>
<li><code>__block_impl</code>结构体里面有<code>void *isa</code>成员变量，很眼熟对不对，这个就是<code>Objective-C</code>对象实现中的对象指针，所以我们通常认为<code>block</code>也算是<code>Objective-C</code>对象。</li>
<li><code>__main_block_impl_0</code>初始化方法<code>impl.isa = &amp;_NSConcreteStackBlock;</code> Demo 里的 <code>block</code> 类型属于 <code>_NSConcreteStackBlock</code>。</li>
<li><code>__block_impl</code>结构体里有函数指针 <code>FuncPtr</code>，在 <code>__main_block_impl_0</code> 初始化的时候指向<code>block</code>闭包里面函数的实现。</li>
</ul>
<h2 id="Block-捕获变量"><a href="#Block-捕获变量" class="headerlink" title="Block 捕获变量"></a>Block 捕获变量</h2><h3 id="Block-捕获普通类型自动变量"><a href="#Block-捕获普通类型自动变量" class="headerlink" title="Block 捕获普通类型自动变量"></a>Block 捕获普通类型自动变量</h3><p><code>Block</code> 的一个强大之处在于能捕获变量，在执行闭包方法的时候利用外部捕获的变量得到一些想要的结果，这是怎么做到的？将 <code>demo</code> 稍作改动，添加一个自动变量，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    void(^block)(void) = ^() &#123; NSLog(@&quot;hello world a = %d&quot;,a); &#125;;</span><br><span class="line">    a = 3;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果如下</span><br><span class="line">hello world a = 0;</span><br></pre></td></tr></table></figure>

<p>继续使用 <code>clang -rewrite-objc main.m</code> 进行编译，得到如下结果（已精简）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int a;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    int a = __cself-&gt;a; // bound by copy</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_473c35_mi_0,a);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line">    a = 3;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次跟没有捕获成员变量时候比，在 <code>__main_block_impl_0</code> 结构体里多了一个成员变量 <code>a</code>，结合 <code>main.m</code> 实现以及 <code>__main_block_impl_0()</code> 的初始化方法可以看到这个成员变量 <code>a</code> 的初始化是依靠外部同名自动变量 <code>a</code> 的赋值，所以打印的时候会打印初始化 <code>block</code> 时候外部变量的 <code>a</code> 的值。如果在 block 初始化之后再次对外部自动变量 <code>a</code> 进行了修改，则 <code>block</code> 自动变量不会被修改。参考上面 demo 的执行结果。</p>
<h3 id="Block-捕获并修改普通类型自动变量-block-修饰符分析"><a href="#Block-捕获并修改普通类型自动变量-block-修饰符分析" class="headerlink" title="Block 捕获并修改普通类型自动变量/__block 修饰符分析"></a>Block 捕获并修改普通类型自动变量/__block 修饰符分析</h3><p>有一个值得思考的问题，如果我想要在 <code>block</code> 的闭包函数里修改外部变量的值该怎么做？目前的实现只是打印了 <code>block</code> 成员变量<code>a</code>的值，如果修改的话，我们也仅仅只能修改成员变量<code>a</code>的值，而没有途径修改外部变量的值。怎么办？一个方法就是在 <code>block</code> 内部做一个指针，指向外部自动变量 <code>a</code>,这样就能在执行方法的时候通过指针去修改外部变量的值。怎么样才能实现我们这个方案呢，<code>block</code> 提供了一个修饰符 <code>__block</code> 去修饰外部成员变量，当 <code>block</code> 捕获了带有 <code>__block</code> 修饰的外部成员变量的时候会自动在结构体内部生成一个引用外部变量的指针变量。如下 demo 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    __block int a = 0; ①</span><br><span class="line">    void(^block)(void) = ^() &#123; NSLog(@&quot;hello world a = %d&quot;,a); ②&#125;;</span><br><span class="line">    ③</span><br><span class="line">    a = 3;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果是</span><br><span class="line">hello world a = 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：①②③ 处分别打印 <code>a</code> 的内存地址，在 <code>ARC/MRC</code> 下会有不同的结果，在 <code>MRC</code> 下内存地址打印都是一样的，但是在 <code>ARC</code> 下，①和②③打印的地址不一样，①打印的是栈上地址，②③打印的是堆上的地址，原因是在 <code>ARC</code> 下向 <code>block</code> 赋值的时候，会自动将 <code>block</code> 从栈上拷贝到堆上。这个现象和后面说到的像 <code>strong</code> 修饰符修饰的 <code>block</code> 属性赋值是一个道理。</p>
</blockquote>
<p>编译后的结果为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; // by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_bd6f8c_mi_0,(a-&gt;__forwarding-&gt;a)); </span><br><span class="line">&#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 0&#125;;</span><br><span class="line">    void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344));</span><br><span class="line">    (a.__forwarding-&gt;a) = 3;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据编译后的结果来看，<code>block</code> 捕获了带有 <code>__block</code> 的自动变量之后生成的代码变的很多，而且出现了很多新的方法，比如 <code>__main_block_dispose_0</code> 和 <code>__main_block_copy_0</code>。同时 <code>block</code> 对应的结构体 <code>__main_block_impl_0</code> 里多出来一项 <code>__Block_byref_a_0 *a;</code>，这个跟我们之前预想的并不一样，我们之前预想的就是多出来一个 <code>int *a</code> 应该就好了，但是这里多出了一个 <code>__Block_byref_a_0</code> 结构体类型的指针，来看一下定义 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_a_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">  __Block_byref_a_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包含 <code>void *__isa</code> 成员变量，<code>__Block_byref_a_0</code> 这个也算是一个对象类型，里面包含了一个 <code>int a</code> 的成员变量，以及一个指向自己的指针。<br>被 <code>__block</code> 修饰符修饰的成员变量被编译器转化为 <code>__Block_byref_a_0</code> 类型的变量。初始化的时候将外部的 <code>__Block_byref_a_0</code> 变量地址赋值给 <code>block</code> 结构体成员变量里的 <code>__Block_byref_a_0</code> 指针。在 <code>block</code> 闭包函数执行的时候通过这个指针来去修改外部变量的值。</p>
<p>但是有个问题，为啥不直接生成一个 <code>int *a</code> 这样的指针，而去生成一个那么麻烦的类型呢？后面详细说明</p>
<p>思考一下，为什么<code>block</code>捕获带有 <code>__block</code> 修饰符的时候，闭包执行永远输出外部变量<code>a</code>的当前值？</p>
<h3 id="Block-捕获对象"><a href="#Block-捕获对象" class="headerlink" title="Block 捕获对象"></a>Block 捕获对象</h3><p>先上个 demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSString * a = @&quot;hello&quot;;</span><br><span class="line">    void(^block)(void) = ^() &#123; NSLog(@&quot;hello world a = %@&quot;,a); &#125;;</span><br><span class="line">    a = @&quot;world&quot;;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  NSString *a;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_a, int flags=0) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSString * a = (NSString *)&amp;__NSConstantStringImpl__var_folders_r4_93dvjwh16d17_brzl2bv_xb40000gn_T_main_0c7a66_mi_0;</span><br><span class="line">    void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, 570425344));</span><br><span class="line">    a = (NSString *)&amp;__NSConstantStringImpl__var_folders_r4_93dvjwh16d17_brzl2bv_xb40000gn_T_main_0c7a66_mi_2;</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSString *a = __cself-&gt;a; // bound by copy</span><br><span class="line"> NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_r4_93dvjwh16d17_brzl2bv_xb40000gn_T_main_0c7a66_mi_1,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>block</code>实现的结构体<code>__main_block_impl_0</code>里多了一个 <code>NSString *a</code>，貌似和捕获正常的自动变量没什么差别。从 <code>mian.m</code> 方法里的 <code>block</code> 初始化过程里可以看到，这个结构体成员变量的具体的赋值过程其实就是外部字符串对象 <code>a</code> 直接赋值给了 <code>block</code> 结构体成员变量 <code>a</code>，具体的 <code>block</code> 闭包实现中也是直接从 <code>block</code> 结构体中取出 <code>a</code> 直接进行的访问。所以其实闭包里面可以修改对象指针的话也丝毫不会影响外部的同名自动变量 <code>a</code>（这俩根本就不是一个对象指针…），但是如果直接在里面修改的话，编译器是不支持的，会报错（跟捕获普通自动变量时候报一个错）如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:Variable is not assignable (missing __block type specifier)</span><br></pre></td></tr></table></figure>

<p>但是，如果不是对捕获的外部变量进行指针修改的话，是可以对这些外部变量进行一些操作的，比如说我们捕获的变量是一个可变数组，demo 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    NSMutableArray *muarr = [NSMutableArray arrayWithCapacity:0];</span><br><span class="line">    void(^block)(void) = ^() &#123;</span><br><span class="line">        [muarr addObject:@&quot;1&quot;];</span><br><span class="line">        NSLog(@&quot;muarr = %@&quot;,muarr);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果如下:</span><br><span class="line">BlockDemo[1088:31899] muarr = (</span><br><span class="line">    1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以看到我们在不改变外部对象指针的情况下，对外部对象进行了操作。</p>
<blockquote>
<p>写到这儿不知道为啥想起来，其实跟字符串对象用 strong 修饰还是 copy 修饰有异曲同工之妙了，一般面试题问起来的话，字符串都是用 copy 修饰的，原因是如果字符串 NSString 类型指向了一个 NSMutableString 类型，那当可变字符串的字符更改的时候，看起来就是虽然 NSString 指针没变，但是内容发生了改变，会引起使用上的一些矛盾之处。所以尽量会使用 copy 修饰符修饰。</p>
</blockquote>
<p>同理，想要修改对象指针的话，还是要加上 <code>__block</code> 修饰符。可以自己使用 <code>clang -rewrite-objc main.m</code> 的方式生成一下源代码分析一下。需要注意在 <code>block</code> 闭包实现的时候对变量访问的方式。</p>
<p>看编译后的代码被捕获的<code>__block</code>变量是在栈上<code>__Block_byref_fan_0 object</code>，初始化<code>Block</code>对象的时候使用<code>object-&gt;forwarding</code>指针去初始化<code>Block</code>内部对应生成的 <code>__Block_byref_fan_0 *</code>指针，而<code>object-&gt;forwarding</code>这个指针是指向<code>object</code>自身的内存地址。这块儿的分析有助于我们后面对<code>__block</code>修饰的变量内存进行分析。</p>
<h2 id="Block-的存储域以及内存生命周期分析"><a href="#Block-的存储域以及内存生命周期分析" class="headerlink" title="Block 的存储域以及内存生命周期分析"></a>Block 的存储域以及内存生命周期分析</h2><h3 id="Block-存储域"><a href="#Block-存储域" class="headerlink" title="Block 存储域"></a>Block 存储域</h3><p><code>Block</code> 存储域分为三种类型：栈上(_NSConcreteStackBlock)，堆上(_NSConcreteMallocBlock)和数据区(_NSConcreteGlobalBlock)。上面的例子中<code>Block</code>都是存在栈上的，和普通的变量一样声明在函数外的话<code>Block</code>就是存在数据区中，比如下面这种 case:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void) = ^() &#123;</span><br><span class="line">    NSLog(@&quot;hello world&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Block</code> 就是存储在数据区，<code>clang -rewrite-objc main.m</code> 之后生成的代码中，<code>Block</code> 初始化方法中有这样一行 <code>impl.isa = &amp;_NSConcreteGlobalBlock;</code>，说明 <code>Block</code> 所属的类是 <code>_NSConcreteGlobalBlock</code>。</p>
<p>值得分析的是，<code>Block</code> 存储域存在堆上的情况，&lt;OC 高级编程&gt; 一书举了如下的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef int(^blk_t)(int);</span><br><span class="line">blk_t func(int rate) &#123;</span><br><span class="line">    return ^(int count) &#123; return rate *count; &#125;;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    blk_t blk = func(5);</span><br><span class="line">    NSLog(@&quot;%d&quot;,blk(10));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>func()</code>方法中<code>Block</code>作为了返回值返回，按道理来讲 <code>Block</code> 超出其函数作用域之后就会被销毁，但是在 ARC 环境下这个 <code>main.m</code> 能正常输出执行结果。当我们修改 <code>main.m</code> 文件的编译选项为 <code>-fno-objc-arc</code> 的时候编译器会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error&quot;Returning block that lives on the local stack</span><br></pre></td></tr></table></figure>

<p>说明是 ARC 下编译器帮我们做了一些事情，避免了 <code>block</code> 在栈上不能返回的问题。将非 ARC 下的代码修改为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blk_t func(int rate) &#123;</span><br><span class="line">    return [^(int count) &#123; return rate *count; &#125; copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>才能避免编译失败问题，并正确得到执行结果。</p>
<p>书上给出的在 ARC 下<code>func</code>方法编译完后大致的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blk_t func(int rate) &#123;</span><br><span class="line">   blk_t tmp = ((int (*)(int))&amp;__func_block_impl_0((void *)__func_block_func_0, &amp;__func_block_desc_0_DATA, rate));</span><br><span class="line">   tmp = objc_retainBlock(tmp);</span><br><span class="line">   return objc_autoreleaseReturnValue(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即 ARC 下编译器对本身是存在于栈上的<code>Block</code>对象执行了一次<code>copy</code>操作，转移到堆上。</p>
<blockquote>
<p> 运行时库中 <code>NSObject.mm</code> 文件中可以看到<code>objc_retainBlock</code>就是<code>_Block_copy</code>方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id objc_retainBlock(id x) &#123;</span><br><span class="line">    return (id)_Block_copy(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分情况下编译器都会处理将栈上的<code>Block</code>复制到堆上的 case.</p>
<h3 id="Block-内存分析"><a href="#Block-内存分析" class="headerlink" title="Block 内存分析"></a>Block 内存分析</h3><p>存在栈上的<code>Block</code>，如果所属的作用域结束，该<code>Block</code>就被废弃，由于<code>__block</code>修饰的变量也在栈上那么<code>__block</code>修饰的变量也会被废弃。</p>
<blockquote>
<p>使用栈来存储变量的优点是内存是自动为你管理的。你无需手动分配内存，或者在你不再需要时释放内存。<a href="https://tomatosx.github.io/技术学习/2018/03/14/内存-栈和堆-C-Swift/" target="_blank" rel="noopener">参考地址</a></p>
</blockquote>
<p>刚才说过在 ARC 下，编译器会自动将 <code>Block</code> 从栈上复制到堆上，使用的方法为 <code>_Block_copy</code> 下面是官方的的 API 说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Create a heap based copy of a Block or simply add a reference to an existing one. This must be paired with Block_release to recover memory, even when running under Objective-C Garbage Collection.</span><br><span class="line">BLOCK_EXPORT void *_Block_copy(const void *aBlock)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br><span class="line">//Lose the reference, and if heap based and last reference, recover the memory</span><br><span class="line">BLOCK_EXPORT void _Block_release(const void *aBlock)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br></pre></td></tr></table></figure>

<p>即使用 <code>_Block_copy</code> 可以创建基于堆上的一份儿<code>Block</code>的复制，同时<code>_Block_copy</code>一定是配合<code>_Block_release</code>使用，否则会造成内存泄漏。</p>
<p><img src="/media/15268076432722.jpg" alt></p>
<h2 id="Block-捕获成员变量的生命周期"><a href="#Block-捕获成员变量的生命周期" class="headerlink" title="Block 捕获成员变量的生命周期"></a>Block 捕获成员变量的生命周期</h2><h3 id="Block-捕获普通对象的生命周期分析"><a href="#Block-捕获普通对象的生命周期分析" class="headerlink" title="Block 捕获普通对象的生命周期分析"></a>Block 捕获普通对象的生命周期分析</h3><p>捕获普通自动变量对象 A 的话，<code>Block</code> 会影响普通自动变量的生命周期，即自动变量作用域结束，A 并不会被立即释放。而是跟捕获了它的 <code>Block</code> 的生命周期同步。原因是为了捕获自动变量 A，<code>Block</code> 对象内部会生成一个捕获对象的同类型的对象 A’ 来对捕获对象进行持有，即使得 A 的引用计数加一。所以当 A 的作用域结束之后 A 依然能存活，直到 <code>Block</code> 被释放，A 跟着一起被释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    blk_t blk;</span><br><span class="line">    &#123;</span><br><span class="line">        Fan *fan = [[Fan alloc] init];</span><br><span class="line">        blk = ^() &#123;</span><br><span class="line">            NSLog(@&quot;a = %@&quot;,fan);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编译完的这部分代码中包含如下代码，这是为了管理<code>__block</code>结构体中捕获的对应外部变量的<code>fan</code>的内存而生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  Fan *fan;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;fan, (void*)src-&gt;fan, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;fan, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的代码中这两个方法并没有被调用，而是当<code>Block</code>被从栈上拷到堆上，以及在堆上被释放的时候才会被调用。如图：</p>
<p><img src="/media/15268143127436.jpg" alt></p>
<p>但是实践中很奇怪的一点是在 ARC 环境下，对<code>Block</code>对象进行了 copy 操作还是没能触发<code>_Block_object_assign</code>这个方法的执行，但是在 MRC 环境下同样条件就能触发<code>_Block_object_assign</code>这个方法。这里 ARC 编译后的代码应该是做了一些额外的操作。</p>
<h3 id="Block-捕获带有-block-修饰符对象的声明周期分析"><a href="#Block-捕获带有-block-修饰符对象的声明周期分析" class="headerlink" title="Block 捕获带有 __block 修饰符对象的声明周期分析"></a>Block 捕获带有 __block 修饰符对象的声明周期分析</h3><p>如果被<code>__block</code>修饰的对象是自动变量，而且<code>Block</code>并没有执行从栈拷贝到堆上的操作，那和普通的自动变量对象一样并没有什么区别，<code>__block</code>修饰的对象也是跟着<code>Block</code>对象一起释放。</p>
<p>但是实际情况里<code>__block</code>修饰对象可能存在栈上，可能存在堆上，而<code>Block</code>对象也有可能从栈上被复制到堆上，这些场景下，<code>__block</code>修饰对象的生命周期是什么样的？</p>
<p><img src="/media/15268110185323.jpg" alt></p>
<p>当<code>Block</code>捕获带有<code>__block</code>修饰符的自动变量的时候，编译后代码出现下面的一些源码，即 <code>Block</code>对象除了管理自己的内存之外还要额外操心<code>__block</code>修饰变量的内存了。</p>
<p>这里 <code>__block</code>变量对象内存管理和普通的引用计数管理思想基本一致了，即哪个<code>Block</code>对象持有了<code>__block</code>变量，则该<code>Block</code>对象有义务对<code>__block</code>变量进行释放。当所有<code>Block</code>都被释放的时候<code>__block</code>变量也跟着一起释放掉。</p>
<h2 id="GCD-里面的-Block-分析"><a href="#GCD-里面的-Block-分析" class="headerlink" title="GCD 里面的 Block 分析"></a>GCD 里面的 Block 分析</h2><p>GCD 提供的 API 里大量使用了 Block 作为参数，比如我们常用的 API <code>dispatch_async(queue, ^(void){})</code> 等，通常来说，我们并不需要过分关注 API 中 Block 的内存管理。因为 GCD 会自动帮我们处理，参考 <code>dispatch_async</code> API 的官方说明(其实 <code>dispatch_after</code> API 里也是这么说的)</p>
<blockquote>
<p>dispatch_async 参数 block 的解释<br>The block to submit to the target dispatch queue. This function performs Block_copy and Block_release on behalf of callers. This parameter cannot be NULL.<br>即这个方法会自动在合适的时机执行 <code>Block_Copy</code> 和 <code>Block_release</code> 两个方法。这样就保证了在执行 Block 之前不会因为 Block 的作用域的原因而是的 Block 提前被释放，将 Block 放到堆上是比较安全的做法。</p>
</blockquote>
<p>现在有个问题，Block 被谁持有了？通过写 demo 打符号断点 <code>_Block_copy</code>，跟到了其上一步调用 <code>_dispatch_Block_copy</code> ，然后在 GCD 的 <a href="https://opensource.apple.com/source/libdispatch/libdispatch-84.5/src/queue.c" target="_blank" rel="noopener">queue.c 源码</a>中找到了答案，是一个 <code>dispatch_block_t</code> 的类型的变量持有了 Block 对象。</p>
<p>关于 GCD 里面的 Block 里面是否应该使用 self，YYKit 的一个 <a href="https://github.com/ibireme/YYKit/issues/41" target="_blank" rel="noopener">issue</a> 里讨论的比较火热。但是很多评论都是有问题的，包括 YY 的理解都是有问题的，YY 对 block 的理解就是「self-&gt;_queue-&gt;block-&gt;self 这不是循环引用吗」但是根据我们刚才的分析，其实 GCD 的 queue 并没有持有 block，GCD 的 Block 内存管理跟当前执行所在的类没有任何关系，系统负责<code>Block_Copy</code>和<code>Block_release</code>，我理解这种 case 算不上循环引用。所以可以放心的在 GCD 里面使用 self，而不需要 weak dance.</p>
<blockquote>
<p>Block_Copy 内部的实现机制可以参考<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">这篇文章</a> </p>
</blockquote>
<p>还有一个 GCD 中应该注意的内存问题，即 ARC 和 dispatch queues 以及 GCD Block 内存管理之间的关系。<br>需要分类讨论</p>
<ol>
<li><p>If your deployment target is lower than iOS 6.0 or Mac OS X 10.8</p>
<blockquote>
<p>You need to use <code>dispatch_retain</code> and <code>dispatch_release</code> on your queue. ARC does not manage them.</p>
</blockquote>
</li>
<li><p>If your deployment target is iOS 6.0 or Mac OS X 10.8 or later</p>
<blockquote>
<p>ARC will manage your queue for you. You do not need to (and cannot) use <code>dispatch_retain</code> or <code>dispatch_release</code> if ARC is enabled.</p>
</blockquote>
</li>
</ol>
<p><a href="https://stackoverflow.com/questions/8618632/does-arc-support-dispatch-queues" target="_blank" rel="noopener">参考地址 - Does ARC support dispatch queues?</a></p>
<p>在 MRC 下 GCD 也会自动执行 <code>Block_Copy</code> 和 <code>Block_Release</code> 方法，所以在 MRC 下的 GCD Block 里面继续使用 self 也不会产生内存的问题。</p>
<p>总结就是在古老的系统中，即使编译器开启了 ARC 也不一定能管理 <code>dispatch_object</code> 对象，还好我们现在早已经过了兼容的那个阶段。</p>
<h2 id="MRC-amp-ARC-下-Block-内存管理区别"><a href="#MRC-amp-ARC-下-Block-内存管理区别" class="headerlink" title="MRC &amp; ARC 下 Block 内存管理区别"></a>MRC &amp; ARC 下 Block 内存管理区别</h2><p>MRC 和 ARC 下 Block 内存管理的区别主要在于 MRC 下并不会对<code>Block</code>进行主动 copy 操作。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">blk returnblk() &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    blk tempblk = ^()&#123;</span><br><span class="line">        NSLog(@&quot;hello world,a = %d&quot;,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    return tempblk;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    blk newblk = returnblk();</span><br><span class="line">    newblk();  ①</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MRC 下在 ① 的位置打断点，观察 <code>newblk</code> 的类型为 <code>__NSStackBlock__</code>，同样断点ARC 下观察到 <code>newblk</code> 的类型为 <code>__NSMallocBlock__</code>。说明在 ARC 下 <code>tempblk</code> 在返回的时候自动执行了一次 copy 操作。</p>
<p>还有一个更经典的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface Fan : NSObject &#123;</span><br><span class="line">    dispatch_queue_t queue;</span><br><span class="line">    Blk blk;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        blk = ^() &#123;NSLog(@&quot;self %@&quot;,self);&#125;; </span><br><span class="line">        ①</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MRC 下在①处打断点，<code>blk</code> 的类型为 <code>__NSStackBlock__</code>，同样断点ARC 下观察到 <code>blk</code> 的类型为 <code>__NSMallocBlock__</code>。ARC 自动在给成员变量 <code>blk</code> 赋值的时候进行了一次 copy 操作。上面这个例子还引出了一个循环引用的问题，我们下面说。</p>
<h3 id="MRC-下-retain-方法使用注意"><a href="#MRC-下-retain-方法使用注意" class="headerlink" title="MRC 下 retain 方法使用注意"></a>MRC 下 retain 方法使用注意</h3><p>MRC 下还需要注意的是，如果<code>Block</code>在栈上的话，对<code>Block</code>进行 retain 操作没有任何意义。必须对其进行 copy 操作才能将其从栈上复制到堆上。如果<code>Block</code>在堆上的话，对其进行 retain 操作，<code>Block</code>对象的引用计数会加一。</p>
<blockquote>
<p>在对 <code>Block</code> 对象进行 copy 操作的时候，<code>Block_copy</code> 方法和 <code>copy</code> 方法执行的效果是一样的，同理，<code>Block_release</code> 和 <code>release</code> 方法效果也一样。</p>
</blockquote>
<h3 id="MRC-下破解循环引用的方式"><a href="#MRC-下破解循环引用的方式" class="headerlink" title="MRC 下破解循环引用的方式"></a>MRC 下破解循环引用的方式</h3><p>对于 MRC 下，为了防止循环引用，我们使用<code>__block</code>来修饰在Block中使用的对象。</p>
<blockquote>
<p>原因是在当 Block 被从栈拷贝到堆上的时候，不会对带有<code>__block</code>修饰符的自动变量对象进行 retain 操作，不带有 <code>__block</code>修饰符的自动变量对象会被 retain 操作。<br>所以上面的例子需要现用 <code>__block id temp = self;</code> 也对 <a href="[]()"></a>self 进行一次引用，然后在 <code>block</code> 里面使用 temp.</p>
</blockquote>
<p>对于 ARC 下，为了防止循环引用，我们使用<code>__weak</code>来修饰在Block中使用的对象。</p>
<h2 id="Block-weak-分析-strongSelf-分析"><a href="#Block-weak-分析-strongSelf-分析" class="headerlink" title="Block __weak 分析 / __strongSelf 分析"></a>Block __weak 分析 / __strongSelf 分析</h2><p>关于Block weak 和 strong 的说明，这两个配合使用存在的意义就是让 block 避免循环引用。举个例子，在视图控制器 (VC) 的 <code>viewDidLoad</code> 方法里执行如下代码 ,<code>FRButton</code> 内部持有了这个点击 <code>block</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">[button setClickBlk:^&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;strongSelf = %@&quot;,strongSelf);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>当 dismiss 的时候，VC 并没有被释放，而是等 <code>dispatch_after</code> 的 block 执行之后 VC 才被释放。<br>分析在 button 赋值 block 对象时候 <code>__weak</code> 和 <code>__strong</code> 的用法，通过引用计数和持有关系进行内存分析。</p>
<ol>
<li>首先在 button block 的外部使用 <code>__weak</code> 对 <code>self</code> 进行持有，并没有增加 <code>self</code> 的引用计数。</li>
<li>在 button block 内部进行对 <code>weakSelf</code> 进行 <code>__strong</code> 修饰符的 <code>strongSelf</code> 持有，增加了 <code>self</code> 的引用计数</li>
<li>分析一下引用关系啊， VC 持有了 button，button 内部持有了 <code>block</code>，<code>block</code> 捕获的是 VC 的 <code>weakSelf</code>。 Block 里面的 <code>strongSelf</code> 仅仅是个自动变量而已（看上面 clang 编译出来的代码就知道，<code>strongSelf</code> 应该是在编译后的闭包函数对应的内联方法里声明的），不用分析其引用关系。但是 <code>strongSelf</code> 增加了 VC 的引用计数。</li>
<li>当点击之后，然后用另外的方法让 VC 迅速(3秒) dismiss，这个时候 VC 并没有被释放，因为 <code>strongSelf</code> 增加了 VC 的引用计数。而 <code>dispatch_after</code> 的 block 持有了 strongSelf，<code>dispatch_after</code> 的 block 在延时 3秒后执行，执行完之后 <code>dispatch_after</code> 的 strongSelf 也被释放(自动变量作用域结束自动被回收)，这个时候 VC 的引用计数变为 0 才会被释放。此时 weakSelf 被置为了 nil，第 3 步里面的引用关系断掉了，即 Block 不再持有 VC 了。所以不会出现循环引用的问题。</li>
</ol>
<p>释放顺序是：1、 VC; 2、Button;3、Block。</p>
<blockquote>
<p><strong>误区一</strong>，<code>Block</code>捕获<code>__weak</code>修饰符的对象，虽然我们不能通过执行 <code>clang -rewrite-objc BlockDemo/main.m</code> 来看最后的编译结果（会报错，<code>cannot create __weak reference because the current deployment target does
      not support weak references</code>），但我猜原理是<code>Block</code>对象结构体内部直接生成一个 <code>__weak</code>修饰的成员变量指向<code>__weak</code>修饰的对象，而不是生成<code>__block</code>修饰的那种结构来，这样才能保证<code>Block</code>不会对<code>self</code>进行强持有来增加引用计数。<br><strong>误区二</strong>，另外一个之前分析时候陷入误区的点是，总会纠结<code>block</code>里面的代码会不会执行，其实执行与否都不会影响当前这种结构的的内存分析，执行匿名函数代码的话<code>strongSelf</code>到最后会被释放，<code>block</code>跟着一起释放。不执行的话<code>self</code>其实也没有强持有<code>block</code>，所以不会造成内存引用问题。</p>
</blockquote>
<p>正是因为误区二，我们引出另外一个问题，即在下面的①的位置添加了一个判断，有必要吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">[networkManager fetchFinishBlk:^(response)&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    if (nil == strongSelf) &#123;  ①</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [strongSelf xxx];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>之前总是觉得 <code>strongSelf</code> 会强引用 <code>self</code>，所以 <code>self</code> 在执行 <code>block</code> 闭包函数之前不会被释放，其实有可能在执行 <code>block</code> 之前，<code>self</code> 已经被释放掉了，则 <code>weakSelf</code> 为 <code>nil</code>, 这个时候 <code>strongSelf</code> 还没有来得及增加的引用计数呢… 所以加上这个判断是必要的。</p>
<p>那又引出一个问题，如果我一定想要执行 <code>block</code> 闭包函数里的方法呢，可以参考<a href="https://juejin.im/entry/594a2aa8ac502e5490f9598d" target="_blank" rel="noopener">这篇文章</a>里的做法，大体思路是先触发循环引用，然后在 <code>block</code> 执行完毕之后再将循环引用破解掉。</p>
<p>再进一步思考，如果是下面这种情况，会造成循环引用吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">[cell setEditPressedBlk:^&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf = weakSelf; ①</span><br><span class="line">    [strongSelf pickerCancel];</span><br><span class="line">    strongSelf.textFiledView = [TFAlertView Title:@&quot;Title&quot; message:@&quot;&quot; complete:^(NSString *text, TFAlertView *alertview) &#123;</span><br><span class="line">        [strongSelf modifyNameWithValue:text];  ②</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="一些常见的关于-Block-的面试题"><a href="#一些常见的关于-Block-的面试题" class="headerlink" title="一些常见的关于 Block 的面试题"></a>一些常见的关于 Block 的面试题</h2><p><strong>Q: Block 作为对象的属性应该用 copy 修饰还是 strong 修饰??</strong><br>A: 在 MRC 下的话，必须用 copy 修饰，用 retain 修饰的话，栈上的 Block 无法被拷贝对堆上，导致使用的时候可能出问题。<br>   在 ARC 下用 strong 即可，当给 block 属性赋值的时候会自动将栈上的 block 拷贝到堆上，用 copy 的话效果是一样的，但是苹果的官方文档还是建议我们即使是在 ARC 上也使用 copy 修饰符，因为 copy 会显式地说明我们对 block 的操作。同时，我们的工程偶尔也会看到给 block 属性进行赋值的时候，手动添加了一个 copy 方法，比如 <code>self.block = [blk copy];</code> 其实是完全没有必要的。<br>官方地址 - <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW12" target="_blank" rel="noopener">Objects Use Properties to Keep Track of Blocks</a></p>
<p>#参考地址#<br><a href="https://developer.apple.com/videos/play/wwdc2012/712/" target="_blank" rel="noopener">WWDC_712</a><br><a href="shttps://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html" target="_blank" rel="noopener">Blocks Programming Topic</a><br><a href="https://draveness.me/block-retain-object" target="_blank" rel="noopener">iOS 中的 block 是如何持有对象的</a><br><a href="https://www.jianshu.com/p/ee9756f3d5f6" target="_blank" rel="noopener">深入研究Block捕获外部变量和__block实现原理</a><br><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">A look inside blocks: Episode 3 (Block_copy)</a><br><a href="https://elliotsomething.github.io/2016/07/28/OC高级编程学习总结之GCD-一/" target="_blank" rel="noopener">OC高级编程学习总结之GCD</a><br><a href="https://blog.csdn.net/abc649395594/article/details/45476925" target="_blank" rel="noopener"><strong>weak与</strong>block修饰符到底有什么区别</a><br><a href="https://blog.6ag.cn/1186.html" target="_blank" rel="noopener">Block在ARC和MRC下的使用分析</a><br><a href="http://ios.jobbole.com/88708/" target="_blank" rel="noopener">深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用</a><br><a href="https://juejin.im/entry/594a2aa8ac502e5490f9598d" target="_blank" rel="noopener">循环引用的破局法门</a><br><a href="https://www.jianshu.com/p/a5dd014edb13" target="_blank" rel="noopener">深入分析 Objective-C block、weakself、strongself 实现原理</a></p>
<p>最后送上两个关于 block 的语法说明</p>
<ol>
<li><a href="https://weibo.com/1765732340/GfRtraOYj?type=comment" target="_blank" rel="noopener">https://weibo.com/1765732340/GfRtraOYj?type=comment</a></li>
<li><a href="http://fuckingblocksyntax.com" target="_blank" rel="noopener">http://fuckingblocksyntax.com</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/05/Objective-C-里的拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/Objective-C-里的拷贝/" itemprop="url">Objective-C 里的拷贝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-05T18:21:42+08:00">2018-03-05</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/03/05/Objective-C-里的拷贝/" class="leancloud_visitors" data-flag-title="Objective-C 里的拷贝">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Objective-C</code> 语言里的拷贝就是对象拷贝，即创建一个跟之前的实例对象一模一样的对象。一般来说数据模型类是需要支持拷贝的。<code>Objective-C</code> 里拷贝又分为浅拷贝（<code>shallow-copy</code>）和深拷贝（<code>deep-copy</code>）。</p>
<h1 id="浅拷贝和深拷贝区别"><a href="#浅拷贝和深拷贝区别" class="headerlink" title="浅拷贝和深拷贝区别"></a>浅拷贝和深拷贝区别</h1><p>浅拷贝只是复制一下对象指针，但是拷贝前和拷贝后的对象指针均指向同一内存区域，只不过是对象的内存引用计数加一。<br>深拷贝为拷贝前和拷贝后的对象指针指向不同的内存区域，即会创建一个新的对象。<br>下图比较直观清楚。<br><img src="/media/Jietu20180305-184629.png" alt="Jietu20180305-184629"></p>
<p>一个非常容易产生的误区就是，遵从了 <code>NSCopying</code> 协议的对象都会执行深拷贝。其实不然，<code>Foundation</code> 框架里大部分类执行的还是浅拷贝。比如 <code>NSString</code> 等。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;hello&quot;];</span><br><span class="line">NSString *copyStr = [str copy];</span><br><span class="line">NSLog(@&quot;str = %p,copyStr = %p&quot;,str ,copyStr);</span><br><span class="line">---</span><br><span class="line">&gt; str = 0x6f6c6c656855,copyStr = 0x6f6c6c656855</span><br><span class="line">&gt; str 在 copy 前后指向的内存地址都一模一样。</span><br></pre></td></tr></table></figure>

<p>还有一点注意的是，虽然有浅拷贝和深拷贝的概念，<strong>但是并没有专门定义深拷贝的协议</strong>。这点很关键，这意味着除非有文档是写用深拷贝实现 <code>NSCopying</code> 协议的，否则深拷贝的实现都是需要开发者自己去手写实现，而不能依赖于系统框架的实现。</p>
<h1 id="Copy-实例方法和-NSCopying-协议"><a href="#Copy-实例方法和-NSCopying-协议" class="headerlink" title="Copy 实例方法和 NSCopying 协议"></a>Copy 实例方法和 NSCopying 协议</h1><p><code>NSObject</code> 有名为 <code>copy</code> 和 <code>mutableCopy</code> 的实例方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (id)copy;</span><br><span class="line">- (id)mutableCopy;</span><br></pre></td></tr></table></figure>

<p><code>NSCopying</code> 协议的方法为 <code>-(id)copyWithZone:(nullable NSZone *)zone</code>。（<code>zone</code> 目前没有任何意义）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSCopying</span><br><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这个实例方法和协议方法有啥关联呢？其实调用 <code>NSObject</code> 的 <code>copy</code> 实例方法就是调用  <code>NSCopying</code> 协议约定的 <code>copyWithZone</code> 方法。同理的，调用 <code>NSObject</code> 的 <code>mutableCopy</code> 实例方法就是调用 <code>NSMutableCopying</code> 协议的 <code>mutableCopyWithZone</code> 方法。</p>
<p>需要注意的是，因为 <code>NSObject</code> 类并不支持 <code>NSCopying</code> 协议，所以继承 <code>NSObject</code> 的子类如果不实现 <code>NSCopying</code> 协议的 <code>copyWithZone</code> 方法会导致应用异常。 见下面 <code>demo</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface FRModel : NSObject</span><br><span class="line">@end</span><br><span class="line">@implementation FRModel</span><br><span class="line">@end</span><br><span class="line">---</span><br><span class="line">FRModel *model = [[FRModel alloc] init];</span><br><span class="line">[model copy];</span><br><span class="line">&gt; -[FRModel copyWithZone:]: unrecognized selector sent to instance 0x1004004c0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>copy</code> <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418807-copy?language=objc#" target="_blank" rel="noopener">API 说明</a><br>Returns the object returned by copyWithZone:.</p>
</blockquote>
<p>因为 <code>NSObject</code> 并没有实现 <code>NSCopying</code> 协议，即没有实现 <code>copyWithZone:</code> 方法，所以 <code>FRModel</code> 需要单独实现 <code>copyWithZone:</code> 方法。有一个误区是子类直接复写 <code>copy</code> 方法，这是不正确的操作方式，要避免。</p>
<h1 id="Copy-和-MutableCopy"><a href="#Copy-和-MutableCopy" class="headerlink" title="Copy 和 MutableCopy"></a>Copy 和 MutableCopy</h1><p>上面说了 <code>NSObject</code> 有 <code>copy</code> 和 <code>mutableCopy</code> 两个实例方法。对应的也有两个协议， <code>NSCopying(copyWithZone:)</code> 和 <code>NSMutableCopying(mutableCopyWithZone:)</code>。虽然名字比较像但是这是两个不同的类，即如果你的类只实现了 <code>NSCopying</code> 协议，这时候给你发 <code>mutableCopy</code> 方法的话还是照样会异常，这两个也没有任何包含关系，把这两个类理解为单独的协议就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FRModel *model = [[FRModel alloc] init];</span><br><span class="line">model.name = @&quot;Frank&quot;;</span><br><span class="line">FRModel *copyModel = [model mutableCopy];</span><br><span class="line">NSLog(@&quot;model = %p,copymodel = %p&quot;,model,copyModel);</span><br><span class="line">NSLog(@&quot;model.name = %p,copymodel.name = %p&quot;,model.name,copyModel.name);</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[FRModel mutableCopyWithZone:]: unrecognized selector sent to instance 0x100532040&apos;</span><br></pre></td></tr></table></figure>

<h2 id="什么时候用-Copy-什么时候用-MutableCopy"><a href="#什么时候用-Copy-什么时候用-MutableCopy" class="headerlink" title="什么时候用 Copy 什么时候用 MutableCopy?"></a>什么时候用 Copy 什么时候用 MutableCopy?</h2><p>我们可以看下 <code>NSMutableCopying</code> 的<a href="https://developer.apple.com/documentation/foundation/nsmutablecopying?language=objc" target="_blank" rel="noopener">协议说明</a> </p>
<blockquote>
<p>The <code>NSMutableCopying</code> protocol declares a method for providing mutable copies of an object.<br>Only classes that define an “immutable vs. mutable” distinction should adopt this protocol. Classes that don’t define such a distinction should adopt <code>NSCopying</code> instead.<br> <code>NSMutableCopying</code> 声明了提供可对象可变副本的方法，只有区分可变和不可变的类应该遵守这个协议，不区分可变不尅版的话就直接用 NSCopying 方法就好了。</p>
</blockquote>
<p>举个例子，我们日常使用的包括可变类型的类是 <code>NSString(NSMutableString)</code>，<code>NSArray(NSMutableArray)</code>，<code>NSDictionary(NSMutableDictionary)</code>以及<code>NSSet(NSMutableSet)</code> 这些类都是同时遵守了 <code>NSCopying</code> 和 <code>NSMutableCopying</code> 协议的。一般来说，我们自己用到的类很少有是可变类型的，所以也很少看到有自己的类实现 <code>NSMutableCopying</code> 协议。</p>
<p>如果要实现的话基本遵守如下原则：</p>
<ol>
<li>向可变(<code>mutable</code>)或者不可变(<code>immutable</code>)对象发送 <code>copy</code> 消息，得到的都是不可变(<code>immutable</code>)对象。</li>
<li>向可变(<code>mutable</code>)或者不可变(<code>immutable</code>)对象发送 <code>mutableCopy</code> 消息，得到的都是可变(<code>mutable</code>)对象。<br>举个例子验证一下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;hello&quot;];</span><br><span class="line">NSMutableString *copyStr = [str mutableCopy]; //得到可变对象.</span><br><span class="line">[copyStr appendString:@&quot; world&quot;];</span><br><span class="line">NSLog(@&quot;str = %p,copyStr = %p&quot;,str ,copyStr);</span><br><span class="line">NSLog(@&quot;str class = %@,copyStr class = %@&quot;,NSStringFromClass([str class]) ,NSStringFromClass([copyStr class]));</span><br><span class="line">NSLog(@&quot;str = %@,copyStr = %@&quot;,str ,copyStr);</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo str = 0x6f6c6c656855, copyStr = 0x10044a960</span><br><span class="line">&gt; FRCopyDemo str class = NSTaggedPointerString, copyStr class = __NSCFString</span><br><span class="line">&gt; FRCopyDemo str = hello, copyStr = hello world</span><br></pre></td></tr></table></figure>

<p>通过输出结果基本上验证了以上的结论。<br>这儿还有一点比较有意思的事儿是，关于 <code>mutableCopy</code> 和深拷贝的关系。我们看到 <code>mutableCopy</code> 之后对象的指针发生了变化，内容并没有发生变化。但其实对象指针类型已经发生了变化。所以跟我们之前说的拷贝多少还是有区别的（正常的拷贝指针类型是不会发生变化的）。只要搞清楚这些不同的概念，就能理解这些概念的区别所在。</p>
<h1 id="怎样让我们的对象支持-copy"><a href="#怎样让我们的对象支持-copy" class="headerlink" title="怎样让我们的对象支持 copy"></a>怎样让我们的对象支持 copy</h1><p>完整的回答应该是：让类实现 <code>NSCopying</code> 协议里的 <code>copyWithZone</code>: 方法，如果对象是可变的应该同时实现 <code>NSMutableCopying</code> 的 <code>mutableCopyWithZone:</code> 方法。</p>
<h1 id="copyWithZone-方法的最佳实践"><a href="#copyWithZone-方法的最佳实践" class="headerlink" title="copyWithZone: 方法的最佳实践"></a>copyWithZone: 方法的最佳实践</h1><p>一般开发者自己实现 <code>copyWithZone:</code> 方法的时候通常都是实现深拷贝，而非浅拷贝。因为浅拷贝确实没啥好实现的。深拷贝的实现需要考虑其父类是否也遵守了 <code>NSCopying</code> 协议，实现了 <code>copyWithZone:</code> 方法。<br>比如继承自 <code>NSObject</code> 的 <code>FRModel</code> 类按如下方式实现 <code>copyWithZone:</code> 方法，这样显然是会异常的（实际上连编译都不会编译过去）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface FRModel : NSObject&lt;NSCopying&gt;</span><br><span class="line">@end</span><br><span class="line">@implementation FRModel</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    FRModel *frmodel = [[super allocWithZone:zone] init];</span><br><span class="line">    return frmodel;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>稍作修改，如果父类没有实现的话子类直接重新创建一个就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface FRModel : NSObject&lt;NSCopying&gt;</span><br><span class="line">@end</span><br><span class="line">@implementation FRModel</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    FRModel *frmodel = [[[self class] allocWithZone:zone] init];</span><br><span class="line">    return frmodel;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果该类还有属性或者成员变量的话，可以直接对成员变量执行 <code>copy</code> 操作。参考如下 demo:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface FRModel : NSObject&lt;NSCopying&gt;</span><br><span class="line">@property (nonatomic,strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line">@implementation FRModel</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    FRModel *frmodel = [[FRModel allocWithZone:zone] init];</span><br><span class="line">    if (frmodel) &#123; frmodel.name = [_name copyWithZone:zone]; &#125;</span><br><span class="line">    return frmodel;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">FRModel *model = [[FRModel alloc] init];</span><br><span class="line">model.name = @&quot;Frank&quot;;</span><br><span class="line">FRModel *copyModel = [model copy];</span><br><span class="line">NSLog(@&quot;model = %p,copymodel = %p&quot;,model,copyModel);</span><br><span class="line">NSLog(@&quot;model.name = %p,copymodel.name = %p&quot;,model.name,copyModel.name);</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo model = 0x102803520,copymodel = 0x102803530</span><br><span class="line">&gt; FRCopyDemo model.name = 0x1000010d0,copymodel.name = 0x1000010d0</span><br></pre></td></tr></table></figure>

<p>注意因为 <code>NSString</code> 类型本身 <code>copyWithZone:</code> 属性为浅拷贝，所以最后输出结果两个类的 <code>name</code> 属性的指针指向相同。</p>
<p><a href="https://stackoverflow.com/questions/9907154/best-practice-when-implementing-copywithzone" target="_blank" rel="noopener">Best practice when implementing copywithzone</a></p>
<h1 id="集合类型拷贝"><a href="#集合类型拷贝" class="headerlink" title="集合类型拷贝"></a>集合类型拷贝</h1><p><code>Foundation</code> 框架中所有集合类型在默认情况下都执行浅拷贝，也就是说，只拷贝容器对象本身，而不复制其中数据。这样做的原因在于，容器内的对象未必能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中每一个对象。</p>
<p>集合类型的浅拷贝和深拷贝的概念和普通对象的深浅拷贝略有不同。</p>
<ol>
<li>集合类型的浅拷贝是指，当执行浅拷贝的时候，原始集合类型里的对象都收到一个 <code>retain</code> 消息，对象指针被复制到新的集合类型里。</li>
<li>集合类型的深拷贝是指，当执行深拷贝的时候，原始集合里的对象都会收到一个 <code>copyWithZone:</code>，即集合里的对象需要实现 <code>NSCopying</code> 协议来实现深拷贝。如果集合里的对象并没有实现 <code>NSCopying</code> 则程序会异常。<br>如图所示<br><img src="/media/15203089948766.jpg" alt><br>浅拷贝 demo: </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">NSArray *arr = [NSArray arrayWithObject:obj];</span><br><span class="line">NSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:NO];</span><br><span class="line">NSLog(@&quot;arr = %p,copyArr = %p&quot;,arr ,copyArr);</span><br><span class="line">NSLog(@&quot;arr model = %p,copyArr model = %p&quot;,[arr objectAtIndex:0],[copyArr objectAtIndex:0]);</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo arr = 0x100462b40,copyArr = 0x100461400</span><br><span class="line">&gt; FRCopyDemo arr model = 0x100400640,copyArr model = 0x100400640</span><br></pre></td></tr></table></figure>

<p>里面使用了 <code>initWithArray:copyItems:</code> 这个方法，传入 NO 即为浅拷贝。通过打印日志可以看到集合对象指针虽然发生了变化，但是集合内部元素的对象指针还是指向同样的内存区域。</p>
<p>深拷贝 demo: (将 <code>initWithArray:copyItems:</code> 方法第二个参数传入 YES 即为深拷贝)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">NSArray *arr = [NSArray arrayWithObject:obj];</span><br><span class="line">NSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:YES];</span><br><span class="line">NSLog(@&quot;arr = %p,copyArr = %p&quot;,arr ,copyArr);</span><br><span class="line">NSLog(@&quot;arr model = %p,copyArr model = %p&quot;,[arr objectAtIndex:0],[copyArr objectAtIndex:0]);</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo -[NSObject copyWithZone:]: unrecognized selector sent to instance 0x100688490</span><br><span class="line">&gt; FRCopyDemo *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[NSObject copyWithZone:]: unrecognized selector sent to instance 0x100688490&apos;</span><br></pre></td></tr></table></figure>

<p>因为 <code>NSObject</code> 没有实现 <code>NSCopying</code> 协议，所以集合类型深拷贝时，集合元素 <code>NSObject</code> 对象收到 <code>copyWithZone:</code> 之后异常了。我们将 NSObject 类型修改为 <code>NSMutableString</code> 再次运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSMutableString *obj = [NSMutableString stringWithFormat:@&quot;hello world&quot;];</span><br><span class="line">NSArray *arr = [NSArray arrayWithObject:obj];</span><br><span class="line">NSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:YES];</span><br><span class="line">NSLog(@&quot;arr = %p,copyArr = %p&quot;,arr ,copyArr);</span><br><span class="line">NSLog(@&quot;arr model = %p,copyArr model = %p&quot;,[arr objectAtIndex:0],[copyArr objectAtIndex:0]);</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo arr = 0x100406dc0,copyArr = 0x100403fb0</span><br><span class="line">&gt; FRCopyDemo arr model = 0x100406780,copyArr model = 0x100405260</span><br></pre></td></tr></table></figure>

<p>可以看到集合内的元素执行了不同的内存地址，因为 <code>NSMutableString</code> 收到 <code>copyWithZone:</code> 消息会生成一个不可变的 <code>NSString</code> 对象。<br><code>initWithArray:copyItems:</code> <a href="https://developer.apple.com/documentation/foundation/nsarray/1408557-initwitharray?language=objc#" target="_blank" rel="noopener">API 说明</a></p>
<blockquote>
<p><code>copyItems:</code> 参数 <code>flag</code><br>If <code>YES</code>, each object in array receives a <code>copyWithZone:</code> message to create a copy of the object—objects must conform to the <code>NSCopying</code> protocol. In a managed memory environment, this is instead of the retain message the object would otherwise receive. The object copy is then added to the returned array.<br>If <code>NO</code>, then in a managed memory environment each object in array simply receives a <code>retain</code> message when it is added to the returned array.</p>
</blockquote>
<h2 id="单层复制和完全复制？"><a href="#单层复制和完全复制？" class="headerlink" title="单层复制和完全复制？"></a>单层复制和完全复制？</h2><p>思考这样一种情况，即数组套数组，这种深拷贝是怎么做？<br>我们刚使用 <code>initWithArray:copyItems:</code> 方法进行的拷贝只是元素拷贝。即如果是两层数组的话，内层数组里的元素其实并没有机会执行 <code>copyWithZone:</code> 方法。苹果官方称这种拷贝为 <code>one-level-deep copy</code>，即单层复制。</p>
<p>完全复制是指，不管嵌套多少层集合，每层的的元素都有机会执行 <code>copyWithZone:</code> 方法。</p>
<h1 id="Copy-和-NSCoding"><a href="#Copy-和-NSCoding" class="headerlink" title="Copy 和 NSCoding"></a>Copy 和 NSCoding</h1><p>如何实现完全复制呢？<br>让对象实现 <code>NSCoding</code> 协议，然后将对象归档到文件里再从文件中归档出来，即需要进行两次 I/O 操作。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//NSArray 和 NSString 都支持 NSCoding 协议</span><br><span class="line">NSString *path = @&quot;/Users/xiushan.fan/Desktop/arrfile&quot;;</span><br><span class="line">NSArray *subArray1 = @[[NSMutableString stringWithString:@&quot;1&quot;]];</span><br><span class="line">NSArray *subArray2 = @[[NSMutableString stringWithString:@&quot;2&quot;]];</span><br><span class="line">NSArray *wholeArr = @[subArray1,subArray2];</span><br><span class="line">[NSKeyedArchiver archiveRootObject:wholeArr toFile:path];</span><br><span class="line">NSLog(@&quot;wholeArr = %@,wholeArr = %p,subArr1 = %p,elemement = %p&quot;,wholeArr,wholeArr,[wholeArr objectAtIndex:0],[[wholeArr objectAtIndex:0] objectAtIndex:0]);</span><br><span class="line">NSArray *unarchivedArray = [NSKeyedUnarchiver unarchiveObjectWithFile:path];</span><br><span class="line">//NSArray *unarchivedArray = [[NSArray alloc] initWithArray:wholeArr copyItems:YES];</span><br><span class="line">NSLog(@&quot;unarchivedArray = %@, unarchivedArray = %p ,subArr1 = %p,elemement = %p&quot;,unarchivedArray,unarchivedArray,[unarchivedArray objectAtIndex:0],[[unarchivedArray objectAtIndex:0] objectAtIndex:0]);</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo wholeArr = ( ( 1 ),( 2 ) ),wholeArr = 0x100422c60,subArr1 = 0x100406930,elemement = 0x100422580</span><br><span class="line">&gt; FRCopyDemo unarchivedArray = (</span><br><span class="line">(1 ), ( 2 )), unarchivedArray = 0x1004273a0 ,subArr1 = 0x1004039c0,elemement = 0x100424230</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>NSCoding</code> 进行转化之后所有的元素的内存地址均不相同。</p>
<h1 id="Copy-和属性"><a href="#Copy-和属性" class="headerlink" title="Copy 和属性"></a>Copy 和属性</h1><p>被 <code>copy attribute</code> 修饰的属性，在被赋值的时候，新值其实是会收到一个 <code>copyWithZone:</code> 的消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface FRObj : NSObject&lt;NSCopying&gt;</span><br><span class="line">@end</span><br><span class="line">@implementation FRObj</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    FRObj *obj = [[FRObj allocWithZone:zone] init];</span><br><span class="line">    NSLog(@&quot;FRObj copy with zone self %@&quot;,self);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@interface FRModel : NSObject&lt;NSCopying&gt;</span><br><span class="line">@property (nonatomic,copy) FRObj *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">FRModel *model = [[FRModel alloc] init];</span><br><span class="line">FRObj *obj = [[FRObj alloc] init];</span><br><span class="line">NSLog(@&quot;obj %@&quot;,obj);</span><br><span class="line">model.name = obj;</span><br><span class="line">---</span><br><span class="line">&gt; FRCopyDemo obj &lt;FRObj: 0x1004001c0&gt;</span><br><span class="line">&gt; FRCopyDemo FRObj copy with zone self &lt;FRObj: 0x1004001c0&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>FRObj</code> 赋值的时候自己收到了一条 <code>copyWithZone:</code> 的消息。<br>具体的底层实现可以参考 <a href="https://fanxiushan.github.io/2018/01/09/属性-attribute-总结/" target="_blank" rel="noopener">属性 attribute 总结</a> 里的 <code>copy attribute</code> 部分</p>
<h1 id="一些-QA"><a href="#一些-QA" class="headerlink" title="一些 QA"></a>一些 QA</h1><p><strong>Q: copy 关键字一般在哪些场景下使用？</strong><br>A: 1.<code>NSString/NSArray/NSDictionary</code> 这些类使用，因为这些类都有对应的可变类型。<br>   2. MRC 下修饰 <code>block</code> 属性需要使用 <code>copy</code>。ARC 下可以使用 <code>copy/strong</code> 去修饰 <code>block</code>，一般也使用 <code>copy</code>,给人感觉比较直观。</p>
<blockquote>
<p>这个的对应的问题是，<code>NSString</code> 使用什么修饰符修饰？为什么？答案是使用 <code>copy</code> 修饰符，原因是 <code>NSString</code> 用 <code>strong</code> 修饰符的时候如果指向自己的可变类型，当可变类型内容修改的时候，<code>NSString</code> 属性也会跟着一起修改，这不是我们希望看到的。同时根据刚才的分析，使用 <code>copy</code> 修饰并不会给 <code>NSString</code> 造成额外的负担，因为仅仅是浅拷贝而已。</p>
</blockquote>
<p><strong>Q: 这个写法会出什么问题： @property (copy) NSMutableArray *array;</strong><br>A: 当给 <code>array</code> 赋值的时候可变对象会变为不可变对象，其实是向被赋值的对象发送了一个 <code>copy</code> 消息， <code>copy</code> 的默认实现就是将可变对象变为不可变对象。属性里也没有 <code>mutablecopy</code> 这种修饰符，所以只能手动发送 <code>mutableCopy</code> 消息达到目的。<br><a href="https://stackoverflow.com/questions/46211849/property-of-mutable-type-nsmutabledictionary-has-copy-attribute-an-immutabl" target="_blank" rel="noopener">Property of mutable type ‘NSMutableDictionary’ has ‘copy’ attribute; an immutable object will be stored instead</a></p>
<p><strong>Q: 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</strong><br>A: 实现 <code>NSCopying</code> 协议，实现 <code>copyWithZone:</code> 方法. 直接发送 <code>copy</code> 消息就好了</p>
<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3" target="_blank" rel="noopener">Collections Programming Topics - Copying Collections</a><br><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCopying.html" target="_blank" rel="noopener">Cocoa Core Competencies - Object copying</a><br>Effective Objective-C 2.0 - 理解 NSCopying 协议<br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i" target="_blank" rel="noopener">Advanced Memory Management Programming Guide - About Memory Management</a><br><a href="https://www.zybuluo.com/MicroCai/note/50592" target="_blank" rel="noopener">iOS 集合的深复制与浅复制</a><br><a href="https://juejin.im/entry/581c6c2aa0bb9f0058a26f81" target="_blank" rel="noopener">Objective-C copy，看我就够了</a><br><a href="http://zhangbuhuai.com/copy-in-objective-c/" target="_blank" rel="noopener">Objective-C copy那些事儿</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/28/IP 地址获取小集(iOS+macOS)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/IP 地址获取小集(iOS+macOS)/" itemprop="url">IP 地址获取小集(iOS+macOS)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T17:01:17+08:00">2018-02-28</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/02/28/IP 地址获取小集(iOS+macOS)/" class="leancloud_visitors" data-flag-title="IP 地址获取小集(iOS+macOS)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-和-macOS-上获取-IP-地址方法"><a href="#iOS-和-macOS-上获取-IP-地址方法" class="headerlink" title="iOS 和 macOS 上获取 IP 地址方法"></a>iOS 和 macOS 上获取 IP 地址方法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>通用的做法是使用 <code>getifaddrs</code> 方法获取到指向本机网络接口信息的一个链表,然后通过遍历该链表拿到当前的网卡对应的 <code>IP</code> 地址。<br><code>iPhone</code> 上的无线网卡是 <code>en0</code> ，所以拿到 <code>ifaddrs</code> 结构体后去判断其 <code>name</code> 成员变量的时候，判定 <code>name</code> 是否等于 <code>en0</code>。</p>
<p>如果是运行 <code>iPhone</code> 模拟器的话 <code>en0</code> 是代表当前电脑上 <code>en0</code> 对应的网卡地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;ifaddrs.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">...</span><br><span class="line">struct ifaddrs *address = NULL;</span><br><span class="line">struct ifaddrs *temp = NULL;</span><br><span class="line">if (0 != getifaddrs(&amp;address)) &#123;</span><br><span class="line">    NSLog(@&quot;getifaddrs error = %s&quot;,strerror(errno));</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">temp = address;</span><br><span class="line">while (temp-&gt;ifa_next != NULL) &#123;</span><br><span class="line">    NSString *if_name = [NSString stringWithUTF8String:temp-&gt;ifa_name];</span><br><span class="line">    if ([if_name isEqualToString:@&quot;en0&quot;]) &#123;</span><br><span class="line">        struct sockaddr *ifa_addr = temp-&gt;ifa_addr;</span><br><span class="line">        if (ifa_addr-&gt;sa_family == AF_INET) &#123;</span><br><span class="line">            struct sockaddr_in *in_address = (struct sockaddr_in *)ifa_addr;</span><br><span class="line">            char *ip_str = inet_ntoa(in_address-&gt;sin_addr);</span><br><span class="line">            NSLog(@&quot;ip %@&quot;,[NSString stringWithFormat:@&quot;%s&quot;,ip_str]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = temp-&gt;ifa_next;</span><br><span class="line">&#125;</span><br><span class="line">freeifaddrs(address);</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><code>iOS</code> 上还有一种方式来获取，拿到通过解析当前机器的 <code>hostname</code> 返回地址链表中的第一个地址作为主 <code>IP</code>。但是这种方法并不适用于 <code>macOS</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)hostname &#123;</span><br><span class="line">    char baseHostName[256]; </span><br><span class="line">    int success = gethostname(baseHostName, 255);</span><br><span class="line">    if (success != 0) return nil;</span><br><span class="line">    baseHostName[255] = &apos;\0&apos;;</span><br><span class="line">#if !TARGET_IPHONE_SIMULATOR</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%s.local&quot;, baseHostName];</span><br><span class="line">#else</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%s&quot;, baseHostName];</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// return IP Address</span><br><span class="line">+ (NSString *)localIPAddress &#123;</span><br><span class="line">    struct hostent *host = gethostbyname([[self hostname] UTF8String]);</span><br><span class="line">    if (!host) &#123;herror(&quot;resolv&quot;); return nil;&#125;</span><br><span class="line">    struct in_addr **list = (struct in_addr **)host-&gt;h_addr_list;</span><br><span class="line">    return [NSString stringWithCString:inet_ntoa(*list[0]) encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p><code>macOS</code> 不能使用第二种方法，但是可以使用第一种的方法，但是有一个问题，在带有网口的 <code>Mac</code> 电脑上，<code>en0</code> 是代表以太网网卡地址，你获取到的 <code>IP</code> 也是该网卡地址，若想要只获取 <code>WIFI</code> 的对应网卡地址，则需要使用别的关键词，通常是 <code>en1</code> 去筛选。</p>
<p>可以使用 <code>networksetup -listallhardwareports</code> 命令来查看当前的网络硬件配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hardware Port: Ethernet</span><br><span class="line">Device: en0</span><br><span class="line">Ethernet Address: 68:5b:35:a5:a2:d5</span><br><span class="line"></span><br><span class="line">Hardware Port: Wi-Fi</span><br><span class="line">Device: en1</span><br><span class="line">Ethernet Address: c8:e0:eb:4c:f9:bf</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>所以想获取 <code>WIFI</code> 的网卡地址话需要将 <code>en0</code> 替换为 <code>en1</code>，但是这并不是通用的方案，因为在 Mac Air 上 <code>en0</code> 再次代表了 <code>WIFI</code>，<code>enX</code> 这种判断方式不够靠谱，我们想要一个更加通用的解决方案。</p>
<p>通用的解决方案如下，获取系统配置，通过匹配 <code>AirPort</code> 关键字来进行匹配，里面的关键字参考 <a href="https://developer.apple.com/library/content/documentation/Networking/Conceptual/SystemConfigFrameworks/SC_UnderstandSchema/SC_UnderstandSchema.html" target="_blank" rel="noopener">System Configuration Programming Guidelines</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1. 创建 dynamic store.</span><br><span class="line">SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, (__bridge CFStringRef)@&quot;example&quot;, NULL, NULL);</span><br><span class="line">//2. 通过 keystore 从 dynamic store 中获取数据.</span><br><span class="line">NSString *keyStr = @&quot;Setup:/Network/Global/IPv4&quot;;</span><br><span class="line">NSDictionary *global = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)keyStr);</span><br><span class="line">//3. 根据 IPv4 的全局数据拿所有 services</span><br><span class="line">NSArray *services = [global objectForKey:@&quot;ServiceOrder&quot;];</span><br><span class="line">//4. 取出 wifi 相关 service.</span><br><span class="line">//Note: wifi serviceId 和 &apos;/Library/Preferences/SystemConfiguration/preferences.plist&apos; 里 wifi serviceID 一样.</span><br><span class="line">for (NSString *serviceID in services) &#123;</span><br><span class="line">    NSString *serviceKeyStr = [NSString stringWithFormat:@&quot;State:/Network/Service/%@/IPv4&quot;,serviceID];</span><br><span class="line">    NSDictionary *serviceInfo = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)serviceKeyStr);</span><br><span class="line">    if (serviceInfo) &#123;</span><br><span class="line">        NSString *interfaceKeyStr = [NSString stringWithFormat:@&quot;Setup:/Network/Service/%@/Interface&quot;,serviceID];</span><br><span class="line">        NSDictionary *globalInterface = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)interfaceKeyStr);</span><br><span class="line">        if ([[globalInterface objectForKey:@&quot;Hardware&quot;] isEqualToString:@&quot;AirPort&quot;] ) &#123;</span><br><span class="line">            NSString *wifiAddress = [[serviceInfo objectForKey:@&quot;Addresses&quot;] objectAtIndex:0];</span><br><span class="line">            return wifiAddress;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法并不适用于 <code>iOS</code>，因为 <code>iOS</code> 不支持上面的 <code>API</code></p>
<h1 id="获取空闲端口"><a href="#获取空闲端口" class="headerlink" title="获取空闲端口"></a>获取空闲端口</h1><p>大概思路：</p>
<ol>
<li><p>创建套接字。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int local_sock = socket(temp_addr-&gt;ifa_addr-&gt;sa_family,SOCK_DGRAM, 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建本地 <code>sockaddr</code> 的时候 <code>sin_port</code> 变量传入 0 。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in local_addr;</span><br><span class="line">bzero(&amp;local_addr, sizeof(local_addr));</span><br><span class="line">local_addr.sin_family = AF_INET;</span><br><span class="line">local_addr.sin_port = 0;</span><br><span class="line">local_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后 <code>bind</code> 这个套接字到本地 <code>sockaddr</code> 地址。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = bind(local_sock, (struct sockaddr *)&amp;local_addr, sizeof(local_addr));</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 <code>bind</code> 成功，接下来通过 <code>getsockname</code> 方法来获取 <code>sockaddr</code> 地址。这时候 <code>sockaddr</code> 里的 <code>sin_port</code> 即为没有被占用的端口。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsockname(local_sock, (struct sockaddr *)&amp;sin, &amp;len)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>有点空手套白狼的意思。</p>
<h1 id="macOS-上监听-WIFI-切换引起-IP-变化的方法"><a href="#macOS-上监听-WIFI-切换引起-IP-变化的方法" class="headerlink" title="macOS 上监听 WIFI 切换引起 IP 变化的方法"></a>macOS 上监听 WIFI 切换引起 IP 变化的方法</h1><p>之前使用的 <code>AFNetworkReachabilityManager</code> 不太符合要求，有的时候切换了 WIFI 也不能及时进行变化。 <code>CoreWLAN</code> 框架提供了一个监听的方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)startMonitoringEventWithType:(CWEventType)type error:(out NSError * _Nullable *)error;</span><br></pre></td></tr></table></figure>

<p>不幸的是，这个方法不能再沙盒之外使用。</p>
<p>经过搜索发现一个方法能完整实现改功能，其实就是上面的获取 IP 的第三个方法，只不过需要增加点东西。具体可以参考下面代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static NSString *wifiServiceKeyStr;</span><br><span class="line">//监听 WIFI 变化的回调方法</span><br><span class="line">void dynamicStoreChange(SCDynamicStoreRef store,CFArrayRef changedKeys, void * __nullable info) &#123;</span><br><span class="line">    NSLog(@&quot;store %@,changedKeys %@,info %s&quot;,store,changedKeys,info);</span><br><span class="line">    for (NSString *changeKey in (__bridge NSArray *)changedKeys) &#123;</span><br><span class="line">        if ([changeKey isEqualToString:wifiServiceKeyStr]) &#123;</span><br><span class="line">            NSDictionary *serviceInfo = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)changeKey);</span><br><span class="line">            NSLog(@&quot;now server info %@&quot;,serviceInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1. 创建 dynamic store.</span><br><span class="line">SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, (__bridge CFStringRef)@&quot;example&quot;, dynamicStoreChange, NULL);</span><br><span class="line"></span><br><span class="line">NSString *interfaceKey = @&quot;State:/Network/Interface&quot;;</span><br><span class="line">NSDictionary *interfaces = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)interfaceKey);</span><br><span class="line">NSLog(@&quot;interfaces = %@&quot;,interfaces);</span><br><span class="line"></span><br><span class="line">//2. 通过 keystore 从 dynamic store 中获取数据.</span><br><span class="line">NSString *keyStr = @&quot;Setup:/Network/Global/IPv4&quot;;</span><br><span class="line">NSDictionary *global = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)keyStr);</span><br><span class="line">//3. 根据 IPv4 的全局数据拿所有 services</span><br><span class="line">NSArray *services = [global objectForKey:@&quot;ServiceOrder&quot;];</span><br><span class="line">//4. 取出 wifi 相关 service.</span><br><span class="line">//Note: wifi serviceId 和 &apos;/Library/Preferences/SystemConfiguration/preferences.plist&apos; 里 wifi serviceID 一样.</span><br><span class="line">//注意不能用 en0 和 en1 进行判断。en0 和 en1 在 iMac 和 macAir 上有对应不同的网卡。</span><br><span class="line">for (NSString *service in services) &#123;</span><br><span class="line">    NSString *serviceKeyStr = [NSString stringWithFormat:@&quot;State:/Network/Service/%@/IPv4&quot;,service];</span><br><span class="line">    NSDictionary *serviceInfo = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)serviceKeyStr);</span><br><span class="line">    if (serviceInfo) &#123;</span><br><span class="line">        NSString *interfaceKeyStr = [NSString stringWithFormat:@&quot;Setup:/Network/Service/%@/Interface&quot;,service];</span><br><span class="line">        NSDictionary *globalInterface = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)interfaceKeyStr);</span><br><span class="line">        if ([[globalInterface objectForKey:@&quot;Hardware&quot;] isEqualToString:@&quot;AirPort&quot;] ) &#123;</span><br><span class="line">            NSLog(@&quot;service info = %@&quot;,serviceInfo);</span><br><span class="line">            wifiServiceKeyStr = serviceKeyStr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//5. 监听 wifi 相关 service 的变化.</span><br><span class="line">if (wifiServiceKeyStr) &#123;</span><br><span class="line">    SCDynamicStoreSetNotificationKeys(store, NULL,(__bridge CFArrayRef)@[wifiServiceKeyStr]);</span><br><span class="line">    CFRunLoopAddSource(CFRunLoopGetCurrent(),</span><br><span class="line">                       SCDynamicStoreCreateRunLoopSource(NULL, store, 0),</span><br><span class="line">                       kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/15/AutoreleasePool-理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/AutoreleasePool-理解/" itemprop="url">AutoreleasePool 理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T10:39:51+08:00">2018-01-15</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/15/AutoreleasePool-理解/" class="leancloud_visitors" data-flag-title="AutoreleasePool 理解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从一些问题开始</p>
<ol start="0">
<li>什么是 <code>AutoreleasePool</code> ? 说明一下 <code>NSAutoreleasePool</code> 具体机制?</li>
<li>ARC 时代和 MRC 时代的 <code>AutoreleasePool</code> 机制有什么区别？</li>
<li><code>AutoreleasePool</code> 的实现机制?</li>
<li><code>AutoreleasePool</code> 和 NSRunloop 有什么关系？</li>
<li><code>AutoreleasePool</code> 和线程有什么关系?</li>
<li>什么时候需要我们手动创建 <code>AutoreleasePool</code> ?</li>
</ol>
<h2 id="什么是-AutoreleasePool-如何理解-NSAutoreleasePool"><a href="#什么是-AutoreleasePool-如何理解-NSAutoreleasePool" class="headerlink" title="什么是 AutoreleasePool ? 如何理解 NSAutoreleasePool?"></a>什么是 AutoreleasePool ? 如何理解 NSAutoreleasePool?</h2><p><code>NSAutoreleasePool</code> 对象的官方说明是一个支持 <code>Cocoa</code> 引用计数式内存管理的一个对象。 当池子排掉的时候向池子内存储的对象发送 <code>release</code> 消息。</p>
<blockquote>
<p>An object that supports Cocoa’s reference-counted memory management system.<br>An autorelease pool stores objects that are sent a release message when the pool itself is drained.</p>
</blockquote>
<p>具体机制说明：<br>在引用计数式的内存管理中，<code>NSAutoreleasePool</code> 对象包含了收到了 <code>_autorelease</code> 消息的对象，这些 <code>autorelease</code> 对象（我们称被标记了 <code>__autorelease</code> 的对象为 <code>autorelease</code> 对象）的生命周期被延长到了这个 <code>NSAutoreleasePool</code> drain 的时候。也可以这么说 <code>autorelease</code> 和 <code>release</code> 的区别仅仅是 <code>autorelease</code> 是延时释放(即等待 <code>AutoreleasePool drain</code>) 而 <code>release</code> 是立即释放。</p>
<p>感觉说到这儿，其实我们可以说 <code>NSAutoreleasePool</code> 就是一个帮助我们管理内存的一个工具。</p>
<p>其实不光是我们自己可以手动创建 <code>NSAutoreleasePool</code> 对象，系统也帮我们维护了一个 <code>NSAutoreleasePool</code> 对象，在 <code>runloop</code> 迭代中不断 <code>Push</code> 和 <code>Pop</code>，从而不会堆积过多的 <code>autorelease</code> 对象引起内存疯长。你可能会好奇，哪会有那么多 <code>autorelease</code> 对象？举个例子来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // str 其实是一个 autorelease 对象</span><br><span class="line">    NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;];</span><br><span class="line">    reference = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题外话：为啥  str 是一个 <code>autorelease</code> 对象呢？<br>这个就需要知道下内存管理的知识了，使用 <code>alloc</code>,<code>new</code>,<code>copy</code>和<code>mutableCopy</code>这些关键字生成的对象是自己持有，反之不是（参考 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1" target="_blank" rel="noopener">Memory Management Policy</a>）。使用 <code>stringWithFormat:</code> 类方法生成的 <code>str</code> 没有持有它的对象，只能通过 <code>autorelease</code> 这种方式来延长它的生命周期。具体 <code>autorelease</code> 的时机是在 <code>stringWithFormat</code> 内部做的。</p>
<p><code>Cocoa</code> 的 <code>Framework</code> 里大量生成了 <code>autorelease</code> 的对象，所以官方说明里 <code>Cocoa</code> 代码执行是预期在一个 <code>autorelease</code> 环境中。</p>
<h2 id="ARC-时代和-MRC-时代的-AutoreleasePool-机制有什么区别？"><a href="#ARC-时代和-MRC-时代的-AutoreleasePool-机制有什么区别？" class="headerlink" title="ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？"></a>ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？</h2><p>没啥根本区别，只是写法稍有不同。看两个 ARC 和 MRC 时代 <code>autorelease</code> 的两个经典写法。</p>
<p>MRC 的 case:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = [[NSAutorelease alloc] init];</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure>

<p>ARC 的 case(注:<a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool" target="_blank" rel="noopener">其实 MRC 也可以这么写</a>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    //_autorelease 为所有权修饰符。</span><br><span class="line">    id _autorelease obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ARC</code> 中的几点变化：</p>
<ol>
<li><p><code>ARC</code> 中是不能使用 <code>autorelease</code> 方法，也不能使用 <code>NSAutoreleasePool</code> 类。</p>
</li>
<li><p><code>ARC</code> 系统提供了 <code>@autoreleasepool</code> 块来替代 <code>NSAutoreleasePool</code> 对象的生成持有以及废弃的功能。</p>
</li>
<li><p>通过将对象赋值给附加了 <code>__autoreleaseing</code> 修饰符变量来替代调用 <code>autorelease</code> 方法。即</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br></pre></td></tr></table></figure>

<p> 等价于</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id _autorelease obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>一般我们不会显式的去使用 <code>__autorelease</code> 修饰符，因为ARC 下编译器帮我们做了一些工作，即编译器会检查方法是否以 <code>alloc/new/copy/mutableCopy</code> 开始，如果不是的话将返回的值对象注册到 <code>autoreleasePool</code>。</p>
<p>不需要显式地写 <code>__autorelease</code> 的几种场景</p>
<ol>
<li><p>自动释放池随意生成对象，不需要显式地添加 <code>autorelease</code>。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    //默认的 strong 修饰符会自动处理这种情况.</span><br><span class="line">    id obj = [[NSObject alloc] init];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回值的场景</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray *)array &#123;</span><br><span class="line">    id obj = [[NSMutableArray alloc] init];</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在 MRC 时代，obj 是需要被发送 <code>autorelease</code> 方法的，ARC 时代不需要这么做，这个对象作为函数的返回值会自动被注册到 <code>autoreleasePool</code> 中</p>
</li>
<li><p>访问 <code>weak</code> 变量的时肯定会涉及到 <code>autoreleasePool</code></p>
<p> 因为 <code>weak</code> 对对象是弱引用，对象随时会被释放，但是使用 <code>autoreleasePool</code> 会延时释放，保证 <code>weak</code> 访问过程中不会出现对象被释放这种状况。</p>
</li>
<li><p><code>NSObject **obj</code> 其实就是 <code>NSObject *_autorelease * obj</code>。<br> 因为<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1" target="_blank" rel="noopener">我们不持有通过引用返回的对象</a>。这种情况只能是 <code>autorelease</code>。</p>
</li>
</ol>
<h2 id="AutoreleasePool-的实现机制"><a href="#AutoreleasePool-的实现机制" class="headerlink" title="AutoreleasePool 的实现机制?"></a>AutoreleasePool 的实现机制?</h2><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>对以下代码所在文件执行 <code>clang -rewrite-objc xx.m</code> 重写命令，可以看到 OC 对应的 C++ 的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换后的 C++ 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>@autoreleasepool</code> 被转换为一个名为 <code>__AtAutoreleasePool</code> 的数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main 函数其实可以理解为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#123; </span><br><span class="line">        void *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 的实现在 runtime 源码 <code>NSObject.mm</code>中可以找到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void * objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutoreleasePoolPage-的介绍"><a href="#AutoreleasePoolPage-的介绍" class="headerlink" title="AutoreleasePoolPage 的介绍"></a><code>AutoreleasePoolPage</code> 的介绍</h3><p>这里涉及到了 <code>AutoreleasePoolPage</code> 这个数据结构，接下来就看下 <code>AutoreleasePoolPage</code> 这个数据结构是啥样的？<code>AutoreleasePoolPage</code> 是个 C++ 的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage  &#123;</span><br><span class="line">    magic_t const magic;    //magic 用于对当前 AutoreleasePoolPage 完整性的校验</span><br><span class="line">    id *next;               //当前 autoreleasePoolPage 最上层的对象的指针。</span><br><span class="line">    pthread_t const thread; //thread 保存了当前页所在的线程</span><br><span class="line">    AutoreleasePoolPage * const parent;//指向上一个 AutoreleasePoolPage 对象.</span><br><span class="line">    AutoreleasePoolPage *child; //指向下一个 AutoreleasePoolPage 对象.</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于 <code>AutoreleasePoolPage</code> 的说明</strong></p>
<ol>
<li><p>可以看到其实并没有一个整体的自动释放池对象，自动释放池是由一个双向链表构成。当一个 <code>AutoreleasePoolPage</code> 的空间被占满之后继续创建新的 <code>AutoreleasePoolPage</code> 对象。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//child 指向的是下一个 AutoreleasePoolPage 对象的指针</span><br><span class="line">// 这个方法是当前 page 如果满的情况下创建新的 page.</span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line">    ....</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line">// 初始化 pool 的方法 在这个里面对 parent 和 child 进行了赋值.</span><br><span class="line">AutoreleasePoolPage(AutoreleasePoolPage *newParent) </span><br><span class="line">    : magic(), next(begin()), thread(pthread_self()),</span><br><span class="line">      parent(newParent), child(nil), </span><br><span class="line">      depth(parent ? 1+parent-&gt;depth : 0), </span><br><span class="line">      hiwat(parent ? parent-&gt;hiwat : 0) &#123; </span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;child = this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个 <code>AutoreleasePoolPage</code> 对象都存储着当前的线程 <code>id</code> 参考上面的 <code>AutoreleasePoolPage</code> 的初始化方法。使用 <code>pthread_self()</code> 拿到当前的线程 <code>id</code> 然后保存到 <code>thread</code> 成员变量里。</p>
</li>
<li><p><code>AutoreleasePoolPage</code> 的内存大小是 4096 个字节。是 80386 机器上的每页的字节数。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//初始化 AutoreleasePoolPage 的方法,size 是个宏定义的 4096</span><br><span class="line">static void * operator new(size_t size) &#123;</span><br><span class="line">    return malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AutoreleasePoolPage</code> 存储 <code>autorelease</code> 对象是通过自己内部的 <code>next</code> 指针去实现。从实现上可以看到 <code>AutoreleasePoolPage</code> 还是从低内存地址向高内存地址增长。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id *add(id obj) &#123;</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 由此大致能得到 <code>AutoreleasePoolPage</code> 的内存结构如图（来自 Sunny 大神博客）<br> <img src="/media/Jietu20180125-103109.png" alt="Jietu20180125-103109"></p>
</li>
</ol>
<h3 id="autorelease-消息调用栈"><a href="#autorelease-消息调用栈" class="headerlink" title="autorelease 消息调用栈"></a>autorelease 消息调用栈</h3><p>了解了这个数据结构后看下 <code>autorelease</code> 消息的调用栈。</p>
<p><img src="/media/15168026389568.jpg" alt><br>我们看下 <code>AutoreleasePoolPage</code> 中 <code>autorelease</code> 方法实现其实就是将 <code>autorelease</code> 对象存储到 <code>AutoreleasePoolPage</code> 的过程。下面是大致实现的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static inline id autorelease(id obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">//这个是将 obj 存入 AutoreleasePoolPage 的方法。</span><br><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    //hotPage 应该是去 TLS(线程本地存储) 中获取 AutoreleasePoolPage。</span><br><span class="line">    //如果是程序刚启动的话，这儿肯定拿到的空。</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        // AutoreleasePoolPage 不满的时候直接往进加</span><br><span class="line">        return page-&gt;add(obj); //绝大多数情况我们走的都是这个分支。</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        // AutoreleasePoolPage 满了，则创建新的 page，将 obj 放到新的 page 里去.</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 创建新的 page.</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="autorelease-pop-消息"><a href="#autorelease-pop-消息" class="headerlink" title="autorelease pop 消息"></a>autorelease pop 消息</h3><p>对应 <code>push</code> 的是 <code>pop</code>，<code>pop</code> 即为将存储到 <code>AutoreleasePoolPage</code> 的对象释放对应原型为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意的是这里并没有直接传入对象，而是传入了一个 <code>ctxt</code> 的指针，根据内部实现来看，自动释放池根据 <code>ctxt</code> 拿到它当前所在的 <code>AutoreleasePoolPage</code> ，然后将 <code>AutoreleasePoolPage</code> 的 <code>ctxt</code> 的位置开始到到最新的 <code>AutoreleasePoolPage</code> 存储的 <code>autorelease</code> 对象全部释放。即我们可以理解为自动释放池代码块儿开始的时候会在 <code>AutoreleasePoolPage</code> 进行一个占位，然后将后续的 <code>autorelease</code> 对象都放到占位后，这样就能确定当前自动释放池块儿里的对象是从哪到哪，理解了这一点也就能理解 <code>autorelease</code> 的嵌套实现了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token)  &#123;</span><br><span class="line">    AutoreleasePoolPage *page; id *stop;</span><br><span class="line">    ..</span><br><span class="line">    page = pageForPointer(token); //拿到 token 所在的 AutoreleasePoolPage</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (PrintPoolHiwat) printHiwat();</span><br><span class="line">    page-&gt;releaseUntil(stop);  //一直释放对象到 token 的位置.</span><br><span class="line">&#125;</span><br><span class="line">//一直释放对象的函数</span><br><span class="line">void releaseUntil(id *stop)  &#123;</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage(); //拿到当前的 page.</span><br><span class="line">        id obj = *--page-&gt;next; </span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);  //取出对象不断发送 relesse 消息..</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setHotPage(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AutoreleasePool-和-NSRunloop-有什么关系？"><a href="#AutoreleasePool-和-NSRunloop-有什么关系？" class="headerlink" title="AutoreleasePool 和 NSRunloop 有什么关系？"></a>AutoreleasePool 和 NSRunloop 有什么关系？</h2><p>先来个实例看下 <code>Runloop</code> 是什么东西。建一个普通的 Single View App 工程。点击按钮然后在按钮点击事件里打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)btnPressed:(id)sender &#123;</span><br><span class="line">    NSRunLoop *runloop = [NSRunLoop currentRunLoop]; </span><br><span class="line">    //在这里打断点然后 po runloop 得到下面结果。（省略大部分无关内容）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) po runloop </span><br><span class="line">common mode items = &lt;CFBasicHash 0x604000249360 [0x110875bb0]&gt;</span><br><span class="line">	1 : &lt;CFRunLoopObserver 0x6040001370c0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), ....</span><br><span class="line">	......</span><br><span class="line">	4 : &lt;CFRunLoopObserver 0x604000136ee0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), ....</span><br></pre></td></tr></table></figure>

<p>注意看上面的 <code>activities</code>,它对应的定义是这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以确定 <code>Autorelease</code> 机制在 <code>Runloop</code> 进入和退出(和休眠前触发) <code>CommonMode</code> 的时候进行观察，当 <code>Runloop</code> 运行到指定的时机的时候回触发 <code>_wrapRunLoopWithAutoreleasePoolHandler</code> 回调方法。</p>
<p><code>_wrapRunLoopWithAutoreleasePoolHandler</code> 这个方法的实现其实我们并不清楚，网上没有找到对应的实现，不过我们可以打下符号断点来看看有没有线索。果然应用刚启动就执行了这些方法。看左侧的调用栈确实是从 Observer 的回调执行过来的。下面两个是我们熟悉的 Pop 和 Push 操作，<strong>基本上可以确认，<code>Autorelease</code> 机制是在进入 <code>Runloop</code> 的时候就创建了一个新的 <code>AutoreleasePoolPage</code>。退出或者休眠的的时候回收 <code>AutoreleasePoolPage</code>。</strong></p>
<p> <img src="/media/15170502117985.jpg" alt></p>
<h2 id="AutoreleasePool-和线程有什么关系"><a href="#AutoreleasePool-和线程有什么关系" class="headerlink" title="AutoreleasePool 和线程有什么关系?"></a>AutoreleasePool 和线程有什么关系?</h2><p><code>Cocoa</code> 应用程序里的每个线程会自动维护一个释放池，就是通过上面 <code>Runloop</code> 的方式。但是如果没有 <code>Runloop</code> 呢？</p>
<p>之前看到有人问了一个问题：子线程默认不会开启 <code>Runloop</code>，那出现 <code>Autorelease</code> 对象如何处理？不手动处理会内存泄漏吗？<br>答案是不会。 </p>
<p>具体 demo 如下 <a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)test &#123;</span><br><span class="line">    MyClass *my = [[[MyClass alloc] init] autorelease];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[my description]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果是 <code>MyClass</code> 实例被释放掉了。理论上来说子线程并没有 <code>Runloop</code> 也就没有自动释放池观察 <code>Runloop</code> 状态，也就不会自动去执行对应的 <code>autorelease</code> 的方法。根据引用计数来看的话，<code>autorelease</code> 方法和 <code>AutoreleasePool</code> 在一起才能发生作用，而目前又没有 <code>AutoreleasePool</code>，所以那是咋回事？</p>
<p>事实上即使没有 <code>Runloop</code>，线程和 <code>AutoreleasePool</code> 也能直接发生关系。向某个对象发送 <code>autorelease</code> 消息后，会自动创建 <code>AutoreleasePoolPage</code>。<code>autorelease</code> 消息的调用栈可以参考上面的说明。最终 <code>TLS</code>(线程本地存储)会存储 <code>AutoreleasePoolPage</code> 对象。大致代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">tls_set_direct(key, (void *)page);</span><br></pre></td></tr></table></figure>

<p>这里具体实现比较复杂，而且根据是这种情况并不适用于主线程。可以看 <a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">StackOverflow</a> 的相关回答。这里不具体贴了。</p>
<p>我个人觉得为了程序可读性还有稳定性，还是加上 <code>@autoreleasepool</code> 更妥。说稳定性是因为不能过度依赖于 <code>runtime</code> 的底层机制，万一 <code>runtime</code> 底层机制后续有变化可能会造成程序的异常。</p>
<h2 id="什么时候需要我们手动创建-AutoreleasePool"><a href="#什么时候需要我们手动创建-AutoreleasePool" class="headerlink" title="什么时候需要我们手动创建 AutoreleasePool?"></a>什么时候需要我们手动创建 AutoreleasePool?</h2><ol>
<li>如果工程只是 Foundation-Only(命令行那种),而不是 Cocoa application。那需要手动创建自动释放池。</li>
<li>如果程序存活时间长，而且可能生成大量临时对象（比如循环里创建了一堆）那应该在合适地方（比如循环里）手动释放池，降低内存峰值（不用担心嵌套使用 <code>AutoreleasePool</code> 的问题）</li>
<li>你创建了一个新线程，需要创建自动释放池。这个跟我们上面一小节说的是略微冲突，但是在上面已经说过了，添加 <code>AutoreleasePool</code> 是最佳实践。</li>
</ol>
<h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a><br><a href="https://draveness.me/autoreleasepool" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 autoreleasepool</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="https://www.jianshu.com/p/5559bc15490d" target="_blank" rel="noopener">iOS中autorelease的那些事儿</a><br><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226-CH1-SW8" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a><br><a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool" target="_blank" rel="noopener">NSAutoreleasePool</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="noopener">Using Autorelease Pool Blocks</a><br><a href="http://www.samirchen.com/ios-arc/" target="_blank" rel="noopener">iOS ARC 内存管理要点</a><br><a href="https://www.jianshu.com/p/f87f40592023" target="_blank" rel="noopener">各个线程 Autorelease 对象的内存管理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/11/属性自动合成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/属性自动合成/" itemprop="url">属性自动合成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T13:12:45+08:00">2018-01-11</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/11/属性自动合成/" class="leancloud_visitors" data-flag-title="属性自动合成">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Clang 编译器提供了 OC 自动合成属性的功能。如果一个属性没有被声明为 <code>@dynamic</code> 或者开发者没有自定制它的 <code>getter</code> 或者 <code>setter</code> 方法实现。那 <code>Clang</code> 会自动为你合成 <code>getter</code> 和 <code>setter</code> 方法的实现同时生成对应的成员变量，检查 <code>Clang</code> 编译器是否支持自动合成使用<code>__has_feature(objc_default_synthesize_properties)</code> 这个条件判断。举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_default_synthesize_properties)</span><br><span class="line">    //support autosynthesis</span><br><span class="line">#else</span><br><span class="line">    //not support</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>当编译器不能自动为你合成属性的时候，需要开发者手动进行。其实也可以换个说法，什么时候需要开发者手动 <code>@synthesize</code>。</p>
<p>举个例子，开发中偶尔会遇到这种报错的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSString *name;</span><br><span class="line">.....</span><br><span class="line">@implementation</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    _name = name; #编译错误:Use of undeclared identifier &apos;_name&apos;; did you mean &apos;name&apos;?</span><br><span class="line">&#125;</span><br><span class="line">-  (NSString *)name &#123;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这个时候需要我们手动的添加一行代码 <code>@synthesize name = _name;</code> 编译错误就会消失。或者你把编译错误的那行去掉，然后使用命令 <code>clang -rewrite-objc main.m</code> 编译原文件，发现生成的对象结构体中并没有 <code>name</code> 对应的成员变量。</p>
<p>接下来就是总结什么场景下需要我们手动添加 <code>@synthesize</code>。</p>
<ol>
<li>就是我们上面 <code>demo</code> 展示的这种可读写的属性，但是开发者自定义了 <code>getter</code> 和 <code>setter</code> 方法，注意必须是同时复写，如果只复写 <code>setter</code> 或者 <code>getter</code> 的话是不会出现问题的。这也是 <code>clang</code> 编译器不支持的自动合成的场景。</li>
<li>只读属性，开发者自定义了 <code>getter</code> 方法。</li>
<li><code>@dynamic</code> 修饰的属性，<code>@dynamic</code> 本质是告诉编译器 <code>setter</code> 与 <code>getter</code> 方法由开发者自己定义，不自动合成。</li>
<li>在协议 <code>@protocol</code> 中声明的属性。</li>
<li>在类别 <code>@category</code> 中声明的属性。这是因为类别不支持自动添加成员变量，需要手动进行引用关联。</li>
<li>如果你复写了父类的属性，你也需要显式地添加 <code>@synthesize</code></li>
<li>如果你想手动修改成员变量名的话，可以使用 <code>@synthesize</code> 修改，比如默认成员变量名是 <code>_name</code> 使用 <code>@synthesize name = yname;</code> 修改成员变量名为 <code>yname</code>，但是不建议这么做。</li>
</ol>
<p>2018-03-23 </p>
<p>补充一些关于第 6 点的说明。</p>
<p>如果父类自动生成属性成员变量和 getter, setter 方法。子类对父类的属性重新进行了 <code>@synthesize</code> 那将会生成新的实例变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface Fan : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line">//父类 Fan 并没有 @synthesize 而且没有复写 getter 和 setter 方法.</span><br><span class="line">......</span><br><span class="line">@interface FanSub : Fan</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">....</span><br><span class="line">@implementation FanSub</span><br><span class="line">@synthesize name = fname;</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    fname = name;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return fname;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意的是此时子类中的 <code>name</code> 属性对应的实例变量其实是 <code>fname</code>. 即它自己生成的实例变量，而不是父类的 <code>_name</code> 了。可以通过查看编译后的选项来验证 <code>clang -rewrite-objc main.m</code>。结合编译后对应的结构体看一下，确实是成员变量发生了变化。<strong>所以这个时候要注意，不能把子类的属性成员变量和父类的成员变量混为一谈。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//编译后的结构体.</span><br><span class="line">struct Fan_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line">struct FanSub_IMPL &#123;</span><br><span class="line">	struct Fan_IMPL Fan_IVARS;</span><br><span class="line">	NSString *fname;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一点总结：<br><img src="http://p2ap0u22n.bkt.clouddn.com/15218123235013.jpg" alt></p>
<p>所以子类合成和使用属性对应自动变量的两个原则：</p>
<ol>
<li>不允许合成和父类名字一样自动变量</li>
<li>如果在子类中有用到父类属性对应的成动变量，则需要显式地在父类头文件的成员变量区域去进行自动变量的声明。</li>
</ol>
<h2 id="一些-QA"><a href="#一些-QA" class="headerlink" title="一些 QA"></a>一些 QA</h2><p><strong>Q:@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？</strong><br>A: 默认合成带属性名字前面带下划线的成员变量。如果这个下划线的成员变量已经存在，就不会合成新的成员变量了。即上面问题答案是不会合成新的成员变量了。</p>
<p>#参考地址#<br><a href="https://stackoverflow.com/questions/19784454/when-should-i-use-synthesize-explicitly" target="_blank" rel="noopener">When should I use @synthesize explicitly?</a><br><a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-autosynthesis-of-properties" target="_blank" rel="noopener">Objective-C Autosynthesis of Properties</a><br><a href="https://www.jianshu.com/p/beefa2da05b5" target="_blank" rel="noopener">@synthesize 和 @dynamic 的作用</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/09/属性-attribute-总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/属性-attribute-总结/" itemprop="url">属性 attribute 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T21:59:57+08:00">2018-01-09</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/09/属性-attribute-总结/" class="leancloud_visitors" data-flag-title="属性 attribute 总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>@property</code> 和 <code>attribute</code> 的中文翻译都是属性，所以本文就只用英文做区分了。<code>property</code> 的不同 <code>attribute</code> 大致包含下面这些</p>
<ol>
<li>strong               //default</li>
<li>weak</li>
<li>copy</li>
<li>assign               //default</li>
<li>unsafe_unretained</li>
<li>atomic &amp; nonatomic   //default atomic </li>
<li>readonly &amp; readwrite //default readwrite </li>
</ol>
<p>接下来依次说一下这些 <code>attribute</code> 的用处，使用方法还有使用时的可能注意事项</p>
<h2 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h2><p><code>strong</code> 是 <code>ARC</code> 引入的方便内存管理的一种 <code>attribute</code>，跟 <code>MRC</code> 属性中的<code>retain</code> 效果基本是一样的。区别在于编译器遇到 <code>strong</code> 修饰的变量的时候会自动为其在合适的地方插入一条 <code>release</code> 语句。相同的地方就是为了强引用属性。强引用的意思就是当前对象持有自己的属性对象，如果当前对象不释放的话这个属性也不会被释放，而当对象释放的时候，<code>ARC</code> 也会自动为我们处理属性的释放，不需要开发者关心。<code>strong</code> 是我们最常用的一个 <code>attribute</code>。</p>
<p>几个说明：</p>
<ol>
<li><p><code>strong attribute</code> 和变量前的修饰符 <code>__strong</code> 在 <code>ARC</code> 里的作用是一样的。只不过一个修饰属性一个修饰变量而已。参考 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#property-declarations" target="_blank" rel="noopener">Property declarations</a></p>
</li>
<li><p><code>strong</code> 不能用来修饰非对象。否则编译器会报错 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Property with retain(or strong) attribute must be object type</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般如果某个属性前面不需要显式地写出 <code>strong</code> 编译器会自动认为这是 <code>strong</code> 类型的属性。</p>
</li>
<li><p><code>strong</code> 修饰符会自动处理以下两种 case,而引用计数不会出现异常。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;// 自己生成并持有对象</span><br><span class="line">    id __strong obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">&#123; // 非自己生成并持有对象.</span><br><span class="line">    id __strong obj = [NSMutableArray array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>objc_storeStrong</code> 方法的说明，当向一个 <code>__strong</code> 修饰符修饰的对象赋值的时候跟执行下面代码是一样的效果。说白了就是执行了 <code>objc_storeStrong</code> 的方法。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Precondition: object is a valid pointer to a __strong object which </span><br><span class="line">//is adequately aligned for a pointer. value is null or a pointer to a valid object.</span><br><span class="line">void objc_storeStrong(id *object, id value) &#123;</span><br><span class="line">  id oldValue = *object;</span><br><span class="line">  value = [value retain];</span><br><span class="line">  *object = value;</span><br><span class="line">  [oldValue release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 值得说明的是 <code>FRObject *obj = [FRObject frobj];</code> 和 <code>FRObject *obj = temp;</code> 这两句代码编译器的处理是不一样的。第二句会执行如上 <code>objc_storeStrong</code> 的方法，但是第一句不会。我个人理解原因是 <code>obj</code> 初始化的时候并没有 <code>oldValue</code>，所以没有必要这么做。</p>
</li>
</ol>
<h2 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h2><p><code>weak</code> 也是 <code>ARC</code> 引入的方便内存管理的一种 <code>attribute</code>，跟 <code>assign</code> 效果基本是一样的。区别在于在对象被释放的时候，<code>weak</code> 机制会自动将对象置为 nil,保证后续访问这个对象不会因为野指针闪退。</p>
<p>真正引入 <code>weak</code> 的原因是 <code>weak</code> 能解决引起内存泄露的循环引用问题。</p>
<p>几个说明：</p>
<ol>
<li><code>weak</code> 和 <code>strong</code> 一样只能用来修饰对象。</li>
<li><code>weak attribute</code> 和变量前的修饰符 <code>__weak</code> 在 <code>ARC</code> 里的作用是一样的。</li>
</ol>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p><code>copy</code> 要求它修饰的属性必须实现 <code>NSCopy</code> 协议。本质上，当 <code>copy</code> 修饰的属性被赋值的时候，新值会收到一个 <code>copyWithZone</code> 方法，旧的值会被 release。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//clang 编译后的源码</span><br><span class="line"> static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; </span><br><span class="line"> objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Fan, _name), (id)name, 1, 1); </span><br><span class="line"> &#125;</span><br><span class="line"> //runtime 里的对应方法</span><br><span class="line"> void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy)</span><br><span class="line"> //reallySetProperty 有对应 copy 属性的具体实现.</span><br></pre></td></tr></table></figure>

<p><code>copy</code> 的使用场景通常是你希望属性在赋值后一直保持值不变，而不是跟着它指向的对象一直变。讨论比较多的是 <code>NSString</code> 是应该用 <code>copy</code> 还是用 <code>strong</code> 去修饰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic) NSString *name;</span><br><span class="line"></span><br><span class="line">NSMutableString *nameString = [NSMutableString stringWithString:@&quot;John&quot;];</span><br><span class="line">Fan *fan = [[Fan alloc] init];</span><br><span class="line">fan.name = nameString;</span><br><span class="line">NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);</span><br><span class="line">[nameString appendString:@&quot;ny&quot;];</span><br><span class="line">NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);</span><br><span class="line">//输出结果如下</span><br><span class="line">2018-01-11 20:35:18.763988+0800 TTTTT[71790:3384299] fan.name = John 0x10051e9c0</span><br><span class="line">2018-01-11 20:35:18.764449+0800 TTTTT[71790:3384299] fan.name = Johnny 0x10051e9c0</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>fan.name</code> 在没有显式修改的时候被改掉了，这种情况出现在 <code>NSString</code> 指针子类 <code>NSMutableString</code> 的情况下，而 <code>NSMutablString</code> 的修改不会对本身地址产生影响。使用 <code>copy</code> 可以避免。个人觉得使用 <code>copy</code> 还是 <code>strong</code> 还是根据实际情况，如果出了问题知道为什么就好了。</p>
<h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><p>值得注意的是 <code>MRC</code> 时代和 <code>ARC</code> 时代的 <code>assign</code> 使用多少有点区别的。<code>MRC</code> 的 <code>assign</code> 是可以修饰对象还有普通基本类型，因为你根本也没得选。但是 <code>ARC</code> 下虽然 <code>assgin</code> 也都可以修饰基本类型和对象，但是通常修饰对象的话不会用 <code>assign</code> ，因为缺少了 <code>weak</code> 修饰变量被释放时候置为 <code>nil</code> 的特性，很有可能出现内存问题。所以我们现在用 <code>assign</code> 修饰基本类型就好了，需要弱引用的时候用 <code>weak</code> 用来修饰对象。规则也比较明确。</p>
<h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h2><p><code>unsafe_unretained</code> 其实就是阉割版本的 <code>weak</code> 实现，它缺少正是对象释放时候置为 <code>nil</code> 的特性。但是 <code>unsafe_unretained</code> 还能修饰基本数据类型，<code>weak</code> 不行。</p>
<p>看起来，我们使用 weak 就好了为啥要用 <code>unsafe_unretained</code> 这个属性呢。答案是因为 <code>__weak</code> 只支持 <code>iOS 5.0</code> 和 <code>OS X Mountain Lion</code> 作为部署版本，如果是想要兼容更低的支持 ARC 的版本，比如你想部署回 <code>iOS 4.0</code> 和 <code>OS X Snow Leopark</code> 就不得不使用 <code>unsafe_unretained</code>。</p>
<p>还有一种说法是 <code>weak</code> 底层实现比较繁琐消耗性能，我认为与 <code>weak</code> 带来的好处相比，这点消耗可以忽略。</p>
<h2 id="atomic-amp-nonatomic"><a href="#atomic-amp-nonatomic" class="headerlink" title="atomic &amp; nonatomic"></a>atomic &amp; nonatomic</h2><p><code>atomic</code> 和 <code>nonatomic</code> 区别在于向属性对应成员变量赋值的时候是否为原子写入，即能不能够保证安全写入，从这一点上 <code>atomic</code> 确实是安全的。但是 <code>atomic</code> 并非是线程安全的，因为 <code>atomic</code> 控制的粒度太细了。</p>
<p>举个例子，A 线程向属性写入一个值，A 线程后续再次读这个值之前，可能 B 线程也向同样的属性里写入另外一个值，这样 A 线程读取的时候并非读到的是自己刚写入的值而是一个预期之外的值。</p>
<p>从这一点上看 <code>atomic</code> 似乎用处不是很大，同时 <code>atomic</code> 底层是用锁实现的，频繁写入会影响性能。个人认为最好的实践是，使用 <code>nonatomic</code> 然后自己去处理线程相关的东西。</p>
<p>几个说明：</p>
<ol>
<li><p><code>atomic</code> 是默认属性。比如 <code>@property NSString *name;</code> 这种属性默认就是 <code>atomic</code> 修饰的。</p>
</li>
<li><p><code>atomic</code> 的底层实现里，赋值和读取值都有锁的保护，而且使用的都是一个锁。</p>
</li>
<li><p><code>atomic</code> 不允许开发者自己复写其 <code>getter</code> 方法，强制复写会得到一个警告。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Writable atomic property &apos;name&apos; cannot pair a synthesized setter with a user defined getter</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="readonly-amp-readwrite"><a href="#readonly-amp-readwrite" class="headerlink" title="readonly &amp; readwrite"></a>readonly &amp; readwrite</h2><p><code>readonly</code> 和 <code>readwrite</code> 其实就是编译器级别帮你做了只读和读写的处理。<br><code>readonly</code> 是告诉编译器不用生成 <code>setter</code> 方法，同时如果你对这个 <code>readonly</code> 属性赋值的时候编译器会报错  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Assignment to readonly property</span><br></pre></td></tr></table></figure>

<p><code>readwrite</code> 是默认的属性，它会告诉编译器自动生成 <code>setter</code> 和 <code>getter</code> 方法。开发者可以随意复写这两个方法来满足自己的时机情况。</p>
<h2 id="补充关于自动合成属性的声明。"><a href="#补充关于自动合成属性的声明。" class="headerlink" title="补充关于自动合成属性的声明。"></a>补充关于自动合成属性的声明。</h2><p><code>Clang</code> 提供了对已声明属性自动合成的支持。这个功能提供了没有被 <code>@dynamic</code> 修饰的属性的 <code>getter</code> 和 <code>setter</code> 方法，而不用用户手动添加。</p>
<p>Clang provides support for autosynthesis of declared properties. Using this feature, clang provides default synthesis of those properties not declared @dynamic and not having user provided backing getter and setter methods. __has_feature(objc_default_synthesize_properties) checks for availability of this feature in version of clang being used.</p>
<h2 id="一些面试时常遇到的-QA"><a href="#一些面试时常遇到的-QA" class="headerlink" title="一些面试时常遇到的 QA"></a>一些面试时常遇到的 QA</h2><p><strong>Q: assign, weak 和 unsafe_unretained 的区别?</strong><br>A: assign 和 unsafe_unretained 是等价的。weak 和它们区别是在对象释放的时候增加了将其置为 <code>nil</code> 的功能。</p>
<p><strong>Q: atomic 是不是线程安全的？</strong><br>A: 参考上面说明.</p>
<p><strong>Q: <code>@property NSString *name;</code> 这个属性的 <code>attribute</code> 是?</strong><br>A: strong,atomic,readwrite. </p>
<p>参考<br><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a><br><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">Objective-C Automatic Reference Counting (ARC)</a><br><a href="http://www.vanbein.com/posts/ios基础/2015/12/08/propertyshu-xing-xiu-shi-fu-zong-jie/" target="_blank" rel="noopener">property属性修饰符总结</a><br><a href="http://www.ios-blog.co.uk/tutorials/objective-c/objective-c-property-attribute-reference-guide/" target="_blank" rel="noopener">Objective-C: Property Attribute Reference Guide</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6" target="_blank" rel="noopener">Encapsulating Data</a><br><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html" target="_blank" rel="noopener">Variable property attributes or Modifiers in iOS</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/06/属性和运行时/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/06/属性和运行时/" itemprop="url">属性和运行时</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-06T17:30:03+08:00">2018-01-06</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/06/属性和运行时/" class="leancloud_visitors" data-flag-title="属性和运行时">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><code>@property</code> 的本质是什么?</li>
<li><code>@property</code> 和运行时有什么关系?</li>
<li><code>@property</code> 一个 demo</li>
</ol>
<h1 id="property-的本质是什么"><a href="#property-的本质是什么" class="headerlink" title="property 的本质是什么"></a><code>property</code> 的本质是什么</h1><p><code>@property</code> 的本质就是成员变量加 <code>getter</code> 和 <code>setter</code> 方法。<code>getter</code> 和 <code>setter</code> 方法是编译器自动为我们生成的。我们也可以尝试去复写 <code>getter</code> 和 <code>setter</code> 方法，在设置成员变量前后增加一些我们想要的业务逻辑。</p>
<p><code>@property</code> 有不同的 <code>attribute</code> : <code>readonly</code>,<code>atomic</code>,<code>nonatomic</code> 等等。编译器会根据不同的 <code>attribute</code> 生成不同的 <code>getter</code> 和 <code>setter</code> 方法</p>
<h1 id="property-和运行时有什么关系"><a href="#property-和运行时有什么关系" class="headerlink" title="property 和运行时有什么关系?"></a><code>property</code> 和运行时有什么关系?</h1><p>来看下运行时系统对 <code>property</code> 相关类型的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Element, typename List, uint32_t FlagMask&gt;</span><br><span class="line">struct property_list_t : entsize_list_tt&lt;property_t, property_list_t, 0&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct property_t *objc_property_t;</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char *name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>entsize_list_tt</code> 是通过 <code>C++</code> 的容器类，提供了容器类的基本方法，通过这些基本方法可以管理数据并以遍历的方式获取容器内的数据。<code>property_list_t</code> 是管理 <code>property_t</code> 的一个属性类型。</p>
</blockquote>
<p>了解了基本数据类型之后，我们来讨论几个问题</p>
<h2 id="类是怎么获取到-property-的"><a href="#类是怎么获取到-property-的" class="headerlink" title="类是怎么获取到 @property 的?"></a>类是怎么获取到 <code>@property</code> 的?</h2><p>看源码及注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">    //依次遍历父类</span><br><span class="line">    for ( ; cls; cls = cls-&gt;superclass) &#123;</span><br><span class="line">        //遍历当前类的属性列表</span><br><span class="line">        for (auto&amp; prop : cls-&gt;data()-&gt;properties) &#123;</span><br><span class="line">            //比较字符串如果相等就返回当前的 property</span><br><span class="line">            if (0 == strcmp(name, prop.name)) &#123;  </span><br><span class="line">                return (objc_property_t)&amp;prop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类是怎么增加-property-的"><a href="#类是怎么增加-property-的" class="headerlink" title="类是怎么增加 property 的?"></a>类是怎么增加 <code>property</code> 的?</h2><p>看源码及注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static bool _class_addProperty(Class cls, const char *name, </span><br><span class="line">                   const objc_property_attribute_t *attrs, unsigned int count, </span><br><span class="line">                   bool replace)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return NO;</span><br><span class="line">    if (!name) return NO;</span><br><span class="line">    //先从当前类获取指定名称的 property，如果有而且 caller 不想替换则直接返回</span><br><span class="line">    property_t *prop = class_getProperty(cls, name);</span><br><span class="line">    if (prop  &amp;&amp;  !replace) &#123;</span><br><span class="line">        // already exists, refuse to replace</span><br><span class="line">        return NO;</span><br><span class="line">    &#125; </span><br><span class="line">    //替换当前 property 流程，其实就是把 property 相关的 attributes 进行替换。</span><br><span class="line">    else if (prop) &#123;</span><br><span class="line">        // replace existing</span><br><span class="line">        rwlock_writer_t lock(runtimeLock);</span><br><span class="line">        try_free(prop-&gt;attributes);</span><br><span class="line">        //参数 count 是 attrs 的数量。</span><br><span class="line">        prop-&gt;attributes = copyPropertyAttributeString(attrs, count);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //为新的 property 分配空空间。值得注意的是这里并不是直接分配的 property 而是通过 property_list 进行操作的。</span><br><span class="line">        property_list_t *proplist = (property_list_t *)malloc(sizeof(*proplist));</span><br><span class="line">        proplist-&gt;count = 1;</span><br><span class="line">        proplist-&gt;entsizeAndFlags = sizeof(proplist-&gt;first);</span><br><span class="line">        proplist-&gt;first.name = strdupIfMutable(name);</span><br><span class="line">        proplist-&gt;first.attributes = copyPropertyAttributeString(attrs, count);</span><br><span class="line">        //cls-&gt;data() 拿到 class_rw_t 结构体，结构体里的 properties 是 property_array_t 类型，将新的 property 加入到 property 数组中。</span><br><span class="line">        cls-&gt;data()-&gt;properties.attachLists(&amp;proplist, 1);</span><br><span class="line">        </span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="property-和成员变量是怎么对应起来的？"><a href="#property-和成员变量是怎么对应起来的？" class="headerlink" title="property 和成员变量是怎么对应起来的？"></a><code>property</code> 和成员变量是怎么对应起来的？</h2><p>其实是在编译这一步就做好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface Fan : NSObject</span><br><span class="line">@property (nonatomic,strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>编译 clang -rewrite-objc main.m  之后结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object Fan;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Fan$_name;</span><br><span class="line">struct Fan_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line">// @property (atomic,strong) NSString *name;</span><br><span class="line">/* @end */</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>name</code> 属性变成了成员变量 <code>_name</code>。</p>
<h2 id="property-一个-demo"><a href="#property-一个-demo" class="headerlink" title="property 一个 demo"></a><code>property</code> 一个 demo</h2><p>我们之前猜测不同 <code>property</code> 的 <code>attribute</code> 会对编译器造成影响，即生成出来的 <code>setter</code> 和 <code>getter</code> 方法可能不同，比如 <code>atomic</code> 的 <code>setter</code> 方法可能会有锁的实现，于是我补充了上面源码的 <code>getter</code> 和 <code>setter</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static NSString * _I_Fan_name(Fan * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)); &#125;</span><br><span class="line">static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)) = name; &#125;</span><br></pre></td></tr></table></figure>

<p>发现 setter 并没有什么特别的地方… </p>
<p>难道我的验证有问题吗？感觉不应该。我尝试在 demo 中给 <code>name</code> 属性赋值，并打了个符号断点 <code>objc_setProperty_atomic</code> 发现这个方法确实走了，所以 <code>clang</code> 出来的结果应该是有问题的。怎么生成更准确的编译结果我也不清楚。。 </p>
<p><img src="/media/Jietu20180106-185957.png" alt="Jietu20180106-185957"></p>
<p>你也许会问 <code>objc_setProperty_atomic</code> 这个是干什么用的，翻源码到 <code>objc-accessors.mm</code> 这个文件看，可以看到不同的修饰符走了不同的设置属性的方法比如 <code>objc_setProperty_nonatomic</code>，<code>objc_setProperty_atomic</code>，<code>objc_setProperty_atomic_copy</code> 最终他们都调用了 <code>reallySetProperty</code> 这个方法接收了众多参数，根据不同的参数，走了不同的执行流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    id oldValue;</span><br><span class="line">    //这里的 offset 其实就是上一步编译时候确定的。</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot == newValue) return;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //在这里看到 atomic 确实是使用自旋锁来对赋值进行了保护。</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，属性机制的实现不仅靠编译时，运行时也起了很大的作用。</p>
<p>一个思考，能否在运行时候动态添加属性呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/29/NSError-最佳实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/29/NSError-最佳实践/" itemprop="url">NSError 最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T17:33:36+08:00">2017-12-29</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/12/29/NSError-最佳实践/" class="leancloud_visitors" data-flag-title="NSError 最佳实践">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NSError-的使用"><a href="#NSError-的使用" class="headerlink" title="NSError 的使用"></a>NSError 的使用</h1><p>访问系统的一些资源的时候，不可避免的会遇到一些错误，我们需要告诉用户或者提醒我们自己遇到什么问题了，方便定位解决。比如移除指定路径文件或者目录的时候，可能文件不存在或者路径有问题等等，我们需要知道究竟为什么不能成功移除，这时候错误信息就很重要了，看下系统是怎么设计这类 API 的。<code>- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error;</code>  </p>
<p>使用类似 API 的时候通常都是传递 <code>NSError * _Nullable *</code> 这种参数，目的是为了延长 error 的初始化时机，让 error 在执行任务的时候再初始化并赋予错误信息。</p>
<p><code>NSError</code> 里面包含的信息很丰富。主要是三个，domain，code 和错误相关的信息。code 是和 domain 相关的。</p>
<p>一个 NSError 的最佳实践是是使用倒序域名方式，这样可以有效避免 NSError 的域名重复。然后根据倒序域名定义错误 code，域名不重复的话，这些 code 可以随意定制，是不会和别的域名下的 code 冲突的。具体看下面 demo </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static NSString *const kUserInfoDomain = @&quot;com.app.userinfo&quot;;</span><br><span class="line"></span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">    AUIUserNotExist = 0,</span><br><span class="line">    AUIUserNameEmpty,</span><br><span class="line">&#125; AUIErrorCode;</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self fetchUserInfoWithError:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)fetchUserInfoWithError:(NSError **)error &#123;</span><br><span class="line">    NSDictionary *errInfo =@&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;;</span><br><span class="line">    - (void)btnPressed:(id)sender &#123;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    [self fetchUserInfoWithError:error];</span><br><span class="line">    NSLog(@&quot;error = %@&quot;,error);</span><br><span class="line">&#125;</span><br><span class="line">//模拟一次错误获取</span><br><span class="line">- (NSString *)fetchUserInfoWithError:(NSError **)error &#123;</span><br><span class="line">    NSDictionary *errInfo = @&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;;</span><br><span class="line">    if(error != NULL)&#123;</span><br><span class="line">        *error = [NSError errorWithDomain:kUserInfoDomain code:AUIUserNotExist userInfo:errInfo];</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上错误处理代码中需要注意的一点就是 error 的判断 <code>if(error != NULL)</code> 加这一行的作用是区分一下两种调用方式</p>
<ol>
<li><code>[self fetchUserInfoWithError:nil];</code></li>
<li><code>NSError *error = nil; [self fetchUserInfoWithError:error];</code></li>
</ol>
<p>如果是像前者一样调用的话，是不会走进这个 <code>if(error != NULL)</code>分支判断，我们没必要为这种情况单独初始化一个 <code>error</code> 实例。</p>
<p>以上，在帮别的同事封装可调用 API 的时候增加必要的 NSError 参数，不仅方便别人，其实也是方便自己。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://nshipster.com/nserror/" target="_blank" rel="noopener">NSError</a><br><a href="https://stackoverflow.com/questions/3276127/best-practice-nserror-domains-and-codes-for-your-own-project-app" target="_blank" rel="noopener">Best Practice - NSError domains and codes for your own project/app</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="FanFrank">
            
              <p class="site-author-name" itemprop="name">FanFrank</p>
              <p class="site-description motion-element" itemprop="description">iOS & macOS Develop</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/fanxiushan/" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FanFrank</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("fnYkA3dAQO9X0BxvP41VcLiK-gzGzoHsz", "JNMemtBzWyj0aq2zz5qKNGTb");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
