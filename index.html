<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Clang 编译器提供了 OC 自动合成属性的功能。如果一个属性没有被声明为 @dynamic 或者开发者没有自定制它的 getter 或者 setter 方法实现。那 Clang 会自动为你合成 getter 和 setter 方法的实现同时生成对应的成员变量，检查 Clang 编译器是否支持自动合成使用__has_feature(objc_default_synthesize_properti">
<meta property="og:type" content="article">
<meta property="og:title" content="属性自动合成">
<meta property="og:url" content="http://yoursite.com/2018/01/11/属性自动合成/index.html">
<meta property="og:site_name" content="FanFrank&#39;s Site">
<meta property="og:description" content="Clang 编译器提供了 OC 自动合成属性的功能。如果一个属性没有被声明为 @dynamic 或者开发者没有自定制它的 getter 或者 setter 方法实现。那 Clang 会自动为你合成 getter 和 setter 方法的实现同时生成对应的成员变量，检查 Clang 编译器是否支持自动合成使用__has_feature(objc_default_synthesize_properti">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-16T15:08:54.234Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="属性自动合成">
<meta name="twitter:description" content="Clang 编译器提供了 OC 自动合成属性的功能。如果一个属性没有被声明为 @dynamic 或者开发者没有自定制它的 getter 或者 setter 方法实现。那 Clang 会自动为你合成 getter 和 setter 方法的实现同时生成对应的成员变量，检查 Clang 编译器是否支持自动合成使用__has_feature(objc_default_synthesize_properti">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/11/属性自动合成/"/>





  <title>FanFrank's Site</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-111759275-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FanFrank's Site</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/15/AutoreleasePool-理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/AutoreleasePool-理解/" itemprop="url">AutoreleasePool 理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T10:39:51+08:00">2018-01-15</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/15/AutoreleasePool-理解/" class="leancloud_visitors" data-flag-title="AutoreleasePool 理解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从一些问题开始</p>
<ol>
<li>什么是 <code>AutoreleasePool</code> ? 说明一下 <code>NSAutoreleasePool</code> 具体机制?</li>
<li>ARC 时代和 MRC 时代的 <code>AutoreleasePool</code> 机制有什么区别？</li>
<li><code>AutoreleasePool</code> 的实现机制?</li>
<li><code>AutoreleasePool</code> 和 NSRunloop 有什么关系？</li>
<li><code>AutoreleasePool</code> 和线程有什么关系?</li>
<li>什么时候需要我们手动创建 <code>AutoreleasePool</code> ?</li>
</ol>
<h2 id="什么是-AutoreleasePool-如何理解-NSAutoreleasePool"><a href="#什么是-AutoreleasePool-如何理解-NSAutoreleasePool" class="headerlink" title="什么是 AutoreleasePool ? 如何理解 NSAutoreleasePool?"></a>什么是 AutoreleasePool ? 如何理解 NSAutoreleasePool?</h2><p><code>NSAutoreleasePool</code> 对象的官方说明是一个支持 <code>Cocoa</code> 引用计数式内存管理的一个对象。 当池子排掉的时候向池子内存储的对象发送 <code>release</code> 消息。</p>
<blockquote>
<p>An object that supports Cocoa’s reference-counted memory management system.<br>An autorelease pool stores objects that are sent a release message when the pool itself is drained.</p>
</blockquote>
<p>具体机制说明：<br>在引用计数式的内存管理中，<code>NSAutoreleasePool</code> 对象包含了收到了 <code>_autorelease</code> 消息的对象，这些 <code>autorelease</code> 对象（我们称被标记了 <code>__autorelease</code> 的对象为 <code>autorelease</code> 对象）的生命周期被延长到了这个 <code>NSAutoreleasePool</code> drain 的时候。也可以这么说 <code>autorelease</code> 和 <code>release</code> 的区别仅仅是 <code>autorelease</code> 是延时释放(即等待 <code>AutoreleasePool drain</code>) 而 <code>release</code> 是立即释放。</p>
<p>感觉说到这儿，其实我们可以说 <code>NSAutoreleasePool</code> 就是一个帮助我们管理内存的一个工具。</p>
<p>其实不光是我们自己可以手动创建 <code>NSAutoreleasePool</code> 对象，系统也帮我们维护了一个 <code>NSAutoreleasePool</code> 对象，在 <code>runloop</code> 迭代中不断 <code>Push</code> 和 <code>Pop</code>，从而不会堆积过多的 <code>autorelease</code> 对象引起内存疯长。你可能会好奇，哪会有那么多 <code>autorelease</code> 对象？举个例子来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // str 其实是一个 autorelease 对象</span><br><span class="line">    NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;];</span><br><span class="line">    reference = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题外话：为啥  str 是一个 <code>autorelease</code> 对象呢？<br>这个就需要知道下内存管理的知识了，使用 <code>alloc</code>,<code>new</code>,<code>copy</code>和<code>mutableCopy</code>这些关键字生成的对象是自己持有，反之不是（参考 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1" target="_blank" rel="noopener">Memory Management Policy</a>）。使用 <code>stringWithFormat:</code> 类方法生成的 <code>str</code> 没有持有它的对象，只能通过 <code>autorelease</code> 这种方式来延长它的生命周期。具体 <code>autorelease</code> 的时机是在 <code>stringWithFormat</code> 内部做的。</p>
<p><code>Cocoa</code> 的 <code>Framework</code> 里大量生成了 <code>autorelease</code> 的对象，所以官方说明里 <code>Cocoa</code> 代码执行是预期在一个 <code>autorelease</code> 环境中。</p>
<h2 id="ARC-时代和-MRC-时代的-AutoreleasePool-机制有什么区别？"><a href="#ARC-时代和-MRC-时代的-AutoreleasePool-机制有什么区别？" class="headerlink" title="ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？"></a>ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？</h2><p>没啥根本区别，只是写法稍有不同。看两个 ARC 和 MRC 时代 <code>autorelease</code> 的两个经典写法。</p>
<p>MRC 的 case:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = [[NSAutorelease alloc] init];</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure>
<p>ARC 的 case(注:<a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool" target="_blank" rel="noopener">其实 MRC 也可以这么写</a>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    //_autorelease 为所有权修饰符。</span><br><span class="line">    id _autorelease obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ARC</code> 中的几点变化：</p>
<ol>
<li><code>ARC</code> 中是不能使用 <code>autorelease</code> 方法，也不能使用 <code>NSAutoreleasePool</code> 类。</li>
<li><code>ARC</code> 系统提供了 <code>@autoreleasepool</code> 块来替代 <code>NSAutoreleasePool</code> 对象的生成持有以及废弃的功能。</li>
<li><p>通过将对象赋值给附加了 <code>__autoreleaseing</code> 修饰符变量来替代调用 <code>autorelease</code> 方法。即</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj autorelease];</span><br></pre></td></tr></table></figure>
<p> 等价于</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id _autorelease obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一般我们不会显式的去使用 <code>__autorelease</code> 修饰符，因为ARC 下编译器帮我们做了一些工作，即编译器会检查方法是否以 <code>alloc/new/copy/mutableCopy</code> 开始，如果不是的话将返回的值对象注册到 <code>autoreleasePool</code>。</p>
<p>不需要显式地写 <code>__autorelease</code> 的几种场景</p>
<ol>
<li><p>自动释放池随意生成对象，不需要显式地添加 <code>autorelease</code>。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    //默认的 strong 修饰符会自动处理这种情况.</span><br><span class="line">    id obj = [[NSObject alloc] init];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回值的场景</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray *)array &#123;</span><br><span class="line">    id obj = [[NSMutableArray alloc] init];</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在 MRC 时代，obj 是需要被发送 <code>autorelease</code> 方法的，ARC 时代不需要这么做，这个对象作为函数的返回值会自动被注册到 <code>autoreleasePool</code> 中</p>
</li>
<li><p>访问 <code>weak</code> 变量的时肯定会涉及到 <code>autoreleasePool</code></p>
<p> 因为 <code>weak</code> 对对象是弱引用，对象随时会被释放，但是使用 <code>autoreleasePool</code> 会延时释放，保证 <code>weak</code> 访问过程中不会出现对象被释放这种状况。</p>
</li>
<li><p><code>NSObject **obj</code> 其实就是 <code>NSObject *_autorelease * obj</code>。<br> 因为<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-SW1" target="_blank" rel="noopener">我们不持有通过引用返回的对象</a>。这种情况只能是 <code>autorelease</code>。</p>
</li>
</ol>
<h2 id="AutoreleasePool-的实现机制"><a href="#AutoreleasePool-的实现机制" class="headerlink" title="AutoreleasePool 的实现机制?"></a>AutoreleasePool 的实现机制?</h2><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>对以下代码所在文件执行 <code>clang -rewrite-objc xx.m</code> 重写命令，可以看到 OC 对应的 C++ 的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的 C++ 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>@autoreleasepool</code> 被转换为一个名为 <code>__AtAutoreleasePool</code> 的数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main 函数其实可以理解为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    &#123; </span><br><span class="line">        void *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0);</span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 的实现在 runtime 源码 <code>NSObject.mm</code>中可以找到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void * objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AutoreleasePoolPage-的介绍"><a href="#AutoreleasePoolPage-的介绍" class="headerlink" title="AutoreleasePoolPage 的介绍"></a><code>AutoreleasePoolPage</code> 的介绍</h3><p>这里涉及到了 <code>AutoreleasePoolPage</code> 这个数据结构，接下来就看下 <code>AutoreleasePoolPage</code> 这个数据结构是啥样的？<code>AutoreleasePoolPage</code> 是个 C++ 的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage  &#123;</span><br><span class="line">    magic_t const magic;    //magic 用于对当前 AutoreleasePoolPage 完整性的校验</span><br><span class="line">    id *next;               //当前 autoreleasePoolPage 最上层的对象的指针。</span><br><span class="line">    pthread_t const thread; //thread 保存了当前页所在的线程</span><br><span class="line">    AutoreleasePoolPage * const parent;//指向上一个 AutoreleasePoolPage 对象.</span><br><span class="line">    AutoreleasePoolPage *child; //指向下一个 AutoreleasePoolPage 对象.</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关于 <code>AutoreleasePoolPage</code> 的说明</strong></p>
<ol>
<li><p>可以看到其实并没有一个整体的自动释放池对象，自动释放池是由一个双向链表构成。当一个 <code>AutoreleasePoolPage</code> 的空间被占满之后继续创建新的 <code>AutoreleasePoolPage</code> 对象。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//child 指向的是下一个 AutoreleasePoolPage 对象的指针</span><br><span class="line">// 这个方法是当前 page 如果满的情况下创建新的 page.</span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        else page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line">    ....</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line">// 初始化 pool 的方法 在这个里面对 parent 和 child 进行了赋值.</span><br><span class="line">AutoreleasePoolPage(AutoreleasePoolPage *newParent) </span><br><span class="line">    : magic(), next(begin()), thread(pthread_self()),</span><br><span class="line">      parent(newParent), child(nil), </span><br><span class="line">      depth(parent ? 1+parent-&gt;depth : 0), </span><br><span class="line">      hiwat(parent ? parent-&gt;hiwat : 0) &#123; </span><br><span class="line">    if (parent) &#123;</span><br><span class="line">        parent-&gt;child = this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个 <code>AutoreleasePoolPage</code> 对象都存储着当前的线程 <code>id</code> 参考上面的 <code>AutoreleasePoolPage</code> 的初始化方法。使用 <code>pthread_self()</code> 拿到当前的线程 <code>id</code> 然后保存到 <code>thread</code> 成员变量里。</p>
</li>
<li><p><code>AutoreleasePoolPage</code> 的内存大小是 4096 个字节。是 80386 机器上的每页的字节数。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//初始化 AutoreleasePoolPage 的方法,size 是个宏定义的 4096</span><br><span class="line">static void * operator new(size_t size) &#123;</span><br><span class="line">    return malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AutoreleasePoolPage</code> 存储 <code>autorelease</code> 对象是通过自己内部的 <code>next</code> 指针去实现。从实现上可以看到 <code>AutoreleasePoolPage</code> 还是从低内存地址向高内存地址增长。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id *add(id obj) &#123;</span><br><span class="line">    id *ret = next;  // faster than `return next-1` because of aliasing</span><br><span class="line">    *next++ = obj;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由此大致能得到 <code>AutoreleasePoolPage</code> 的内存结构如图（来自 Sunny 大神博客）<br> <img src="/media/Jietu20180125-103109.png" alt="Jietu20180125-103109"></p>
</li>
</ol>
<h3 id="autorelease-消息调用栈"><a href="#autorelease-消息调用栈" class="headerlink" title="autorelease 消息调用栈"></a>autorelease 消息调用栈</h3><p>了解了这个数据结构后看下 <code>autorelease</code> 消息的调用栈。</p>
<p><img src="/media/15168026389568.jpg" alt=""><br>我们看下 <code>AutoreleasePoolPage</code> 中 <code>autorelease</code> 方法实现其实就是将 <code>autorelease</code> 对象存储到 <code>AutoreleasePoolPage</code> 的过程。下面是大致实现的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static inline id autorelease(id obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">//这个是将 obj 存入 AutoreleasePoolPage 的方法。</span><br><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    //hotPage 应该是去 TLS(线程本地存储) 中获取 AutoreleasePoolPage。</span><br><span class="line">    //如果是程序刚启动的话，这儿肯定拿到的空。</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        // AutoreleasePoolPage 不满的时候直接往进加</span><br><span class="line">        return page-&gt;add(obj); //绝大多数情况我们走的都是这个分支。</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        // AutoreleasePoolPage 满了，则创建新的 page，将 obj 放到新的 page 里去.</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 创建新的 page.</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="autorelease-pop-消息"><a href="#autorelease-pop-消息" class="headerlink" title="autorelease pop 消息"></a>autorelease pop 消息</h3><p>对应 <code>push</code> 的是 <code>pop</code>，<code>pop</code> 即为将存储到 <code>AutoreleasePoolPage</code> 的对象释放对应原型为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意的是这里并没有直接传入对象，而是传入了一个 <code>ctxt</code> 的指针，根据内部实现来看，自动释放池根据 <code>ctxt</code> 拿到它当前所在的 <code>AutoreleasePoolPage</code> ，然后将 <code>AutoreleasePoolPage</code> 的 <code>ctxt</code> 的位置开始到到最新的 <code>AutoreleasePoolPage</code> 存储的 <code>autorelease</code> 对象全部释放。即我们可以理解为自动释放池代码块儿开始的时候会在 <code>AutoreleasePoolPage</code> 进行一个占位，然后将后续的 <code>autorelease</code> 对象都放到占位后，这样就能确定当前自动释放池块儿里的对象是从哪到哪，理解了这一点也就能理解 <code>autorelease</code> 的嵌套实现了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static inline void pop(void *token)  &#123;</span><br><span class="line">    AutoreleasePoolPage *page; id *stop;</span><br><span class="line">    ..</span><br><span class="line">    page = pageForPointer(token); //拿到 token 所在的 AutoreleasePoolPage</span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    if (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        if (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            // Start of coldest page may correctly not be POOL_BOUNDARY:</span><br><span class="line">            // 1. top-level pool is popped, leaving the cold page in place</span><br><span class="line">            // 2. an object is autoreleased with no pool</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (PrintPoolHiwat) printHiwat();</span><br><span class="line">    page-&gt;releaseUntil(stop);  //一直释放对象到 token 的位置.</span><br><span class="line">&#125;</span><br><span class="line">//一直释放对象的函数</span><br><span class="line">void releaseUntil(id *stop)  &#123;</span><br><span class="line">    while (this-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage(); //拿到当前的 page.</span><br><span class="line">        id obj = *--page-&gt;next; </span><br><span class="line">        memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next));</span><br><span class="line">        if (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);  //取出对象不断发送 relesse 消息..</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setHotPage(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AutoreleasePool-和-NSRunloop-有什么关系？"><a href="#AutoreleasePool-和-NSRunloop-有什么关系？" class="headerlink" title="AutoreleasePool 和 NSRunloop 有什么关系？"></a>AutoreleasePool 和 NSRunloop 有什么关系？</h2><p>先来个实例看下 <code>Runloop</code> 是什么东西。建一个普通的 Single View App 工程。点击按钮然后在按钮点击事件里打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)btnPressed:(id)sender &#123;</span><br><span class="line">    NSRunLoop *runloop = [NSRunLoop currentRunLoop]; </span><br><span class="line">    //在这里打断点然后 po runloop 得到下面结果。（省略大部分无关内容）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) po runloop </span><br><span class="line">common mode items = &lt;CFBasicHash 0x604000249360 [0x110875bb0]&gt;</span><br><span class="line">	1 : &lt;CFRunLoopObserver 0x6040001370c0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), ....</span><br><span class="line">	......</span><br><span class="line">	4 : &lt;CFRunLoopObserver 0x604000136ee0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), ....</span><br></pre></td></tr></table></figure>
<p>注意看上面的 <code>activities</code>,它对应的定义是这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以确定 <code>Autorelease</code> 机制在 <code>Runloop</code> 进入和退出(和休眠前触发) <code>CommonMode</code> 的时候进行观察，当 <code>Runloop</code> 运行到指定的时机的时候回触发 <code>_wrapRunLoopWithAutoreleasePoolHandler</code> 回调方法。</p>
<p><code>_wrapRunLoopWithAutoreleasePoolHandler</code> 这个方法的实现其实我们并不清楚，网上没有找到对应的实现，不过我们可以打下符号断点来看看有没有线索。果然应用刚启动就执行了这些方法。看左侧的调用栈确实是从 Observer 的回调执行过来的。下面两个是我们熟悉的 Pop 和 Push 操作，<strong>基本上可以确认，<code>Autorelease</code> 机制是在进入 <code>Runloop</code> 的时候就创建了一个新的 <code>AutoreleasePoolPage</code>。退出或者休眠的的时候回收 <code>AutoreleasePoolPage</code>。</strong></p>
<p> <img src="/media/15170502117985.jpg" alt=""></p>
<h2 id="AutoreleasePool-和线程有什么关系"><a href="#AutoreleasePool-和线程有什么关系" class="headerlink" title="AutoreleasePool 和线程有什么关系?"></a>AutoreleasePool 和线程有什么关系?</h2><p><code>Cocoa</code> 应用程序里的每个线程会自动维护一个释放池，就是通过上面 <code>Runloop</code> 的方式。但是如果没有 <code>Runloop</code> 呢？</p>
<p>之前看到有人问了一个问题：子线程默认不会开启 <code>Runloop</code>，那出现 <code>Autorelease</code> 对象如何处理？不手动处理会内存泄漏吗？<br>答案是不会。 </p>
<p>具体 demo 如下 <a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)test &#123;</span><br><span class="line">    MyClass *my = [[[MyClass alloc] init] autorelease];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[my description]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的结果是 <code>MyClass</code> 实例被释放掉了。理论上来说子线程并没有 <code>Runloop</code> 也就没有自动释放池观察 <code>Runloop</code> 状态，也就不会自动去执行对应的 <code>autorelease</code> 的方法。根据引用计数来看的话，<code>autorelease</code> 方法和 <code>AutoreleasePool</code> 在一起才能发生作用，而目前又没有 <code>AutoreleasePool</code>，所以那是咋回事？</p>
<p>事实上即使没有 <code>Runloop</code>，线程和 <code>AutoreleasePool</code> 也能直接发生关系。向某个对象发送 <code>autorelease</code> 消息后，会自动创建 <code>AutoreleasePoolPage</code>。<code>autorelease</code> 消息的调用栈可以参考上面的说明。最终 <code>TLS</code>(线程本地存储)会存储 <code>AutoreleasePoolPage</code> 对象。大致代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);</span><br><span class="line">tls_set_direct(key, (void *)page);</span><br></pre></td></tr></table></figure>
<p>这里具体实现比较复杂，而且根据是这种情况并不适用于主线程。可以看 <a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">StackOverflow</a> 的相关回答。这里不具体贴了。</p>
<p>我个人觉得为了程序可读性还有稳定性，还是加上 <code>@autoreleasepool</code> 更妥。说稳定性是因为不能过度依赖于 <code>runtime</code> 的底层机制，万一 <code>runtime</code> 底层机制后续有变化可能会造成程序的异常。</p>
<h2 id="什么时候需要我们手动创建-AutoreleasePool"><a href="#什么时候需要我们手动创建-AutoreleasePool" class="headerlink" title="什么时候需要我们手动创建 AutoreleasePool?"></a>什么时候需要我们手动创建 AutoreleasePool?</h2><ol>
<li>如果工程只是 Foundation-Only(命令行那种),而不是 Cocoa application。那需要手动创建自动释放池。</li>
<li>如果程序存活时间长，而且可能生成大量临时对象（比如循环里创建了一堆）那应该在合适地方（比如循环里）手动释放池，降低内存峰值（不用担心嵌套使用 <code>AutoreleasePool</code> 的问题）</li>
<li>你创建了一个新线程，需要创建自动释放池。这个跟我们上面一小节说的是略微冲突，但是在上面已经说过了，添加 <code>AutoreleasePool</code> 是最佳实践。</li>
</ol>
<h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a><br><a href="https://draveness.me/autoreleasepool" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 autoreleasepool</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="https://www.jianshu.com/p/5559bc15490d" target="_blank" rel="noopener">iOS中autorelease的那些事儿</a><br><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226-CH1-SW8" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a><br><a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool" target="_blank" rel="noopener">NSAutoreleasePool</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="noopener">Using Autorelease Pool Blocks</a><br><a href="http://www.samirchen.com/ios-arc/" target="_blank" rel="noopener">iOS ARC 内存管理要点</a><br><a href="https://www.jianshu.com/p/f87f40592023" target="_blank" rel="noopener">各个线程 Autorelease 对象的内存管理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/11/属性自动合成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/11/属性自动合成/" itemprop="url">属性自动合成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-11T13:12:45+08:00">2018-01-11</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/11/属性自动合成/" class="leancloud_visitors" data-flag-title="属性自动合成">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Clang 编译器提供了 OC 自动合成属性的功能。如果一个属性没有被声明为 <code>@dynamic</code> 或者开发者没有自定制它的 <code>getter</code> 或者 <code>setter</code> 方法实现。那 <code>Clang</code> 会自动为你合成 <code>getter</code> 和 <code>setter</code> 方法的实现同时生成对应的成员变量，检查 <code>Clang</code> 编译器是否支持自动合成使用<code>__has_feature(objc_default_synthesize_properties)</code> 这个条件判断。举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_default_synthesize_properties)</span><br><span class="line">    //support autosynthesis</span><br><span class="line">#else</span><br><span class="line">    //not support</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>当编译器不能自动为你合成属性的时候，需要开发者手动进行。其实也可以换个说法，什么时候需要开发者手动 <code>@synthesize</code>。</p>
<p>举个例子，开发中偶尔会遇到这种报错的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) NSString *name;</span><br><span class="line">.....</span><br><span class="line">@implementation</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    _name = name; #编译错误:Use of undeclared identifier &apos;_name&apos;; did you mean &apos;name&apos;?</span><br><span class="line">&#125;</span><br><span class="line">-  (NSString *)name &#123;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这个时候需要我们手动的添加一行代码 <code>@synthesize name = _name;</code> 编译错误就会消失。或者你把编译错误的那行去掉，然后使用命令 <code>clang -rewrite-objc main.m</code> 编译原文件，发现生成的对象结构体中并没有 <code>name</code> 对应的成员变量。</p>
<p>接下来就是总结什么场景下需要我们手动添加 <code>@synthesize</code>。</p>
<ol>
<li>就是我们上面 <code>demo</code> 展示的这种可读写的属性，但是开发者自定义了 <code>getter</code> 和 <code>setter</code> 方法，注意必须是同时复写，如果只复写 <code>setter</code> 或者 <code>getter</code> 的话是不会出现问题的。这也是 <code>clang</code> 编译器不支持的自动合成的场景。</li>
<li>只读属性，开发者自定义了 <code>getter</code> 方法。</li>
<li><code>@dynamic</code> 修饰的属性，<code>@dynamic</code> 本质是告诉编译器 <code>setter</code> 与 <code>getter</code> 方法由开发者自己定义，不自动合成。</li>
<li>在协议 <code>@protocol</code> 中声明的属性。</li>
<li>在类别 <code>@category</code> 中声明的属性。这是因为类别不支持自动添加成员变量，需要手动进行引用关联。</li>
<li>如果你复写了父类的属性，你也需要显式地添加 <code>@synthesize</code></li>
<li>如果你想手动修改成员变量名的话，可以使用 <code>@synthesize</code> 修改，比如默认成员变量名是 <code>_name</code> 使用 <code>@synthesize name = yname;</code> 修改成员变量名为 <code>yname</code>，但是不建议这么做。</li>
</ol>
<p>#参考地址#<br><a href="https://stackoverflow.com/questions/19784454/when-should-i-use-synthesize-explicitly" target="_blank" rel="noopener">When should I use @synthesize explicitly?</a><br><a href="http://clang.llvm.org/docs/LanguageExtensions.html#objective-c-autosynthesis-of-properties" target="_blank" rel="noopener">Objective-C Autosynthesis of Properties</a><br><a href="https://www.jianshu.com/p/beefa2da05b5" target="_blank" rel="noopener">@synthesize 和 @dynamic 的作用</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/09/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T23:54:10+08:00">2018-01-09</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/09/hello-world/" class="leancloud_visitors" data-flag-title="Hello World">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/09/属性-attribute-总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/属性-attribute-总结/" itemprop="url">属性 attribute 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T21:59:57+08:00">2018-01-09</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/09/属性-attribute-总结/" class="leancloud_visitors" data-flag-title="属性 attribute 总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>@property</code> 和 <code>attribute</code> 的中文翻译都是属性，所以本文就只用英文做区分了。<code>property</code> 的不同 <code>attribute</code> 大致包含下面这些</p>
<ol>
<li>strong               //default</li>
<li>weak</li>
<li>copy</li>
<li>assign               //default</li>
<li>unsafe_unretained</li>
<li>atomic &amp; nonatomic   //default atomic </li>
<li>readonly &amp; readwrite //default readwrite </li>
</ol>
<p>接下来依次说一下这些 <code>attribute</code> 的用处，使用方法还有使用时的可能注意事项</p>
<h2 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h2><p><code>strong</code> 是 <code>ARC</code> 引入的方便内存管理的一种 <code>attribute</code>，跟 <code>MRC</code> 属性中的<code>retain</code> 效果基本是一样的。区别在于编译器遇到 <code>strong</code> 修饰的变量的时候会自动为其在合适的地方插入一条 <code>release</code> 语句。相同的地方就是为了强引用属性。强引用的意思就是当前对象持有自己的属性对象，如果当前对象不释放的话这个属性也不会被释放，而当对象释放的时候，<code>ARC</code> 也会自动为我们处理属性的释放，不需要开发者关心。<code>strong</code> 是我们最常用的一个 <code>attribute</code>。</p>
<p>几个说明：</p>
<ol>
<li><code>strong attribute</code> 和变量前的修饰符 <code>__strong</code> 在 <code>ARC</code> 里的作用是一样的。只不过一个修饰属性一个修饰变量而已。参考 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#property-declarations" target="_blank" rel="noopener">Property declarations</a></li>
<li><p><code>strong</code> 不能用来修饰非对象。否则编译器会报错 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Property with retain(or strong) attribute must be object type</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般如果某个属性前面不需要显式地写出 <code>strong</code> 编译器会自动认为这是 <code>strong</code> 类型的属性。</p>
</li>
<li><p><code>strong</code> 修饰符会自动处理以下两种 case,而引用计数不会出现异常。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;// 自己生成并持有对象</span><br><span class="line">    id __strong obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">&#123; // 非自己生成并持有对象.</span><br><span class="line">    id __strong obj = [NSMutableArray array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>objc_storeStrong</code> 方法的说明，当向一个 <code>__strong</code> 修饰符修饰的对象赋值的时候跟执行下面代码是一样的效果。说白了就是执行了 <code>objc_storeStrong</code> 的方法。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Precondition: object is a valid pointer to a __strong object which </span><br><span class="line">//is adequately aligned for a pointer. value is null or a pointer to a valid object.</span><br><span class="line">void objc_storeStrong(id *object, id value) &#123;</span><br><span class="line">  id oldValue = *object;</span><br><span class="line">  value = [value retain];</span><br><span class="line">  *object = value;</span><br><span class="line">  [oldValue release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 值得说明的是 <code>FRObject *obj = [FRObject frobj];</code> 和 <code>FRObject *obj = temp;</code> 这两句代码编译器的处理是不一样的。第二句会执行如上 <code>objc_storeStrong</code> 的方法，但是第一句不会。我个人理解原因是 <code>obj</code> 初始化的时候并没有 <code>oldValue</code>，所以没有必要这么做。</p>
</li>
</ol>
<h2 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h2><p><code>weak</code> 也是 <code>ARC</code> 引入的方便内存管理的一种 <code>attribute</code>，跟 <code>assign</code> 效果基本是一样的。区别在于在对象被释放的时候，<code>weak</code> 机制会自动将对象置为 nil,保证后续访问这个对象不会因为野指针闪退。</p>
<p>真正引入 <code>weak</code> 的原因是 <code>weak</code> 能解决引起内存泄露的循环引用问题。</p>
<p>几个说明：</p>
<ol>
<li><code>weak</code> 和 <code>strong</code> 一样只能用来修饰对象。</li>
<li><code>weak attribute</code> 和变量前的修饰符 <code>__weak</code> 在 <code>ARC</code> 里的作用是一样的。</li>
</ol>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p><code>copy</code> 要求它修饰的属性必须实现 <code>NSCopy</code> 协议。本质上，当 <code>copy</code> 修饰的属性被赋值的时候，新值会收到一个 <code>copyWithZone</code> 方法，旧的值会被 release。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//clang 编译后的源码</span><br><span class="line"> static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; </span><br><span class="line"> objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Fan, _name), (id)name, 1, 1); </span><br><span class="line"> &#125;</span><br><span class="line"> //runtime 里的对应方法</span><br><span class="line"> void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy)</span><br><span class="line"> //reallySetProperty 有对应 copy 属性的具体实现.</span><br></pre></td></tr></table></figure>
<p><code>copy</code> 的使用场景通常是你希望属性在赋值后一直保持值不变，而不是跟着它指向的对象一直变。讨论比较多的是 <code>NSString</code> 是应该用 <code>copy</code> 还是用 <code>strong</code> 去修饰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic) NSString *name;</span><br><span class="line"></span><br><span class="line">NSMutableString *nameString = [NSMutableString stringWithString:@&quot;John&quot;];</span><br><span class="line">Fan *fan = [[Fan alloc] init];</span><br><span class="line">fan.name = nameString;</span><br><span class="line">NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);</span><br><span class="line">[nameString appendString:@&quot;ny&quot;];</span><br><span class="line">NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);</span><br><span class="line">//输出结果如下</span><br><span class="line">2018-01-11 20:35:18.763988+0800 TTTTT[71790:3384299] fan.name = John 0x10051e9c0</span><br><span class="line">2018-01-11 20:35:18.764449+0800 TTTTT[71790:3384299] fan.name = Johnny 0x10051e9c0</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>fan.name</code> 在没有显式修改的时候被改掉了，这种情况出现在 <code>NSString</code> 指针子类 <code>NSMutableString</code> 的情况下，而 <code>NSMutablString</code> 的修改不会对本身地址产生影响。使用 <code>copy</code> 可以避免。个人觉得使用 <code>copy</code> 还是 <code>strong</code> 还是根据实际情况，如果出了问题知道为什么就好了。</p>
<h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><p>值得注意的是 <code>MRC</code> 时代和 <code>ARC</code> 时代的 <code>assign</code> 使用多少有点区别的。<code>MRC</code> 的 <code>assign</code> 是可以修饰对象还有普通基本类型，因为你根本也没得选。但是 <code>ARC</code> 下虽然 <code>assgin</code> 也都可以修饰基本类型和对象，但是通常修饰对象的话不会用 <code>assign</code> ，因为缺少了 <code>weak</code> 修饰变量被释放时候置为 <code>nil</code> 的特性，很有可能出现内存问题。所以我们现在用 <code>assign</code> 修饰基本类型就好了，需要弱引用的时候用 <code>weak</code> 用来修饰对象。规则也比较明确。</p>
<h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="unsafe_unretained"></a>unsafe_unretained</h2><p><code>unsafe_unretained</code> 其实就是阉割版本的 <code>weak</code> 实现，它缺少正是对象释放时候置为 <code>nil</code> 的特性。但是 <code>unsafe_unretained</code> 还能修饰基本数据类型，<code>weak</code> 不行。</p>
<p>看起来，我们使用 weak 就好了为啥要用 <code>unsafe_unretained</code> 这个属性呢。答案是因为 <code>__weak</code> 只支持 <code>iOS 5.0</code> 和 <code>OS X Mountain Lion</code> 作为部署版本，如果是想要兼容更低的支持 ARC 的版本，比如你想部署回 <code>iOS 4.0</code> 和 <code>OS X Snow Leopark</code> 就不得不使用 <code>unsafe_unretained</code>。</p>
<p>还有一种说法是 <code>weak</code> 底层实现比较繁琐消耗性能，我认为与 <code>weak</code> 带来的好处相比，这点消耗可以忽略。</p>
<h2 id="atomic-amp-nonatomic"><a href="#atomic-amp-nonatomic" class="headerlink" title="atomic &amp; nonatomic"></a>atomic &amp; nonatomic</h2><p><code>atomic</code> 和 <code>nonatomic</code> 区别在于向属性对应成员变量赋值的时候是否为原子写入，即能不能够保证安全写入，从这一点上 <code>atomic</code> 确实是安全的。但是 <code>atomic</code> 并非是线程安全的，因为 <code>atomic</code> 控制的粒度太细了。</p>
<p>举个例子，A 线程向属性写入一个值，A 线程后续再次读这个值之前，可能 B 线程也向同样的属性里写入另外一个值，这样 A 线程读取的时候并非读到的是自己刚写入的值而是一个预期之外的值。</p>
<p>从这一点上看 <code>atomic</code> 似乎用处不是很大，同时 <code>atomic</code> 底层是用锁实现的，频繁写入会影响性能。个人认为最好的实践是，使用 <code>nonatomic</code> 然后自己去处理线程相关的东西。</p>
<p>几个说明：</p>
<ol>
<li><code>atomic</code> 是默认属性。比如 <code>@property NSString *name;</code> 这种属性默认就是 <code>atomic</code> 修饰的。</li>
<li><code>atomic</code> 的底层实现里，赋值和读取值都有锁的保护，而且使用的都是一个锁。</li>
<li><p><code>atomic</code> 不允许开发者自己复写其 <code>getter</code> 方法，强制复写会得到一个警告。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Writable atomic property &apos;name&apos; cannot pair a synthesized setter with a user defined getter</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="readonly-amp-readwrite"><a href="#readonly-amp-readwrite" class="headerlink" title="readonly &amp; readwrite"></a>readonly &amp; readwrite</h2><p><code>readonly</code> 和 <code>readwrite</code> 其实就是编译器级别帮你做了只读和读写的处理。<br><code>readonly</code> 是告诉编译器不用生成 <code>setter</code> 方法，同时如果你对这个 <code>readonly</code> 属性赋值的时候编译器会报错  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Assignment to readonly property</span><br></pre></td></tr></table></figure>
<p><code>readwrite</code> 是默认的属性，它会告诉编译器自动生成 <code>setter</code> 和 <code>getter</code> 方法。开发者可以随意复写这两个方法来满足自己的时机情况。</p>
<h2 id="补充关于自动合成属性的声明。"><a href="#补充关于自动合成属性的声明。" class="headerlink" title="补充关于自动合成属性的声明。"></a>补充关于自动合成属性的声明。</h2><p><code>Clang</code> 提供了对已声明属性自动合成的支持。这个功能提供了没有被 <code>@dynamic</code> 修饰的属性的 <code>getter</code> 和 <code>setter</code> 方法，而不用用户手动添加。</p>
<p>Clang provides support for autosynthesis of declared properties. Using this feature, clang provides default synthesis of those properties not declared @dynamic and not having user provided backing getter and setter methods. __has_feature(objc_default_synthesize_properties) checks for availability of this feature in version of clang being used.</p>
<h2 id="一些面试时常遇到的-QA"><a href="#一些面试时常遇到的-QA" class="headerlink" title="一些面试时常遇到的 QA"></a>一些面试时常遇到的 QA</h2><p><strong>Q: assign, weak 和 unsafe_unretained 的区别?</strong><br>A: assign 和 unsafe_unretained 是等价的。weak 和它们区别是在对象释放的时候增加了将其置为 <code>nil</code> 的功能。</p>
<p><strong>Q: atomic 是不是线程安全的？</strong><br>A: 参考上面说明.</p>
<p><strong>Q: <code>@property NSString *name;</code> 这个属性的 <code>attribute</code> 是?</strong><br>A: strong,atomic,readwrite. </p>
<p>参考<br><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="noopener">Transitioning to ARC Release Notes</a><br><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">Objective-C Automatic Reference Counting (ARC)</a><br><a href="http://www.vanbein.com/posts/ios基础/2015/12/08/propertyshu-xing-xiu-shi-fu-zong-jie/" target="_blank" rel="noopener">property属性修饰符总结</a><br><a href="http://www.ios-blog.co.uk/tutorials/objective-c/objective-c-property-attribute-reference-guide/" target="_blank" rel="noopener">Objective-C: Property Attribute Reference Guide</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW6" target="_blank" rel="noopener">Encapsulating Data</a><br><a href="http://rdcworld-iphone.blogspot.in/2012/12/variable-property-attributes-or.html" target="_blank" rel="noopener">Variable property attributes or Modifiers in iOS</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/06/属性和运行时/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/06/属性和运行时/" itemprop="url">属性和运行时</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-06T17:30:03+08:00">2018-01-06</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/01/06/属性和运行时/" class="leancloud_visitors" data-flag-title="属性和运行时">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><code>@property</code> 的本质是什么?</li>
<li><code>@property</code> 和运行时有什么关系?</li>
<li><code>@property</code> 一个 demo</li>
</ol>
<h1 id="property-的本质是什么"><a href="#property-的本质是什么" class="headerlink" title="property 的本质是什么"></a><code>property</code> 的本质是什么</h1><p><code>@property</code> 的本质就是成员变量加 <code>getter</code> 和 <code>setter</code> 方法。<code>getter</code> 和 <code>setter</code> 方法是编译器自动为我们生成的。我们也可以尝试去复写 <code>getter</code> 和 <code>setter</code> 方法，在设置成员变量前后增加一些我们想要的业务逻辑。</p>
<p><code>@property</code> 有不同的 <code>attribute</code> : <code>readonly</code>,<code>atomic</code>,<code>nonatomic</code> 等等。编译器会根据不同的 <code>attribute</code> 生成不同的 <code>getter</code> 和 <code>setter</code> 方法</p>
<h1 id="property-和运行时有什么关系"><a href="#property-和运行时有什么关系" class="headerlink" title="property 和运行时有什么关系?"></a><code>property</code> 和运行时有什么关系?</h1><p>来看下运行时系统对 <code>property</code> 相关类型的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Element, typename List, uint32_t FlagMask&gt;</span><br><span class="line">struct property_list_t : entsize_list_tt&lt;property_t, property_list_t, 0&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct property_t *objc_property_t;</span><br><span class="line">struct property_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// Defines a property attribute</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    const char *name;           /**&lt; The name of the attribute */</span><br><span class="line">    const char *value;          /**&lt; The value of the attribute (usually empty) */</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>entsize_list_tt</code> 是通过 <code>C++</code> 的容器类，提供了容器类的基本方法，通过这些基本方法可以管理数据并以遍历的方式获取容器内的数据。<code>property_list_t</code> 是管理 <code>property_t</code> 的一个属性类型。</p>
</blockquote>
<p>了解了基本数据类型之后，我们来讨论几个问题</p>
<h2 id="类是怎么获取到-property-的"><a href="#类是怎么获取到-property-的" class="headerlink" title="类是怎么获取到 @property 的?"></a>类是怎么获取到 <code>@property</code> 的?</h2><p>看源码及注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    .......</span><br><span class="line">    //依次遍历父类</span><br><span class="line">    for ( ; cls; cls = cls-&gt;superclass) &#123;</span><br><span class="line">        //遍历当前类的属性列表</span><br><span class="line">        for (auto&amp; prop : cls-&gt;data()-&gt;properties) &#123;</span><br><span class="line">            //比较字符串如果相等就返回当前的 property</span><br><span class="line">            if (0 == strcmp(name, prop.name)) &#123;  </span><br><span class="line">                return (objc_property_t)&amp;prop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类是怎么增加-property-的"><a href="#类是怎么增加-property-的" class="headerlink" title="类是怎么增加 property 的?"></a>类是怎么增加 <code>property</code> 的?</h2><p>看源码及注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static bool _class_addProperty(Class cls, const char *name, </span><br><span class="line">                   const objc_property_attribute_t *attrs, unsigned int count, </span><br><span class="line">                   bool replace)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return NO;</span><br><span class="line">    if (!name) return NO;</span><br><span class="line">    //先从当前类获取指定名称的 property，如果有而且 caller 不想替换则直接返回</span><br><span class="line">    property_t *prop = class_getProperty(cls, name);</span><br><span class="line">    if (prop  &amp;&amp;  !replace) &#123;</span><br><span class="line">        // already exists, refuse to replace</span><br><span class="line">        return NO;</span><br><span class="line">    &#125; </span><br><span class="line">    //替换当前 property 流程，其实就是把 property 相关的 attributes 进行替换。</span><br><span class="line">    else if (prop) &#123;</span><br><span class="line">        // replace existing</span><br><span class="line">        rwlock_writer_t lock(runtimeLock);</span><br><span class="line">        try_free(prop-&gt;attributes);</span><br><span class="line">        //参数 count 是 attrs 的数量。</span><br><span class="line">        prop-&gt;attributes = copyPropertyAttributeString(attrs, count);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //为新的 property 分配空空间。值得注意的是这里并不是直接分配的 property 而是通过 property_list 进行操作的。</span><br><span class="line">        property_list_t *proplist = (property_list_t *)malloc(sizeof(*proplist));</span><br><span class="line">        proplist-&gt;count = 1;</span><br><span class="line">        proplist-&gt;entsizeAndFlags = sizeof(proplist-&gt;first);</span><br><span class="line">        proplist-&gt;first.name = strdupIfMutable(name);</span><br><span class="line">        proplist-&gt;first.attributes = copyPropertyAttributeString(attrs, count);</span><br><span class="line">        //cls-&gt;data() 拿到 class_rw_t 结构体，结构体里的 properties 是 property_array_t 类型，将新的 property 加入到 property 数组中。</span><br><span class="line">        cls-&gt;data()-&gt;properties.attachLists(&amp;proplist, 1);</span><br><span class="line">        </span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="property-和成员变量是怎么对应起来的？"><a href="#property-和成员变量是怎么对应起来的？" class="headerlink" title="property 和成员变量是怎么对应起来的？"></a><code>property</code> 和成员变量是怎么对应起来的？</h2><p>其实是在编译这一步就做好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface Fan : NSObject</span><br><span class="line">@property (nonatomic,strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>编译 clang -rewrite-objc main.m  之后结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object Fan;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; unsigned long OBJC_IVAR_$_Fan$_name;</span><br><span class="line">struct Fan_IMPL &#123;</span><br><span class="line">	struct NSObject_IMPL NSObject_IVARS;</span><br><span class="line">	NSString *_name;</span><br><span class="line">&#125;;</span><br><span class="line">// @property (atomic,strong) NSString *name;</span><br><span class="line">/* @end */</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>name</code> 属性变成了成员变量 <code>_name</code>。</p>
<h2 id="property-一个-demo"><a href="#property-一个-demo" class="headerlink" title="property 一个 demo"></a><code>property</code> 一个 demo</h2><p>我们之前猜测不同 <code>property</code> 的 <code>attribute</code> 会对编译器造成影响，即生成出来的 <code>setter</code> 和 <code>getter</code> 方法可能不同，比如 <code>atomic</code> 的 <code>setter</code> 方法可能会有锁的实现，于是我补充了上面源码的 <code>getter</code> 和 <code>setter</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static NSString * _I_Fan_name(Fan * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)); &#125;</span><br><span class="line">static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)) = name; &#125;</span><br></pre></td></tr></table></figure>
<p>发现 setter 并没有什么特别的地方… </p>
<p>难道我的验证有问题吗？感觉不应该。我尝试在 demo 中给 <code>name</code> 属性赋值，并打了个符号断点 <code>objc_setProperty_atomic</code> 发现这个方法确实走了，所以 <code>clang</code> 出来的结果应该是有问题的。怎么生成更准确的编译结果我也不清楚。。 </p>
<p><img src="/media/Jietu20180106-185957.png" alt="Jietu20180106-185957"></p>
<p>你也许会问 <code>objc_setProperty_atomic</code> 这个是干什么用的，翻源码到 <code>objc-accessors.mm</code> 这个文件看，可以看到不同的修饰符走了不同的设置属性的方法比如 <code>objc_setProperty_nonatomic</code>，<code>objc_setProperty_atomic</code>，<code>objc_setProperty_atomic_copy</code> 最终他们都调用了 <code>reallySetProperty</code> 这个方法接收了众多参数，根据不同的参数，走了不同的执行流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    id oldValue;</span><br><span class="line">    //这里的 offset 其实就是上一步编译时候确定的。</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot == newValue) return;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //在这里看到 atomic 确实是使用自旋锁来对赋值进行了保护。</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，属性机制的实现不仅靠编译时，运行时也起了很大的作用。</p>
<p>一个思考，能否在运行时候动态添加属性呢？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/29/NSError-最佳实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/29/NSError-最佳实践/" itemprop="url">NSError 最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T17:33:36+08:00">2017-12-29</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/12/29/NSError-最佳实践/" class="leancloud_visitors" data-flag-title="NSError 最佳实践">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NSError-的使用"><a href="#NSError-的使用" class="headerlink" title="NSError 的使用"></a>NSError 的使用</h1><p>访问系统的一些资源的时候，不可避免的会遇到一些错误，我们需要告诉用户或者提醒我们自己遇到什么问题了，方便定位解决。比如移除指定路径文件或者目录的时候，可能文件不存在或者路径有问题等等，我们需要知道究竟为什么不能成功移除，这时候错误信息就很重要了，看下系统是怎么设计这类 API 的。<code>- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error;</code>  </p>
<p>使用类似 API 的时候通常都是传递 <code>NSError * _Nullable *</code> 这种参数，目的是为了延长 error 的初始化时机，让 error 在执行任务的时候再初始化并赋予错误信息。</p>
<p><code>NSError</code> 里面包含的信息很丰富。主要是三个，domain，code 和错误相关的信息。code 是和 domain 相关的。</p>
<p>一个 NSError 的最佳实践是是使用倒序域名方式，这样可以有效避免 NSError 的域名重复。然后根据倒序域名定义错误 code，域名不重复的话，这些 code 可以随意定制，是不会和别的域名下的 code 冲突的。具体看下面 demo </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static NSString *const kUserInfoDomain = @&quot;com.app.userinfo&quot;;</span><br><span class="line"></span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">    AUIUserNotExist = 0,</span><br><span class="line">    AUIUserNameEmpty,</span><br><span class="line">&#125; AUIErrorCode;</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    [self fetchUserInfoWithError:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)fetchUserInfoWithError:(NSError **)error &#123;</span><br><span class="line">    NSDictionary *errInfo =@&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;;</span><br><span class="line">    - (void)btnPressed:(id)sender &#123;</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    [self fetchUserInfoWithError:error];</span><br><span class="line">    NSLog(@&quot;error = %@&quot;,error);</span><br><span class="line">&#125;</span><br><span class="line">//模拟一次错误获取</span><br><span class="line">- (NSString *)fetchUserInfoWithError:(NSError **)error &#123;</span><br><span class="line">    NSDictionary *errInfo = @&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;;</span><br><span class="line">    if(error != NULL)&#123;</span><br><span class="line">        *error = [NSError errorWithDomain:kUserInfoDomain code:AUIUserNotExist userInfo:errInfo];</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上错误处理代码中需要注意的一点就是 error 的判断 <code>if(error != NULL)</code> 加这一行的作用是区分一下两种调用方式</p>
<ol>
<li><code>[self fetchUserInfoWithError:nil];</code></li>
<li><code>NSError *error = nil; [self fetchUserInfoWithError:error];</code></li>
</ol>
<p>如果是像前者一样调用的话，是不会走进这个 <code>if(error != NULL)</code>分支判断，我们没必要为这种情况单独初始化一个 <code>error</code> 实例。</p>
<p>以上，在帮别的同事封装可调用 API 的时候增加必要的 NSError 参数，不仅方便别人，其实也是方便自己。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://nshipster.com/nserror/" target="_blank" rel="noopener">NSError</a><br><a href="https://stackoverflow.com/questions/3276127/best-practice-nserror-domains-and-codes-for-your-own-project-app" target="_blank" rel="noopener">Best Practice - NSError domains and codes for your own project/app</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/28/Bonjour-的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/Bonjour-的理解/" itemprop="url">Bonjour 的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:20:41+08:00">2017-12-28</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/12/28/Bonjour-的理解/" class="leancloud_visitors" data-flag-title="Bonjour 的理解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先提问几个问题</p>
<ol>
<li>什么是 Bonjour？</li>
<li>Bonjour 提供了哪些服务？</li>
<li>Bonjour 的工作机制是什么样子的?</li>
<li>Bonjour 实践</li>
<li>Bonjour 异常分析</li>
</ol>
<h2 id="什么是-Bonjour"><a href="#什么是-Bonjour" class="headerlink" title="什么是 Bonjour"></a>什么是 Bonjour</h2><p>Bonjour 被认为是 0 网络配置，自动发现 PC，普通设备和 IP 网络服务的协议。Bonjour 使用工业标准的 IP 协议，允许一台设备在不需要输入对方 IP 地址或配置 DNS 服务器的情况下自动发现其他设备。特别是 Bonjour 不需要 DHCP 服务器就能使 IP 自动分配，同时无需 DNS 服务器能给 IP 命名，发现服务不需要额外的服务器。同时它是个开放的协议。</p>
<blockquote>
<p>Bonjour, also known as zero-configuration networking, enables automatic discovery of computers, devices, and services on IP networks. Bonjour uses industry standard IP protocols to allow devices to automatically discover each other without the need to enter IP addresses or configure DNS servers. See the Bonjour Protocol Specifications section for more details on the underlying standards.  <a href="https://developer.apple.com/library/content/qa/qa1690/_index.html" target="_blank" rel="noopener">Technical Q&amp;A QA1690 Common QA for Bonjour</a></p>
</blockquote>
<p>一个实际场景是，我的电脑想用使用打印机打印一些资料，Bonjour 可以使打印机自动连接到网络，同时给打印机分配一个 IP 地址，无需任何配置，相同网络下的电脑就可以发现这台打印机，并识别到打印机的 IP 地址，进而建立连接完成打印工作。而且如果你以后地址被动态分配的地址被改变了，Bonjour 还能继续发现新的地址。</p>
<h2 id="Bonjour-提供了哪些服务？"><a href="#Bonjour-提供了哪些服务？" class="headerlink" title="Bonjour 提供了哪些服务？"></a>Bonjour 提供了哪些服务？</h2><ol>
<li>addressing  (向 host 分配 IP 地址)</li>
<li>naming （使用名字代表 host 而不是 IP 地址）</li>
<li>service discovery （自动发现网络中的服务）</li>
</ol>
<h2 id="Bonjour-的工作机制是什么样子的"><a href="#Bonjour-的工作机制是什么样子的" class="headerlink" title="Bonjour 的工作机制是什么样子的?"></a>Bonjour 的工作机制是什么样子的?</h2><p>其实就是说一下上面三个服务的实现机制</p>
<ol>
<li><p>分配 IP 的原理，使用链路本地地址（link-local address） 来解决。</p>
<p>IPv6 协议包含了这种技术。IPv4 是使用另外的实现来达到这个目的，IPv4 的实现原理是在本地链路中随机取一个地址然后测试是不是被占用，如果没有占用则分配其为本地链路地址，否则重新生成并继续测试占用情况。 link-local address 这项技术被绝大多数操作系统实现，如果硬件厂商想要使用 Bonjour 服务也必须在自己的设备里实现这项技术。</p>
<p>对 link-local address 有兴趣的可以看下<a href="https://en.wikipedia.org/wiki/Link-local_address" target="_blank" rel="noopener">它的 wiki</a></p>
</li>
<li><p>在本地网络中解决 IP 到名字的转换的合适方案是使用 <code>Multicast DNS (mDNS)</code>。</p>
<p> 具体实现原理是使用 IP 多播的方式在本地网络中发送 DNS 格式的查询，因为没有一个统一的 DNS 服务器去响应这些查询，所以每个设备或者服务都会去返回自己的 DNS 响应</p>
<p> 可以通过 Bonjour 提供的 API 注册服务，Bonjour 可以自动广播你的服务，任何查询你的服务的请求都会直接被转到正确的 IP 和端口。</p>
<p> 每个服务和设备都应该只有一个名字，这个名字只在当前的网络环境下起作用。这个起名字的过程大概是这样的</p>
<ol>
<li>硬件厂商的设备通过发送带有自己名字（XYZ-LaserPrinter.local）的查询来看下是否当前网络中有一样的，如果有响应那就应该重新起个名字（XYZ-LaserPrinter-1.local 这个名字是在原来名字的基础上继续拼接了一个数字）如果没有则继续之前的操作。直到新的名字的查询没有响应。</li>
<li><p>软件服务是当注册的时候自己起一个名字，如果名字已经被使用了，则 Bonjour 协议会重新给它起一个。</p>
<p>为了向系统表明 local host，macOS 上会在 local host 后面再加个点,比如 <code>Steve.local.</code>。 这部分命名规则比较复杂，这里不赘述了。</p>
</li>
</ol>
</li>
<li><p>通过 DNS 发现服务的过程称为 DNS-SD（DNS Service Discovery）。发现服务这部分的内容还是建立在前面两部的基础上，一个指定服务类型和域名的 mDNS 查询发出去后，有符合条件的服务会返回它们的名字，结果包含了你可选择的一系列服务。和传统的查询服务不同，Bonjour 的服务更类似于询问「我想要的打印服务有没有」，而不是询问每个设备你在运行什么服务（Apple 官方对后者的的说明是，这种询问是以设备为中心的，而前者是以服务为中心）前者相比后者来说对 Client 更加有意义，Client 并不关心其他设备是干嘛的，不断询问只会造成网络压力。</p>
</li>
</ol>
<h2 id="Bonjour-实践"><a href="#Bonjour-实践" class="headerlink" title="Bonjour 实践"></a>Bonjour 实践</h2><p>macOS 系统提供了一个名为 <code>dns-sd</code> 的 Multicast DNS (mDNS) 和 DNS Service Discovery (DNS-SD) 测试工具。</p>
<p>一个例子，我想查看当前网络下能提供打印的服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dns-sd -B _printer</span><br><span class="line">Browsing for _printer._tcp</span><br><span class="line">DATE: ---Thu 28 Dec 2017---</span><br><span class="line">19:45:30.989  ...STARTING...</span><br><span class="line">Timestamp     A/R    Flags  if Domain               Service Type         Instance Name</span><br><span class="line">19:45:30.990  Add        3   5 local.               _printer._tcp.       Brother MFC-8510DN [30055c9332be] (2)</span><br><span class="line">19:45:30.990  Add        2   5 local.               _printer._tcp.       Brother MFC-8510DN [30055c92a583] (2)</span><br></pre></td></tr></table></figure>
<p>我啥都不指定是默认会列出当前提供 http 的服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ dns-sd -B  </span><br><span class="line">Browsing for _http._tcp</span><br><span class="line">DATE: ---Thu 28 Dec 2017---</span><br><span class="line">19:45:49.802  ...STARTING...</span><br><span class="line">Timestamp     A/R    Flags  if Domain               Service Type         Instance Name</span><br><span class="line">19:45:49.803  Add        3   8 local.               _http._tcp.          webserver (5)</span><br><span class="line">19:45:49.804  Add        3   8 local.               _http._tcp.          bxxx</span><br></pre></td></tr></table></figure>
<p>还有一个 Bonjour Browser 的软件(如图)来提供可视化的 Bonjour 服务浏览<br><img src="/media/Jietu20171228-195757.png" alt="Jietu20171228-195757"></p>
<h2 id="为啥有的时候连不上-Bonjour"><a href="#为啥有的时候连不上-Bonjour" class="headerlink" title="为啥有的时候连不上 Bonjour?"></a>为啥有的时候连不上 Bonjour?</h2><ol>
<li>确认路由器开启了组播模式，某些路由器（如思科）默认关闭了「组播模式」，故无法在此网络下搜索到设备.</li>
<li>跟二次认证网络应该也没有关系.</li>
<li>如果是用 iPhone 设备有的时候跟 iOS 系统版本也有关系，参考 <a href="https://stackoverflow.com/questions/38969032/nsnetservicebrowser-can-not-find-service-sometimes" target="_blank" rel="noopener">这里</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.apple.com/library/content/qa/qa1690/_index.html" target="_blank" rel="noopener">Technical Q&amp;A QA1690 Common QA for Bonjour</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/NetServices/Introduction.html" target="_blank" rel="noopener">Bonjour Overview</a><br><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/dns-sd.1.html" target="_blank" rel="noopener">dns-sd</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/21/GCD-的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FanFrank">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanFrank's Site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/21/GCD-的理解/" itemprop="url">GCD 的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-21T18:14:59+08:00">2017-12-21</time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/12/21/GCD-的理解/" class="leancloud_visitors" data-flag-title="GCD 的理解">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="GCD-的理解"><a href="#GCD-的理解" class="headerlink" title="GCD 的理解"></a>GCD 的理解</h1><p><a href="https://apple.github.io/swift-corelibs-libdispatch/" target="_blank" rel="noopener">Grand Central Dispatch</a> (GCD or libdispatch) 为多核上的并行程序执行上的提供了全面支持。GCD 的出现就是系统帮助开发者管理了一些线程方面的工作让开发者将重心放入自己的业务。减轻了开发者的负担，同时也保证了并行执行的高效。</p>
<h2 id="GCD-中线程和队列的关系"><a href="#GCD-中线程和队列的关系" class="headerlink" title="GCD 中线程和队列的关系"></a>GCD 中线程和队列的关系</h2><p>首先要明确一下这俩完全不一样的东西，GCD 的线程管理是系统帮助维护了一个线程池，系统自己会去根据当前负载去决定调用线程池的哪个线程去执行对应队列里的 block 任务。</p>
<p>对于 GCD 本身而言，GCD 本身是需要关注线程的管理，开发者使用 GCD 的时候，可以不那么关心线程的知识，省去自己创建线程，管理线程等一系列繁琐的事情，而是专心使用 GCD 提供的队列的功能。</p>
<p>之前看微博上有 iOS 开发小集的知识点，有一点是说如何「判断是否在主队列运行」。当时特别好奇什么情况下会用到这种判断呢？后来在一个 issue 里发现了这种判断的使用场景。</p>
<p>说明这个场景之前问个问题，主线程和主队列是什么关系？答案：主队列一定位于主线程，但是主线程可能包含别的队列。可以写个 demo 测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">            NSLog(@&quot;hello world&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如图，<br><img src="/media/Jietu20171221-160748.png" alt="Jietu20171221-160748"></p>
<p>而在主线程的主队列里执行的话断点应该是这样的<br><img src="/media/Jietu20171221-160859.png" alt="Jietu20171221-160859"></p>
<p>好，明确了这一点后我们继续说一下什么场景会用到判断当前是否在主队列？即当执行一些 UI 操作的时候我们不仅仅需要判断是否是主线程，还要判断是否是主队列。</p>
<p>诶？难道 UI 操作放到主线程还不够安全吗？是的。<br>相关问题：</p>
<ul>
<li><a href="http://www.openradar.me/24025596" target="_blank" rel="noopener">http://www.openradar.me/24025596</a></li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083" target="_blank" rel="noopener">https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083</a><br>  <img src="/media/Jietu20171221-163735.png" alt="Jietu20171221-163735"></li>
</ul>
<p>我们之前被 Apple 教育：UI 操作要放到主线程中执行，但是现在发现放到主线程中执行的时候，因为 Apple 的不靠谱，我们只能自己动手去做个判断。判断主线程的方式就和 iOS 知识小集里的说的一样使用如下代码，通过 key/value 的方式来设置和获取指定的 queue.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BOOL RCTIsMainQueue()</span><br><span class="line">&#123;</span><br><span class="line">  static void *mainQueueKey = &amp;mainQueueKey;</span><br><span class="line">  static dispatch_once_t onceToken;</span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    dispatch_queue_set_specific(dispatch_get_main_queue(),</span><br><span class="line">                                mainQueueKey, mainQueueKey, NULL);</span><br><span class="line">  &#125;);</span><br><span class="line">  return dispatch_get_specific(mainQueueKey) == mainQueueKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充一点：上面有个 demo 没有说明的是 <code>dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ xxx }); }</code> 这个方法为什么会在主线程执行呢？可以看下 <code>dispatch_sync</code> 的官方 API 说明</p>
<blockquote>
<p>As an optimization, this function invokes the block on the current thread when possible.</p>
</blockquote>
<h2 id="GCD-的-API-设计"><a href="#GCD-的-API-设计" class="headerlink" title="GCD 的 API 设计"></a>GCD 的 API 设计</h2><p>GCD 里的 API 设计打都是为了保证多线程下任务的执行顺序。GCD 队列(FIFO)这个概念本身也是为了连续执行 block 而生。这里不打算详细说明具体 API 的使用方法。比如 <code>dispatch_group</code> 相关的 API 是封装了一组任务保证该组任务执行完之后执行某个特定任务，<code>dispatch_semaphore</code> 相关的 API 是等某个任务执行完了再执行某个别的任务。特别说明一下 <code>dispatch_semaphore</code> 这个 API 非常好用，我们经常在业务中比如执行某个网络业务的时候，顺序执行 N 个网络请求来保证业务执行成功，我们会在一个网络请求的异步回调里继续调用另外一个请求的方法，通常的做法是不断的嵌套调用函数，这样是能解决问题，但是不够优雅。但是有了 <code>dispatch_semaphore</code> 我们就可以新的方式去执行这种操作，上个 demo 模拟一下顺序执行一系列异步操作的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">            NSLog(@&quot;first block&quot;);</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">            NSLog(@&quot;second block&quot;);</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">        &#125;);</span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">        NSLog(@&quot;this is end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有 <code>dispatch_barrier_async</code> 控制队列中哪些 block 先执行，哪些后执行。在某种程度上和 <code>dispatch_group</code> 挺像。还有一些是通过控制 queue 的优先级来控制任务的执行顺序的，参考 <code>dispatch_set_target_queue</code> 相关用法。</p>
<p>以上都是我们经常用的 gcd 的方法，通过 GCD 提供的 API 来控制队列中 block 的执行。当然 GCD 还提供了很多别的功能，比如通过 dispatch_source_create 创建定时器等等这里就不列举了。</p>
<p>总结：理清楚线程，队列还有 block 三者的关系就能对 GCD 的使用游刃有余。</p>
<p>参考地址</p>
<ul>
<li><a href="https://developer.apple.com/documentation/dispatch" target="_blank" rel="noopener">https://developer.apple.com/documentation/dispatch</a></li>
<li><a href="http://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/" target="_blank" rel="noopener">http://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/</a></li>
<li><a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/" target="_blank" rel="noopener">http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/</a></li>
<li><a href="https://github.com/southpeak/iOS-tech-set/blob/master/2017/10.md#判断是否在主队列运行" target="_blank" rel="noopener">https://github.com/southpeak/iOS-tech-set/blob/master/2017/10.md#判断是否在主队列运行</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="FanFrank" />
            
              <p class="site-author-name" itemprop="name">FanFrank</p>
              <p class="site-description motion-element" itemprop="description">iOS & macOS Develop</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yourname" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/fanxiushan/" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FanFrank</span>

  

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("fnYkA3dAQO9X0BxvP41VcLiK-gzGzoHsz", "JNMemtBzWyj0aq2zz5qKNGTb");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
