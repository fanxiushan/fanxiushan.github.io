<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AutoreleasePool 理解]]></title>
    <url>%2F2018%2F01%2F15%2FAutoreleasePool-%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[从一些问题开始 什么是 AutoreleasePool ? 说明一下 NSAutoreleasePool 具体机制? ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？ AutoreleasePool 的实现机制? AutoreleasePool 和 NSRunloop 有什么关系？ AutoreleasePool 和线程有什么关系? 什么时候需要我们手动创建 AutoreleasePool ? 什么是 AutoreleasePool ? 如何理解 NSAutoreleasePool?NSAutoreleasePool 对象的官方说明是一个支持 Cocoa 引用计数式内存管理的一个对象。 当池子排掉的时候向池子内存储的对象发送 release 消息。 An object that supports Cocoa’s reference-counted memory management system.An autorelease pool stores objects that are sent a release message when the pool itself is drained. 具体机制说明：在引用计数式的内存管理中，NSAutoreleasePool 对象包含了收到了 _autorelease 消息的对象，这些 autorelease 对象（我们称被标记了 __autorelease 的对象为 autorelease 对象）的生命周期被延长到了这个 NSAutoreleasePool drain 的时候。也可以这么说 autorelease 和 release 的区别仅仅是 autorelease 是延时释放(即等待 AutoreleasePool drain) 而 release 是立即释放。 感觉说到这儿，其实我们可以说 NSAutoreleasePool 就是一个帮助我们管理内存的一个工具。 其实不光是我们自己可以手动创建 NSAutoreleasePool 对象，系统也帮我们维护了一个 NSAutoreleasePool 对象，在 runloop 迭代中不断 Push 和 Pop，从而不会堆积过多的 autorelease 对象引起内存疯长。你可能会好奇，哪会有那么多 autorelease 对象？举个例子来看一下： 123456- (void)viewDidLoad &#123; [super viewDidLoad]; // str 其实是一个 autorelease 对象 NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;]; reference = str;&#125; 题外话：为啥 str 是一个 autorelease 对象呢？这个就需要知道下内存管理的知识了，使用 alloc,new,copy和mutableCopy这些关键字生成的对象是自己持有，反之不是（参考 Memory Management Policy）。使用 stringWithFormat: 类方法生成的 str 没有持有它的对象，只能通过 autorelease 这种方式来延长它的生命周期。具体 autorelease 的时机是在 stringWithFormat 内部做的。 Cocoa 的 Framework 里大量生成了 autorelease 的对象，所以官方说明里 Cocoa 代码执行是预期在一个 autorelease 环境中。 ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？没啥根本区别，只是写法稍有不同。看两个 ARC 和 MRC 时代 autorelease 的两个经典写法。 MRC 的 case: 1234NSAutoreleasePool *pool = [[NSAutorelease alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];[pool drain]; ARC 的 case(注:其实 MRC 也可以这么写): 1234@autoreleasepool &#123; //_autorelease 为所有权修饰符。 id _autorelease obj = [[NSObject alloc] init];&#125; ARC 中的几点变化： ARC 中是不能使用 autorelease 方法，也不能使用 NSAutoreleasePool 类。 ARC 系统提供了 @autoreleasepool 块来替代 NSAutoreleasePool 对象的生成持有以及废弃的功能。 通过将对象赋值给附加了 __autoreleaseing 修饰符变量来替代调用 autorelease 方法。即 12id obj = [[NSObject alloc] init];[obj autorelease]; 等价于 1id _autorelease obj = [[NSObject alloc] init]; 一般我们不会显式的去使用 __autorelease 修饰符，因为ARC 下编译器帮我们做了一些工作，即编译器会检查方法是否以 alloc/new/copy/mutableCopy 开始，如果不是的话将返回的值对象注册到 autoreleasePool。 不需要显式地写 __autorelease 的几种场景 自动释放池随意生成对象，不需要显式地添加 autorelease。 1234@autoreleasepool &#123; //默认的 strong 修饰符会自动处理这种情况. id obj = [[NSObject alloc] init]; &#125; 函数返回值的场景 1234+ (NSArray *)array &#123; id obj = [[NSMutableArray alloc] init]; return obj;&#125; 在 MRC 时代，obj 是需要被发送 autorelease 方法的，ARC 时代不需要这么做，这个对象作为函数的返回值会自动被注册到 autoreleasePool 中 访问 weak 变量的时肯定会涉及到 autoreleasePool 因为 weak 对对象是弱引用，对象随时会被释放，但是使用 autoreleasePool 会延时释放，保证 weak 访问过程中不会出现对象被释放这种状况。 NSObject **obj 其实就是 NSObject *_autorelease * obj。 因为我们不持有通过引用返回的对象。这种情况只能是 autorelease。 AutoreleasePool 的实现机制?分析过程对以下代码所在文件执行 clang -rewrite-objc xx.m 重写命令，可以看到 OC 对应的 C++ 的源码。 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 转换后的 C++ 代码。 123456int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0); &#125; return 0;&#125; 可以看到 @autoreleasepool 被转换为一个名为 __AtAutoreleasePool 的数据结构。 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; main 函数其实可以理解为 12345678int main(int argc, const char * argv[]) &#123; &#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush(); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; 具体 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的实现在 runtime 源码 NSObject.mm中可以找到。 1234567void * objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; AutoreleasePoolPage 的介绍这里涉及到了 AutoreleasePoolPage 这个数据结构，接下来就看下 AutoreleasePoolPage 这个数据结构是啥样的？AutoreleasePoolPage 是个 C++ 的类 123456789class AutoreleasePoolPage &#123; magic_t const magic; //magic 用于对当前 AutoreleasePoolPage 完整性的校验 id *next; //当前 autoreleasePoolPage 最上层的对象的指针。 pthread_t const thread; //thread 保存了当前页所在的线程 AutoreleasePoolPage * const parent;//指向上一个 AutoreleasePoolPage 对象. AutoreleasePoolPage *child; //指向下一个 AutoreleasePoolPage 对象. uint32_t const depth; uint32_t hiwat;&#125; 关于 AutoreleasePoolPage 的说明 可以看到其实并没有一个整体的自动释放池对象，自动释放池是由一个双向链表构成。当一个 AutoreleasePoolPage 的空间被占满之后继续创建新的 AutoreleasePoolPage 对象。 1234567891011121314151617181920//child 指向的是下一个 AutoreleasePoolPage 对象的指针// 这个方法是当前 page 如果满的情况下创建新的 page.id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); .... return page-&gt;add(obj);&#125;// 初始化 pool 的方法 在这个里面对 parent 和 child 进行了赋值.AutoreleasePoolPage(AutoreleasePoolPage *newParent) : magic(), next(begin()), thread(pthread_self()), parent(newParent), child(nil), depth(parent ? 1+parent-&gt;depth : 0), hiwat(parent ? parent-&gt;hiwat : 0) &#123; if (parent) &#123; parent-&gt;child = this; &#125;&#125; 每个 AutoreleasePoolPage 对象都存储着当前的线程 id 参考上面的 AutoreleasePoolPage 的初始化方法。使用 pthread_self() 拿到当前的线程 id 然后保存到 thread 成员变量里。 AutoreleasePoolPage 的内存大小是 4096 个字节。是 80386 机器上的每页的字节数。 1234//初始化 AutoreleasePoolPage 的方法,size 是个宏定义的 4096static void * operator new(size_t size) &#123; return malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);&#125; AutoreleasePoolPage 存储 autorelease 对象是通过自己内部的 next 指针去实现。从实现上可以看到 AutoreleasePoolPage 还是从低内存地址向高内存地址增长。 12345id *add(id obj) &#123; id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj; return ret;&#125; 由此大致能得到 AutoreleasePoolPage 的内存结构如图（来自 Sunny 大神博客） autorelease 消息调用栈了解了这个数据结构后看下 autorelease 消息的调用栈。 我们看下 AutoreleasePoolPage 中 autorelease 方法实现其实就是将 autorelease 对象存储到 AutoreleasePoolPage 的过程。下面是大致实现的代码 12345678910111213141516171819202122static inline id autorelease(id obj) &#123; ... id *dest __unused = autoreleaseFast(obj); ... return obj;&#125;//这个是将 obj 存入 AutoreleasePoolPage 的方法。static inline id *autoreleaseFast(id obj) &#123; //hotPage 应该是去 TLS(线程本地存储) 中获取 AutoreleasePoolPage。 //如果是程序刚启动的话，这儿肯定拿到的空。 AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; // AutoreleasePoolPage 不满的时候直接往进加 return page-&gt;add(obj); //绝大多数情况我们走的都是这个分支。 &#125; else if (page) &#123; // AutoreleasePoolPage 满了，则创建新的 page，将 obj 放到新的 page 里去. return autoreleaseFullPage(obj, page); &#125; else &#123; // 创建新的 page. return autoreleaseNoPage(obj); &#125;&#125; autorelease pop 消息对应 push 的是 pop，pop 即为将存储到 AutoreleasePoolPage 的对象释放对应原型为 123void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 注意的是这里并没有直接传入对象，而是传入了一个 ctxt 的指针，根据内部实现来看，自动释放池根据 ctxt 拿到它当前所在的 AutoreleasePoolPage ，然后将 AutoreleasePoolPage 的 ctxt 的位置开始到到最新的 AutoreleasePoolPage 存储的 autorelease 对象全部释放。即我们可以理解为自动释放池代码块儿开始的时候会在 AutoreleasePoolPage 进行一个占位，然后将后续的 autorelease 对象都放到占位后，这样就能确定当前自动释放池块儿里的对象是从哪到哪，理解了这一点也就能理解 autorelease 的嵌套实现了。 1234567891011121314151617181920212223242526272829static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; .. page = pageForPointer(token); //拿到 token 所在的 AutoreleasePoolPage stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); //一直释放对象到 token 的位置.&#125;//一直释放对象的函数void releaseUntil(id *stop) &#123; while (this-&gt;next != stop) &#123; AutoreleasePoolPage *page = hotPage(); //拿到当前的 page. id obj = *--page-&gt;next; memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); if (obj != POOL_BOUNDARY) &#123; objc_release(obj); //取出对象不断发送 relesse 消息.. &#125; &#125; setHotPage(this);&#125; AutoreleasePool 和 NSRunloop 有什么关系？先来个实例看下 Runloop 是什么东西。建一个普通的 Single View App 工程。点击按钮然后在按钮点击事件里打印 12345678910- (void)btnPressed:(id)sender &#123; NSRunLoop *runloop = [NSRunLoop currentRunLoop]; //在这里打断点然后 po runloop 得到下面结果。（省略大部分无关内容）&#125;(lldb) po runloop common mode items = &lt;CFBasicHash 0x604000249360 [0x110875bb0]&gt; 1 : &lt;CFRunLoopObserver 0x6040001370c0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), .... ...... 4 : &lt;CFRunLoopObserver 0x604000136ee0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), .... 注意看上面的 activities,它对应的定义是这里 12345678910/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; 可以确定 Autorelease 机制在 Runloop 进入和退出(和休眠前触发) CommonMode 的时候进行观察，当 Runloop 运行到指定的时机的时候回触发 _wrapRunLoopWithAutoreleasePoolHandler 回调方法。 _wrapRunLoopWithAutoreleasePoolHandler 这个方法的实现其实我们并不清楚，网上没有找到对应的实现，不过我们可以打下符号断点来看看有没有线索。果然应用刚启动就执行了这些方法。看左侧的调用栈确实是从 Observer 的回调执行过来的。下面两个是我们熟悉的 Pop 和 Push 操作，基本上可以确认，Autorelease 机制是在进入 Runloop 的时候就创建了一个新的 AutoreleasePoolPage。退出或者休眠的的时候回收 AutoreleasePoolPage。 AutoreleasePool 和线程有什么关系?Cocoa 应用程序里的每个线程会自动维护一个释放池，就是通过上面 Runloop 的方式。但是如果没有 Runloop 呢？ 之前看到有人问了一个问题：子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？答案是不会。 具体 demo 如下 参考 123456789- (void)viewDidLoad &#123; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil]; [thread start];&#125;-(void)test &#123; MyClass *my = [[[MyClass alloc] init] autorelease]; NSLog(@&quot;%@&quot;,[my description]);&#125; 最后的结果是 MyClass 实例被释放掉了。理论上来说子线程并没有 Runloop 也就没有自动释放池观察 Runloop 状态，也就不会自动去执行对应的 autorelease 的方法。根据引用计数来看的话，autorelease 方法和 AutoreleasePool 在一起才能发生作用，而目前又没有 AutoreleasePool，所以那是咋回事？ 事实上即使没有 Runloop，线程和 AutoreleasePool 也能直接发生关系。向某个对象发送 autorelease 消息后，会自动创建 AutoreleasePoolPage。autorelease 消息的调用栈可以参考上面的说明。最终 TLS(线程本地存储)会存储 AutoreleasePoolPage 对象。大致代码如下： 12AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);tls_set_direct(key, (void *)page); 这里具体实现比较复杂，而且根据是这种情况并不适用于主线程。可以看 StackOverflow 的相关回答。这里不具体贴了。 我个人觉得为了程序可读性还有稳定性，还是加上 @autoreleasepool 更妥。说稳定性是因为不能过度依赖于 runtime 的底层机制，万一 runtime 底层机制后续有变化可能会造成程序的异常。 什么时候需要我们手动创建 AutoreleasePool? 如果工程只是 Foundation-Only(命令行那种),而不是 Cocoa application。那需要手动创建自动释放池。 如果程序存活时间长，而且可能生成大量临时对象（比如循环里创建了一堆）那应该在合适地方（比如循环里）手动释放池，降低内存峰值（不用担心嵌套使用 AutoreleasePool 的问题） 你创建了一个新线程，需要创建自动释放池。这个跟我们上面一小节说的是略微冲突，但是在上面已经说过了，添加 AutoreleasePool 是最佳实践。 参考地址黑幕背后的Autorelease自动释放池的前世今生 —- 深入解析 autoreleasepool深入理解RunLoopiOS中autorelease的那些事儿Transitioning to ARC Release NotesNSAutoreleasePoolUsing Autorelease Pool BlocksiOS ARC 内存管理要点各个线程 Autorelease 对象的内存管理]]></content>
  </entry>
  <entry>
    <title><![CDATA[属性自动合成]]></title>
    <url>%2F2018%2F01%2F11%2F%E5%B1%9E%E6%80%A7%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[Clang 编译器提供了 OC 自动合成属性的功能。如果一个属性没有被声明为 @dynamic 或者开发者没有自定制它的 getter 或者 setter 方法实现。那 Clang 会自动为你合成 getter 和 setter 方法的实现同时生成对应的成员变量，检查 Clang 编译器是否支持自动合成使用__has_feature(objc_default_synthesize_properties) 这个条件判断。举例 12345#if __has_feature(objc_default_synthesize_properties) //support autosynthesis#else //not support#endif 当编译器不能自动为你合成属性的时候，需要开发者手动进行。其实也可以换个说法，什么时候需要开发者手动 @synthesize。 举个例子，开发中偶尔会遇到这种报错的情况： 12345678910@property (nonatomic,strong) NSString *name;.....@implementation- (void)setName:(NSString *)name &#123; _name = name; #编译错误:Use of undeclared identifier &apos;_name&apos;; did you mean &apos;name&apos;?&#125;- (NSString *)name &#123; return @&quot;&quot;;&#125;@end 这个时候需要我们手动的添加一行代码 @synthesize name = _name; 编译错误就会消失。或者你把编译错误的那行去掉，然后使用命令 clang -rewrite-objc main.m 编译原文件，发现生成的对象结构体中并没有 name 对应的成员变量。 接下来就是总结什么场景下需要我们手动添加 @synthesize。 就是我们上面 demo 展示的这种可读写的属性，但是开发者自定义了 getter 和 setter 方法，注意必须是同时复写，如果只复写 setter 或者 getter 的话是不会出现问题的。这也是 clang 编译器不支持的自动合成的场景。 只读属性，开发者自定义了 getter 方法。 @dynamic 修饰的属性，@dynamic 本质是告诉编译器 setter 与 getter 方法由开发者自己定义，不自动合成。 在协议 @protocol 中声明的属性。 在类别 @category 中声明的属性。这是因为类别不支持自动添加成员变量，需要手动进行引用关联。 如果你复写了父类的属性，你也需要显式地添加 @synthesize 如果你想手动修改成员变量名的话，可以使用 @synthesize 修改，比如默认成员变量名是 _name 使用 @synthesize name = yname; 修改成员变量名为 yname，但是不建议这么做。 #参考地址#When should I use @synthesize explicitly?Objective-C Autosynthesis of Properties@synthesize 和 @dynamic 的作用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[属性 attribute 总结]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%B1%9E%E6%80%A7-attribute-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[@property 和 attribute 的中文翻译都是属性，所以本文就只用英文做区分了。property 的不同 attribute 大致包含下面这些 strong //default weak copy assign //default unsafe_unretained atomic &amp; nonatomic //default atomic readonly &amp; readwrite //default readwrite 接下来依次说一下这些 attribute 的用处，使用方法还有使用时的可能注意事项 strongstrong 是 ARC 引入的方便内存管理的一种 attribute，跟 MRC 属性中的retain 效果基本是一样的。区别在于编译器遇到 strong 修饰的变量的时候会自动为其在合适的地方插入一条 release 语句。相同的地方就是为了强引用属性。强引用的意思就是当前对象持有自己的属性对象，如果当前对象不释放的话这个属性也不会被释放，而当对象释放的时候，ARC 也会自动为我们处理属性的释放，不需要开发者关心。strong 是我们最常用的一个 attribute。 几个说明： strong attribute 和变量前的修饰符 __strong 在 ARC 里的作用是一样的。只不过一个修饰属性一个修饰变量而已。参考 Property declarations strong 不能用来修饰非对象。否则编译器会报错 1Property with retain(or strong) attribute must be object type 一般如果某个属性前面不需要显式地写出 strong 编译器会自动认为这是 strong 类型的属性。 strong 修饰符会自动处理以下两种 case,而引用计数不会出现异常。 123456&#123;// 自己生成并持有对象 id __strong obj = [[NSObject alloc] init];&#125;&#123; // 非自己生成并持有对象. id __strong obj = [NSMutableArray array];&#125; objc_storeStrong 方法的说明，当向一个 __strong 修饰符修饰的对象赋值的时候跟执行下面代码是一样的效果。说白了就是执行了 objc_storeStrong 的方法。 12345678//Precondition: object is a valid pointer to a __strong object which //is adequately aligned for a pointer. value is null or a pointer to a valid object.void objc_storeStrong(id *object, id value) &#123; id oldValue = *object; value = [value retain]; *object = value; [oldValue release];&#125; 值得说明的是 FRObject *obj = [FRObject frobj]; 和 FRObject *obj = temp; 这两句代码编译器的处理是不一样的。第二句会执行如上 objc_storeStrong 的方法，但是第一句不会。我个人理解原因是 obj 初始化的时候并没有 oldValue，所以没有必要这么做。 weakweak 也是 ARC 引入的方便内存管理的一种 attribute，跟 assign 效果基本是一样的。区别在于在对象被释放的时候，weak 机制会自动将对象置为 nil,保证后续访问这个对象不会因为野指针闪退。 真正引入 weak 的原因是 weak 能解决引起内存泄露的循环引用问题。 几个说明： weak 和 strong 一样只能用来修饰对象。 weak attribute 和变量前的修饰符 __weak 在 ARC 里的作用是一样的。 copycopy 要求它修饰的属性必须实现 NSCopy 协议。本质上，当 copy 修饰的属性被赋值的时候，新值会收到一个 copyWithZone 方法，旧的值会被 release。 1234567//clang 编译后的源码 static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Fan, _name), (id)name, 1, 1); &#125; //runtime 里的对应方法 void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) //reallySetProperty 有对应 copy 属性的具体实现. copy 的使用场景通常是你希望属性在赋值后一直保持值不变，而不是跟着它指向的对象一直变。讨论比较多的是 NSString 是应该用 copy 还是用 strong 去修饰 1234567891011@property (atomic) NSString *name;NSMutableString *nameString = [NSMutableString stringWithString:@&quot;John&quot;];Fan *fan = [[Fan alloc] init];fan.name = nameString;NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);[nameString appendString:@&quot;ny&quot;];NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);//输出结果如下2018-01-11 20:35:18.763988+0800 TTTTT[71790:3384299] fan.name = John 0x10051e9c02018-01-11 20:35:18.764449+0800 TTTTT[71790:3384299] fan.name = Johnny 0x10051e9c0 可以看到 fan.name 在没有显式修改的时候被改掉了，这种情况出现在 NSString 指针子类 NSMutableString 的情况下，而 NSMutablString 的修改不会对本身地址产生影响。使用 copy 可以避免。个人觉得使用 copy 还是 strong 还是根据实际情况，如果出了问题知道为什么就好了。 assign值得注意的是 MRC 时代和 ARC 时代的 assign 使用多少有点区别的。MRC 的 assign 是可以修饰对象还有普通基本类型，因为你根本也没得选。但是 ARC 下虽然 assgin 也都可以修饰基本类型和对象，但是通常修饰对象的话不会用 assign ，因为缺少了 weak 修饰变量被释放时候置为 nil 的特性，很有可能出现内存问题。所以我们现在用 assign 修饰基本类型就好了，需要弱引用的时候用 weak 用来修饰对象。规则也比较明确。 unsafe_unretainedunsafe_unretained 其实就是阉割版本的 weak 实现，它缺少正是对象释放时候置为 nil 的特性。但是 unsafe_unretained 还能修饰基本数据类型，weak 不行。 看起来，我们使用 weak 就好了为啥要用 unsafe_unretained 这个属性呢。答案是因为 __weak 只支持 iOS 5.0 和 OS X Mountain Lion 作为部署版本，如果是想要兼容更低的支持 ARC 的版本，比如你想部署回 iOS 4.0 和 OS X Snow Leopark 就不得不使用 unsafe_unretained。 还有一种说法是 weak 底层实现比较繁琐消耗性能，我认为与 weak 带来的好处相比，这点消耗可以忽略。 atomic &amp; nonatomicatomic 和 nonatomic 区别在于向属性对应成员变量赋值的时候是否为原子写入，即能不能够保证安全写入，从这一点上 atomic 确实是安全的。但是 atomic 并非是线程安全的，因为 atomic 控制的粒度太细了。 举个例子，A 线程向属性写入一个值，A 线程后续再次读这个值之前，可能 B 线程也向同样的属性里写入另外一个值，这样 A 线程读取的时候并非读到的是自己刚写入的值而是一个预期之外的值。 从这一点上看 atomic 似乎用处不是很大，同时 atomic 底层是用锁实现的，频繁写入会影响性能。个人认为最好的实践是，使用 nonatomic 然后自己去处理线程相关的东西。 几个说明： atomic 是默认属性。比如 @property NSString *name; 这种属性默认就是 atomic 修饰的。 atomic 的底层实现里，赋值和读取值都有锁的保护，而且使用的都是一个锁。 atomic 不允许开发者自己复写其 getter 方法，强制复写会得到一个警告。 1#Writable atomic property &apos;name&apos; cannot pair a synthesized setter with a user defined getter readonly &amp; readwritereadonly 和 readwrite 其实就是编译器级别帮你做了只读和读写的处理。readonly 是告诉编译器不用生成 setter 方法，同时如果你对这个 readonly 属性赋值的时候编译器会报错 1#Assignment to readonly property readwrite 是默认的属性，它会告诉编译器自动生成 setter 和 getter 方法。开发者可以随意复写这两个方法来满足自己的时机情况。 补充关于自动合成属性的声明。Clang 提供了对已声明属性自动合成的支持。这个功能提供了没有被 @dynamic 修饰的属性的 getter 和 setter 方法，而不用用户手动添加。 Clang provides support for autosynthesis of declared properties. Using this feature, clang provides default synthesis of those properties not declared @dynamic and not having user provided backing getter and setter methods. __has_feature(objc_default_synthesize_properties) checks for availability of this feature in version of clang being used. 一些面试时常遇到的 QAQ: assign, weak 和 unsafe_unretained 的区别?A: assign 和 unsafe_unretained 是等价的。weak 和它们区别是在对象释放的时候增加了将其置为 nil 的功能。 Q: atomic 是不是线程安全的？A: 参考上面说明. Q: @property NSString *name; 这个属性的 attribute 是?A: strong,atomic,readwrite. 参考Transitioning to ARC Release NotesObjective-C Automatic Reference Counting (ARC)property属性修饰符总结Objective-C: Property Attribute Reference GuideEncapsulating DataVariable property attributes or Modifiers in iOS]]></content>
  </entry>
  <entry>
    <title><![CDATA[属性和运行时]]></title>
    <url>%2F2018%2F01%2F06%2F%E5%B1%9E%E6%80%A7%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%2F</url>
    <content type="text"><![CDATA[@property 的本质是什么? @property 和运行时有什么关系? @property 一个 demo property 的本质是什么@property 的本质就是成员变量加 getter 和 setter 方法。getter 和 setter 方法是编译器自动为我们生成的。我们也可以尝试去复写 getter 和 setter 方法，在设置成员变量前后增加一些我们想要的业务逻辑。 @property 有不同的 attribute : readonly,atomic,nonatomic 等等。编译器会根据不同的 attribute 生成不同的 getter 和 setter 方法 property 和运行时有什么关系?来看下运行时系统对 property 相关类型的定义 123456789101112131415template &lt;typename Element, typename List, uint32_t FlagMask&gt;struct property_list_t : entsize_list_tt&lt;property_t, property_list_t, 0&gt; &#123;&#125;;typedef struct property_t *objc_property_t;struct property_t &#123; const char *name; const char *attributes;&#125;;/// Defines a property attributetypedef struct &#123; const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; entsize_list_tt 是通过 C++ 的容器类，提供了容器类的基本方法，通过这些基本方法可以管理数据并以遍历的方式获取容器内的数据。property_list_t 是管理 property_t 的一个属性类型。 了解了基本数据类型之后，我们来讨论几个问题 类是怎么获取到 @property 的?看源码及注释 12345678910111213141516objc_property_t class_getProperty(Class cls, const char *name)&#123; ....... //依次遍历父类 for ( ; cls; cls = cls-&gt;superclass) &#123; //遍历当前类的属性列表 for (auto&amp; prop : cls-&gt;data()-&gt;properties) &#123; //比较字符串如果相等就返回当前的 property if (0 == strcmp(name, prop.name)) &#123; return (objc_property_t)&amp;prop; &#125; &#125; &#125; return nil;&#125; 类是怎么增加 property 的?看源码及注释 12345678910111213141516171819202122232425262728293031323334static bool _class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int count, bool replace)&#123; if (!cls) return NO; if (!name) return NO; //先从当前类获取指定名称的 property，如果有而且 caller 不想替换则直接返回 property_t *prop = class_getProperty(cls, name); if (prop &amp;&amp; !replace) &#123; // already exists, refuse to replace return NO; &#125; //替换当前 property 流程，其实就是把 property 相关的 attributes 进行替换。 else if (prop) &#123; // replace existing rwlock_writer_t lock(runtimeLock); try_free(prop-&gt;attributes); //参数 count 是 attrs 的数量。 prop-&gt;attributes = copyPropertyAttributeString(attrs, count); return YES; &#125; else &#123; //为新的 property 分配空空间。值得注意的是这里并不是直接分配的 property 而是通过 property_list 进行操作的。 property_list_t *proplist = (property_list_t *)malloc(sizeof(*proplist)); proplist-&gt;count = 1; proplist-&gt;entsizeAndFlags = sizeof(proplist-&gt;first); proplist-&gt;first.name = strdupIfMutable(name); proplist-&gt;first.attributes = copyPropertyAttributeString(attrs, count); //cls-&gt;data() 拿到 class_rw_t 结构体，结构体里的 properties 是 property_array_t 类型，将新的 property 加入到 property 数组中。 cls-&gt;data()-&gt;properties.attachLists(&amp;proplist, 1); return YES; &#125;&#125; property 和成员变量是怎么对应起来的？其实是在编译这一步就做好了。 1234@interface Fan : NSObject@property (nonatomic,strong) NSString *name;@end..... 编译 clang -rewrite-objc main.m 之后结果 12345678910typedef struct objc_object Fan;extern &quot;C&quot; unsigned long OBJC_IVAR_$_Fan$_name;struct Fan_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; NSString *_name;&#125;;// @property (atomic,strong) NSString *name;/* @end */... 可以看到 name 属性变成了成员变量 _name。 property 一个 demo我们之前猜测不同 property 的 attribute 会对编译器造成影响，即生成出来的 setter 和 getter 方法可能不同，比如 atomic 的 setter 方法可能会有锁的实现，于是我补充了上面源码的 getter 和 setter 实现： 12static NSString * _I_Fan_name(Fan * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)); &#125;static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)) = name; &#125; 发现 setter 并没有什么特别的地方… 难道我的验证有问题吗？感觉不应该。我尝试在 demo 中给 name 属性赋值，并打了个符号断点 objc_setProperty_atomic 发现这个方法确实走了，所以 clang 出来的结果应该是有问题的。怎么生成更准确的编译结果我也不清楚。。 你也许会问 objc_setProperty_atomic 这个是干什么用的，翻源码到 objc-accessors.mm 这个文件看，可以看到不同的修饰符走了不同的设置属性的方法比如 objc_setProperty_nonatomic，objc_setProperty_atomic，objc_setProperty_atomic_copy 最终他们都调用了 reallySetProperty 这个方法接收了众多参数，根据不同的参数，走了不同的执行流。 123456789101112131415161718192021222324252627282930static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; //这里的 offset 其实就是上一步编译时候确定的。 id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; //在这里看到 atomic 确实是使用自旋锁来对赋值进行了保护。 spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125; 可以看到，属性机制的实现不仅靠编译时，运行时也起了很大的作用。 一个思考，能否在运行时候动态添加属性呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[NSError 最佳实践]]></title>
    <url>%2F2017%2F12%2F29%2FNSError-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[NSError 的使用访问系统的一些资源的时候，不可避免的会遇到一些错误，我们需要告诉用户或者提醒我们自己遇到什么问题了，方便定位解决。比如移除指定路径文件或者目录的时候，可能文件不存在或者路径有问题等等，我们需要知道究竟为什么不能成功移除，这时候错误信息就很重要了，看下系统是怎么设计这类 API 的。- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error; 使用类似 API 的时候通常都是传递 NSError * _Nullable * 这种参数，目的是为了延长 error 的初始化时机，让 error 在执行任务的时候再初始化并赋予错误信息。 NSError 里面包含的信息很丰富。主要是三个，domain，code 和错误相关的信息。code 是和 domain 相关的。 一个 NSError 的最佳实践是是使用倒序域名方式，这样可以有效避免 NSError 的域名重复。然后根据倒序域名定义错误 code，域名不重复的话，这些 code 可以随意定制，是不会和别的域名下的 code 冲突的。具体看下面 demo 1234567891011121314151617181920212223242526272829static NSString *const kUserInfoDomain = @&quot;com.app.userinfo&quot;;typedef enum : NSUInteger &#123; AUIUserNotExist = 0, AUIUserNameEmpty,&#125; AUIErrorCode;@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self fetchUserInfoWithError:&amp;error];&#125;- (NSString *)fetchUserInfoWithError:(NSError **)error &#123; NSDictionary *errInfo =@&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;; - (void)btnPressed:(id)sender &#123; NSError *error = nil; [self fetchUserInfoWithError:error]; NSLog(@&quot;error = %@&quot;,error);&#125;//模拟一次错误获取- (NSString *)fetchUserInfoWithError:(NSError **)error &#123; NSDictionary *errInfo = @&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;; if(error != NULL)&#123; *error = [NSError errorWithDomain:kUserInfoDomain code:AUIUserNotExist userInfo:errInfo]; &#125; return nil;&#125; 以上错误处理代码中需要注意的一点就是 error 的判断 if(error != NULL) 加这一行的作用是区分一下两种调用方式 [self fetchUserInfoWithError:nil]; NSError *error = nil; [self fetchUserInfoWithError:error]; 如果是像前者一样调用的话，是不会走进这个 if(error != NULL)分支判断，我们没必要为这种情况单独初始化一个 error 实例。 以上，在帮别的同事封装可调用 API 的时候增加必要的 NSError 参数，不仅方便别人，其实也是方便自己。 参考NSErrorBest Practice - NSError domains and codes for your own project/app]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bonjour 的理解]]></title>
    <url>%2F2017%2F12%2F28%2FBonjour-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[先提问几个问题 什么是 Bonjour？ Bonjour 提供了哪些服务？ Bonjour 的工作机制是什么样子的? Bonjour 实践 Bonjour 异常分析 什么是 BonjourBonjour 被认为是 0 网络配置，自动发现 PC，普通设备和 IP 网络服务的协议。Bonjour 使用工业标准的 IP 协议，允许一台设备在不需要输入对方 IP 地址或配置 DNS 服务器的情况下自动发现其他设备。特别是 Bonjour 不需要 DHCP 服务器就能使 IP 自动分配，同时无需 DNS 服务器能给 IP 命名，发现服务不需要额外的服务器。同时它是个开放的协议。 Bonjour, also known as zero-configuration networking, enables automatic discovery of computers, devices, and services on IP networks. Bonjour uses industry standard IP protocols to allow devices to automatically discover each other without the need to enter IP addresses or configure DNS servers. See the Bonjour Protocol Specifications section for more details on the underlying standards. Technical Q&amp;A QA1690 Common QA for Bonjour 一个实际场景是，我的电脑想用使用打印机打印一些资料，Bonjour 可以使打印机自动连接到网络，同时给打印机分配一个 IP 地址，无需任何配置，相同网络下的电脑就可以发现这台打印机，并识别到打印机的 IP 地址，进而建立连接完成打印工作。而且如果你以后地址被动态分配的地址被改变了，Bonjour 还能继续发现新的地址。 Bonjour 提供了哪些服务？ addressing (向 host 分配 IP 地址) naming （使用名字代表 host 而不是 IP 地址） service discovery （自动发现网络中的服务） Bonjour 的工作机制是什么样子的?其实就是说一下上面三个服务的实现机制 分配 IP 的原理，使用链路本地地址（link-local address） 来解决。 IPv6 协议包含了这种技术。IPv4 是使用另外的实现来达到这个目的，IPv4 的实现原理是在本地链路中随机取一个地址然后测试是不是被占用，如果没有占用则分配其为本地链路地址，否则重新生成并继续测试占用情况。 link-local address 这项技术被绝大多数操作系统实现，如果硬件厂商想要使用 Bonjour 服务也必须在自己的设备里实现这项技术。 对 link-local address 有兴趣的可以看下它的 wiki 在本地网络中解决 IP 到名字的转换的合适方案是使用 Multicast DNS (mDNS)。 具体实现原理是使用 IP 多播的方式在本地网络中发送 DNS 格式的查询，因为没有一个统一的 DNS 服务器去响应这些查询，所以每个设备或者服务都会去返回自己的 DNS 响应 可以通过 Bonjour 提供的 API 注册服务，Bonjour 可以自动广播你的服务，任何查询你的服务的请求都会直接被转到正确的 IP 和端口。 每个服务和设备都应该只有一个名字，这个名字只在当前的网络环境下起作用。这个起名字的过程大概是这样的 硬件厂商的设备通过发送带有自己名字（XYZ-LaserPrinter.local）的查询来看下是否当前网络中有一样的，如果有响应那就应该重新起个名字（XYZ-LaserPrinter-1.local 这个名字是在原来名字的基础上继续拼接了一个数字）如果没有则继续之前的操作。直到新的名字的查询没有响应。 软件服务是当注册的时候自己起一个名字，如果名字已经被使用了，则 Bonjour 协议会重新给它起一个。 为了向系统表明 local host，macOS 上会在 local host 后面再加个点,比如 Steve.local.。 这部分命名规则比较复杂，这里不赘述了。 通过 DNS 发现服务的过程称为 DNS-SD（DNS Service Discovery）。发现服务这部分的内容还是建立在前面两部的基础上，一个指定服务类型和域名的 mDNS 查询发出去后，有符合条件的服务会返回它们的名字，结果包含了你可选择的一系列服务。和传统的查询服务不同，Bonjour 的服务更类似于询问「我想要的打印服务有没有」，而不是询问每个设备你在运行什么服务（Apple 官方对后者的的说明是，这种询问是以设备为中心的，而前者是以服务为中心）前者相比后者来说对 Client 更加有意义，Client 并不关心其他设备是干嘛的，不断询问只会造成网络压力。 Bonjour 实践macOS 系统提供了一个名为 dns-sd 的 Multicast DNS (mDNS) 和 DNS Service Discovery (DNS-SD) 测试工具。 一个例子，我想查看当前网络下能提供打印的服务 1234567➜ ~ dns-sd -B _printerBrowsing for _printer._tcpDATE: ---Thu 28 Dec 2017---19:45:30.989 ...STARTING...Timestamp A/R Flags if Domain Service Type Instance Name19:45:30.990 Add 3 5 local. _printer._tcp. Brother MFC-8510DN [30055c9332be] (2)19:45:30.990 Add 2 5 local. _printer._tcp. Brother MFC-8510DN [30055c92a583] (2) 我啥都不指定是默认会列出当前提供 http 的服务 1234567➜ ~ dns-sd -B Browsing for _http._tcpDATE: ---Thu 28 Dec 2017---19:45:49.802 ...STARTING...Timestamp A/R Flags if Domain Service Type Instance Name19:45:49.803 Add 3 8 local. _http._tcp. webserver (5)19:45:49.804 Add 3 8 local. _http._tcp. bxxx 还有一个 Bonjour Browser 的软件(如图)来提供可视化的 Bonjour 服务浏览 为啥有的时候连不上 Bonjour? 确认路由器开启了组播模式，某些路由器（如思科）默认关闭了「组播模式」，故无法在此网络下搜索到设备. 跟二次认证网络应该也没有关系. 如果是用 iPhone 设备有的时候跟 iOS 系统版本也有关系，参考 这里 参考Technical Q&amp;A QA1690 Common QA for BonjourBonjour Overviewdns-sd]]></content>
  </entry>
  <entry>
    <title><![CDATA[GCD 的理解]]></title>
    <url>%2F2017%2F12%2F21%2FGCD-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[GCD 的理解Grand Central Dispatch (GCD or libdispatch) 为多核上的并行程序执行上的提供了全面支持。GCD 的出现就是系统帮助开发者管理了一些线程方面的工作让开发者将重心放入自己的业务。减轻了开发者的负担，同时也保证了并行执行的高效。 GCD 中线程和队列的关系首先要明确一下这俩完全不一样的东西，GCD 的线程管理是系统帮助维护了一个线程池，系统自己会去根据当前负载去决定调用线程池的哪个线程去执行对应队列里的 block 任务。 对于 GCD 本身而言，GCD 本身是需要关注线程的管理，开发者使用 GCD 的时候，可以不那么关心线程的知识，省去自己创建线程，管理线程等一系列繁琐的事情，而是专心使用 GCD 提供的队列的功能。 之前看微博上有 iOS 开发小集的知识点，有一点是说如何「判断是否在主队列运行」。当时特别好奇什么情况下会用到这种判断呢？后来在一个 issue 里发现了这种判断的使用场景。 说明这个场景之前问个问题，主线程和主队列是什么关系？答案：主队列一定位于主线程，但是主线程可能包含别的队列。可以写个 demo 测试一下： 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;hello world&quot;); &#125;); &#125; return 0;&#125; 运行结果如图， 而在主线程的主队列里执行的话断点应该是这样的 好，明确了这一点后我们继续说一下什么场景会用到判断当前是否在主队列？即当执行一些 UI 操作的时候我们不仅仅需要判断是否是主线程，还要判断是否是主队列。 诶？难道 UI 操作放到主线程还不够安全吗？是的。相关问题： http://www.openradar.me/24025596 https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083 我们之前被 Apple 教育：UI 操作要放到主线程中执行，但是现在发现放到主线程中执行的时候，因为 Apple 的不靠谱，我们只能自己动手去做个判断。判断主线程的方式就和 iOS 知识小集里的说的一样使用如下代码，通过 key/value 的方式来设置和获取指定的 queue. 12345678910BOOL RCTIsMainQueue()&#123; static void *mainQueueKey = &amp;mainQueueKey; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, mainQueueKey, NULL); &#125;); return dispatch_get_specific(mainQueueKey) == mainQueueKey;&#125; 补充一点：上面有个 demo 没有说明的是 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ xxx }); } 这个方法为什么会在主线程执行呢？可以看下 dispatch_sync 的官方 API 说明 As an optimization, this function invokes the block on the current thread when possible. GCD 的 API 设计GCD 里的 API 设计打都是为了保证多线程下任务的执行顺序。GCD 队列(FIFO)这个概念本身也是为了连续执行 block 而生。这里不打算详细说明具体 API 的使用方法。比如 dispatch_group 相关的 API 是封装了一组任务保证该组任务执行完之后执行某个特定任务，dispatch_semaphore 相关的 API 是等某个任务执行完了再执行某个别的任务。特别说明一下 dispatch_semaphore 这个 API 非常好用，我们经常在业务中比如执行某个网络业务的时候，顺序执行 N 个网络请求来保证业务执行成功，我们会在一个网络请求的异步回调里继续调用另外一个请求的方法，通常的做法是不断的嵌套调用函数，这样是能解决问题，但是不够优雅。但是有了 dispatch_semaphore 我们就可以新的方式去执行这种操作，上个 demo 模拟一下顺序执行一系列异步操作的方法: 1234567891011121314151617int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; dispatch_semaphore_t sem = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;first block&quot;); dispatch_semaphore_signal(sem); &#125;); dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;second block&quot;); dispatch_semaphore_signal(sem); &#125;); dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;this is end&quot;); &#125; return 0;&#125; 还有 dispatch_barrier_async 控制队列中哪些 block 先执行，哪些后执行。在某种程度上和 dispatch_group 挺像。还有一些是通过控制 queue 的优先级来控制任务的执行顺序的，参考 dispatch_set_target_queue 相关用法。 以上都是我们经常用的 gcd 的方法，通过 GCD 提供的 API 来控制队列中 block 的执行。当然 GCD 还提供了很多别的功能，比如通过 dispatch_source_create 创建定时器等等这里就不列举了。 总结：理清楚线程，队列还有 block 三者的关系就能对 GCD 的使用游刃有余。 参考地址 https://developer.apple.com/documentation/dispatch http://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/ http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/ https://github.com/southpeak/iOS-tech-set/blob/master/2017/10.md#判断是否在主队列运行]]></content>
  </entry>
</search>
