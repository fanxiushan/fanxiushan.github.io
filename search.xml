<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NSError 最佳实践]]></title>
    <url>%2F2017%2F12%2F29%2FNSError-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[NSError 的使用访问系统的一些资源的时候，不可避免的会遇到一些错误，我们需要告诉用户或者提醒我们自己遇到什么问题了，方便定位解决。比如移除指定路径文件或者目录的时候，可能文件不存在或者路径有问题等等，我们需要知道究竟为什么不能成功移除，这时候错误信息就很重要了，看下系统是怎么设计这类 API 的。- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error; 使用类似 API 的时候通常都是传递 NSError * _Nullable * 这种参数，目的是为了延长 error 的初始化时机，让 error 在执行任务的时候再初始化并赋予错误信息。 NSError 里面包含的信息很丰富。主要是三个，domain，code 和错误相关的信息。code 是和 domain 相关的。 一个 NSError 的最佳实践是是使用倒序域名方式，这样可以有效避免 NSError 的域名重复。然后根据倒序域名定义错误 code，域名不重复的话，这些 code 可以随意定制，是不会和别的域名下的 code 冲突的。具体看下面 demo 1234567891011121314151617181920212223242526272829static NSString *const kUserInfoDomain = @&quot;com.app.userinfo&quot;;typedef enum : NSUInteger &#123; AUIUserNotExist = 0, AUIUserNameEmpty,&#125; AUIErrorCode;@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self fetchUserInfoWithError:&amp;error];&#125;- (NSString *)fetchUserInfoWithError:(NSError **)error &#123; NSDictionary *errInfo =@&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;; - (void)btnPressed:(id)sender &#123; NSError *error = nil; [self fetchUserInfoWithError:error]; NSLog(@&quot;error = %@&quot;,error);&#125;//模拟一次错误获取- (NSString *)fetchUserInfoWithError:(NSError **)error &#123; NSDictionary *errInfo = @&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;; if(error != NULL)&#123; *error = [NSError errorWithDomain:kUserInfoDomain code:AUIUserNotExist userInfo:errInfo]; &#125; return nil;&#125; 以上错误处理代码中需要注意的一点就是 error 的判断 if(error != NULL) 加这一行的作用是区分一下两种调用方式 [self fetchUserInfoWithError:nil]; NSError *error = nil; [self fetchUserInfoWithError:error]; 如果是像前者一样调用的话，是不会走进这个 if(error != NULL)分支判断，我们没必要为这种情况单独初始化一个 error 实例。 以上，在帮别的同事封装可调用 API 的时候增加必要的 NSError 参数，不仅方便别人，其实也是方便自己。 参考NSErrorBest Practice - NSError domains and codes for your own project/app]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bonjour 的理解]]></title>
    <url>%2F2017%2F12%2F28%2FBonjour-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[先提问几个问题 什么是 Bonjour？ Bonjour 提供了哪些服务？ Bonjour 的工作机制是什么样子的? Bonjour 实践 Bonjour 异常分析 什么是 BonjourBonjour 被认为是 0 网络配置，自动发现 PC，普通设备和 IP 网络服务的协议。Bonjour 使用工业标准的 IP 协议，允许一台设备在不需要输入对方 IP 地址或配置 DNS 服务器的情况下自动发现其他设备。特别是 Bonjour 不需要 DHCP 服务器就能使 IP 自动分配，同时无需 DNS 服务器能给 IP 命名，发现服务不需要额外的服务器。同时它是个开放的协议。 Bonjour, also known as zero-configuration networking, enables automatic discovery of computers, devices, and services on IP networks. Bonjour uses industry standard IP protocols to allow devices to automatically discover each other without the need to enter IP addresses or configure DNS servers. See the Bonjour Protocol Specifications section for more details on the underlying standards. Technical Q&amp;A QA1690 Common QA for Bonjour 一个实际场景是，我的电脑想用使用打印机打印一些资料，Bonjour 可以使打印机自动连接到网络，同时给打印机分配一个 IP 地址，无需任何配置，相同网络下的电脑就可以发现这台打印机，并识别到打印机的 IP 地址，进而建立连接完成打印工作。而且如果你以后地址被动态分配的地址被改变了，Bonjour 还能继续发现新的地址。 Bonjour 提供了哪些服务？ addressing (向 host 分配 IP 地址) naming （使用名字代表 host 而不是 IP 地址） service discovery （自动发现网络中的服务） Bonjour 的工作机制是什么样子的?其实就是说一下上面三个服务的实现机制 分配 IP 的原理，使用链路本地地址（link-local address） 来解决。 IPv6 协议包含了这种技术。IPv4 是使用另外的实现来达到这个目的，IPv4 的实现原理是在本地链路中随机取一个地址然后测试是不是被占用，如果没有占用则分配其为本地链路地址，否则重新生成并继续测试占用情况。 link-local address 这项技术被绝大多数操作系统实现，如果硬件厂商想要使用 Bonjour 服务也必须在自己的设备里实现这项技术。 对 link-local address 有兴趣的可以看下它的 wiki 在本地网络中解决 IP 到名字的转换的合适方案是使用 Multicast DNS (mDNS)。 具体实现原理是使用 IP 多播的方式在本地网络中发送 DNS 格式的查询，因为没有一个统一的 DNS 服务器去响应这些查询，所以每个设备或者服务都会去返回自己的 DNS 响应 可以通过 Bonjour 提供的 API 注册服务，Bonjour 可以自动广播你的服务，任何查询你的服务的请求都会直接被转到正确的 IP 和端口。 每个服务和设备都应该只有一个名字，这个名字只在当前的网络环境下起作用。这个起名字的过程大概是这样的 硬件厂商的设备通过发送带有自己名字（XYZ-LaserPrinter.local）的查询来看下是否当前网络中有一样的，如果有响应那就应该重新起个名字（XYZ-LaserPrinter-1.local 这个名字是在原来名字的基础上继续拼接了一个数字）如果没有则继续之前的操作。直到新的名字的查询没有响应。 软件服务是当注册的时候自己起一个名字，如果名字已经被使用了，则 Bonjour 协议会重新给它起一个。 为了向系统表明 local host，macOS 上会在 local host 后面再加个点,比如 Steve.local.。 这部分命名规则比较复杂，这里不赘述了。 通过 DNS 发现服务的过程称为 DNS-SD（DNS Service Discovery）。发现服务这部分的内容还是建立在前面两部的基础上，一个指定服务类型和域名的 mDNS 查询发出去后，有符合条件的服务会返回它们的名字，结果包含了你可选择的一系列服务。和传统的查询服务不同，Bonjour 的服务更类似于询问「我想要的打印服务有没有」，而不是询问每个设备你在运行什么服务（Apple 官方对后者的的说明是，这种询问是以设备为中心的，而前者是以服务为中心）前者相比后者来说对 Client 更加有意义，Client 并不关心其他设备是干嘛的，不断询问只会造成网络压力。 Bonjour 实践macOS 系统提供了一个名为 dns-sd 的 Multicast DNS (mDNS) 和 DNS Service Discovery (DNS-SD) 测试工具。 一个例子，我想查看当前网络下能提供打印的服务 1234567➜ ~ dns-sd -B _printerBrowsing for _printer._tcpDATE: ---Thu 28 Dec 2017---19:45:30.989 ...STARTING...Timestamp A/R Flags if Domain Service Type Instance Name19:45:30.990 Add 3 5 local. _printer._tcp. Brother MFC-8510DN [30055c9332be] (2)19:45:30.990 Add 2 5 local. _printer._tcp. Brother MFC-8510DN [30055c92a583] (2) 我啥都不指定是默认会列出当前提供 http 的服务 1234567➜ ~ dns-sd -B Browsing for _http._tcpDATE: ---Thu 28 Dec 2017---19:45:49.802 ...STARTING...Timestamp A/R Flags if Domain Service Type Instance Name19:45:49.803 Add 3 8 local. _http._tcp. webserver (5)19:45:49.804 Add 3 8 local. _http._tcp. bxxx 还有一个 Bonjour Browser 的软件(如图)来提供可视化的 Bonjour 服务浏览 为啥有的时候连不上 Bonjour? 确认路由器开启了组播模式，某些路由器（如思科）默认关闭了「组播模式」，故无法在此网络下搜索到设备. 跟二次认证网络应该也没有关系. 如果是用 iPhone 设备有的时候跟 iOS 系统版本也有关系，参考 这里 参考Technical Q&amp;A QA1690 Common QA for BonjourBonjour Overviewdns-sd]]></content>
  </entry>
  <entry>
    <title><![CDATA[GCD 的理解]]></title>
    <url>%2F2017%2F12%2F21%2FGCD-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[GCD 的理解Grand Central Dispatch (GCD or libdispatch) 为多核上的并行程序执行上的提供了全面支持。GCD 的出现就是系统帮助开发者管理了一些线程方面的工作让开发者将重心放入自己的业务。减轻了开发者的负担，同时也保证了并行执行的高效。 GCD 中线程和队列的关系首先要明确一下这俩完全不一样的东西，GCD 的线程管理是系统帮助维护了一个线程池，系统自己会去根据当前负载去决定调用线程池的哪个线程去执行对应队列里的 block 任务。 对于 GCD 本身而言，GCD 本身是需要关注线程的管理，开发者使用 GCD 的时候，可以不那么关心线程的知识，省去自己创建线程，管理线程等一系列繁琐的事情，而是专心使用 GCD 提供的队列的功能。 之前看微博上有 iOS 开发小集的知识点，有一点是说如何「判断是否在主队列运行」。当时特别好奇什么情况下会用到这种判断呢？后来在一个 issue 里发现了这种判断的使用场景。 说明这个场景之前问个问题，主线程和主队列是什么关系？答案：主队列一定位于主线程，但是主线程可能包含别的队列。可以写个 demo 测试一下： 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;hello world&quot;); &#125;); &#125; return 0;&#125; 运行结果如图， 而在主线程的主队列里执行的话断点应该是这样的 好，明确了这一点后我们继续说一下什么场景会用到判断当前是否在主队列？即当执行一些 UI 操作的时候我们不仅仅需要判断是否是主线程，还要判断是否是主队列。 诶？难道 UI 操作放到主线程还不够安全吗？是的。相关问题： http://www.openradar.me/24025596 https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083 我们之前被 Apple 教育：UI 操作要放到主线程中执行，但是现在发现放到主线程中执行的时候，因为 Apple 的不靠谱，我们只能自己动手去做个判断。判断主线程的方式就和 iOS 知识小集里的说的一样使用如下代码，通过 key/value 的方式来设置和获取指定的 queue. 12345678910BOOL RCTIsMainQueue()&#123; static void *mainQueueKey = &amp;mainQueueKey; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, mainQueueKey, NULL); &#125;); return dispatch_get_specific(mainQueueKey) == mainQueueKey;&#125; 补充一点：上面有个 demo 没有说明的是 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ xxx }); } 这个方法为什么会在主线程执行呢？可以看下 dispatch_sync 的官方 API 说明 As an optimization, this function invokes the block on the current thread when possible. GCD 的 API 设计GCD 里的 API 设计打都是为了保证多线程下任务的执行顺序。GCD 队列(FIFO)这个概念本身也是为了连续执行 block 而生。这里不打算详细说明具体 API 的使用方法。比如 dispatch_group 相关的 API 是封装了一组任务保证该组任务执行完之后执行某个特定任务，dispatch_semaphore 相关的 API 是等某个任务执行完了再执行某个别的任务。特别说明一下 dispatch_semaphore 这个 API 非常好用，我们经常在业务中比如执行某个网络业务的时候，顺序执行 N 个网络请求来保证业务执行成功，我们会在一个网络请求的异步回调里继续调用另外一个请求的方法，通常的做法是不断的嵌套调用函数，这样是能解决问题，但是不够优雅。但是有了 dispatch_semaphore 我们就可以新的方式去执行这种操作，上个 demo 模拟一下顺序执行一系列异步操作的方法: 1234567891011121314151617int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; dispatch_semaphore_t sem = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;first block&quot;); dispatch_semaphore_signal(sem); &#125;); dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;second block&quot;); dispatch_semaphore_signal(sem); &#125;); dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;this is end&quot;); &#125; return 0;&#125; 还有 dispatch_barrier_async 控制队列中哪些 block 先执行，哪些后执行。在某种程度上和 dispatch_group 挺像。还有一些是通过控制 queue 的优先级来控制任务的执行顺序的，参考 dispatch_set_target_queue 相关用法。 以上都是我们经常用的 gcd 的方法，通过 GCD 提供的 API 来控制队列中 block 的执行。当然 GCD 还提供了很多别的功能，比如通过 dispatch_source_create 创建定时器等等这里就不列举了。 总结：理清楚线程，队列还有 block 三者的关系就能对 GCD 的使用游刃有余。 参考地址 https://developer.apple.com/documentation/dispatch http://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/ http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/ https://github.com/southpeak/iOS-tech-set/blob/master/2017/10.md#判断是否在主队列运行]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
