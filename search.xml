<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift 关于初始化方法的 QA]]></title>
    <url>%2F2020%2F01%2F03%2FSwift-%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E7%9A%84-QA%2F</url>
    <content type="text"><![CDATA[Q: swift 和 OC 初始化（init）方法的区别？ Swift 的初始化方法和普通的 swift 方法有什么区别的点吗？ 123init() &#123; desktop = &quot;桌子&quot;&#125; A: 和 OC 的初始化方法相比1 - 初始化顺序的区别， swift先初始化自己的成员变量，然后在调用父类的初始化方法，OC 的调用则相反2 - swift 不需要 return 方法，写就行了3 - swift 子类默认不继承父类的初始化方法，但是遇到一些 case 是自动继承的。 参考这里 Automatic Initializer Inheritance和普通的 swift 方法相比1 - 没有 func 关键字，只有 init 关键字Note -1 - 但是和普通的 swift 方法一样，后面的参数的语法是一样的，即下面这种初始化方法完全没有问题. 123456class House &#123; let desktop:String #Note-这儿是 let 照样可以在初始化方法中赋值! init(with desktop:String) &#123; self.desktop = desktop &#125;&#125; Q: swift 中什么是初始化委托(Initializer delegation)，有啥用??A: 就是在一个初始化方法中调用另外一个初始化方法，作用是可以减少重复的初始化代码。这个难点在于，类的是支持继承的（结构体/枚举不支持继承相对简单，直接本类提供对应方法即可），需要保证存储属性的初始化一致。举个官方的例子 - 12345678910111213141516struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125;&#125;extension Rect &#123; //初始化方法放在 Extension 更合适. init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 参考地址:1 - Initializer Delegation for Value Types #Swift 官方的说明2 - Extensions -&gt; Initializers #Swift 官方的说明 Q: 下面这种写法有问题吗？会编译报错吗？ 123456789class People &#123; var mount:Int = 0&#125;class ChinesePeople: People &#123; var name:String init(name:String) &#123; self.name = name //这儿没有调用父类的 super.init() &#125;&#125; A: 没问题，不会编译报错。这儿其实是在 self.name = name 后面隐式调用了 super.init() 方法.. 能这么做的原因是所有的 stored property 都已经被初始化了..Note1 - 很多时候衡量初始化方法合理不合理的一个重要指标就是「是否所有的存储属性在初始化完毕之后都被赋值了」.. 上面这个例子之所以没有报错也是因为 mount 已经赋值了. Q: 下面这种 case 执行的时候会执行父类的 CustomTT… ? 1234567891011let ttc = TTClass()class CustomTT &#123; init() &#123; print(&quot;CustomTT”) &#125;&#125;class TTClass: CustomTT &#123; override init() &#123; print(&quot;TTClass”) &#125;&#125; A: 会.. 理论上复写的话只会走子类的方法，但是初始化方法比较特殊，它会隐式的调用父类的初始化方法来完成初始话过程. Instead of making an explicit call to super.init(), this initializer relies on an implicit call to its superclass’s initializer to complete the process. 参考地址:1 - Swift - Initialization Q: Swift 初始化方法 designated Initializers 和 convenience Initializers 是干嘛的有啥区别？A: designated initializers 是一个类的主要的初始化方法。它做了点啥呢？主要就是初始化当前类的所有存储属性，以及通过调用父类的合适的初始化方法来继续完成初始化。一般来说一个类必须要有一个convenience initializers 相对来说并不是主要的初始化方法，所以从字面意思来说是「便捷的初始化方法」，这个便捷初始化方法类可以没有。Swift 官方给出的 convenience/designated initializers 的三个法则 -1 - designated initializer 必须调用父类相关的 designated initializer，举下面这个例子- 1234567891011121314151617class People &#123; var mount:Int init(with mount:Int) &#123; self.mount = mount &#125;&#125;class ChinesePeople: People &#123; var country:String override init(with mount: Int) &#123; country = “china&quot; //Note //1 - 这儿必须调用同样的 designated initializer 方法. //2 - 如果不调用会报编译错误: &apos;super.init&apos; isn&apos;t called on all paths before returning from initializer //3 - 如果调用 super.init() 报编译错误: Missing argument for parameter &apos;with&apos; in call super.init(with: mount) &#125;&#125; 2 - convenience initializer 必须调用类中另外一个初始化方法. 123456789101112131415161718192021let chinesePeople = ChinesePeople.init(country: “Chinese”) #使用 convenience 进行初始化class People &#123; var mount:Int init(with mount:Int) &#123; self.mount = mount &#125;&#125;class ChinesePeople: People &#123; var country:String init(with mount: Int,country:String) &#123; self.country = country super.init(with: mount) &#125; convenience init(country:String) &#123; //Note //1 - 必须要调用另外一个初始化方法. //2 - 不能直接调用调用父类的的初始化方法，否则会报编译错误:Convenience initializer for &apos;ChinesePeople&apos; must delegate (with &apos;self.init&apos;) rather than chaining to a superclass initializer (with &apos;super.init&apos;) self.init(with:14亿人, country:country) &#125;&#125; 3 - convenience initializer 必须最终调用一个 designated initializer 方法 Note -1 - Swift 类的初始化方法复杂在哪，我个人感觉就是在于引入复杂的继承体系后，初始化变得非常复杂。2 - 通常来说大部分的类都只有一个 designated initializers，这很好理解，因为太多的 designated initializers 会让调用者感到迷惑，我究竟应该用哪个，而且也不利于开发者自己维护。3 - convenience initializer 一般都是只能在同一个类层级中进行调用，即不能直接调用父类的初始化方法。而 designated initializers 是只能调用父类的。可以参考下面这张图…参考地址:1 - Swift - Designated Initializers and Convenience Initializers Q: 默认初始化方法和 designated initializer 是啥关系？A: 通常对于一个类来说，默认初始化方法就是 designated initializer “The default initializer (when available) is always a designated initializer for a class” Q: 还是关于 designated initializer 的问题，考虑下面这种 case 到底哪个是 designated initializer? 123456789class People &#123; var mount:Int init() &#123; mount = 0 &#125; init(with mount:Int) &#123; self.mount = mount &#125;&#125; A: 首先考虑一下 designated initializer 定义吧..“A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain”所以尽管一个类倾向于尽可能少的 designated initializer，但这两种都算是 designated initializer。Note1 - 其实理论上上面这两种的实现基本上没有啥差别，只不过一个是使用默认值，一个使用外部参数。 Q: Two-Phase Initialization 是啥意思？有啥用？A: Two-Phase Initialization 中文翻译过来就是「两阶段初始化」，两阶段都做啥了？第一阶段：所有存储属性都被赋初始值。第二阶段：当前类有机会在实例使用前对存储属性进行自定制。 123456789class Vehicle &#123; var numberOfWheels = 0&#125;class Bicycle: Vehicle &#123; override init() &#123; super.init() //这是第一阶段 numberOfWheels = 2 //这是第二阶段 &#125;&#125; Note1 - 两阶段初始化其实并不是什么新技术，而是 Swift 官方的一个提示「告诉你在继承体系中如何正确的初始化存储属性的方式」 Q: 我太难了，所以作为子类(subclass)怎么正确实现自己的初始方法呢？A: 我觉得应该分为三步1 - 初始化自己的属性2 - 调用父类的 designated initializer3 - 修改父类的属性举个例子 - 1234567891011class Vehicle &#123; var numberOfWheels = 0&#125;class Bicycle: Vehicle &#123; var isMobike:Bool override init() &#123; isMobike = false //1 - 初始化子类自己的独有属性 super.init() //2 - 调用父类的 designated initializer numberOfWheels = 2 //3 - 修改父类的属性 &#125;&#125; Q: 有的 init 方法之前要加 requried 是为啥??A: 一个类的初始化方法前面加 requried 那要求继承当前类的所有子类都要加上 requried.Note1 - 如果当前类已经用 requried 标记初始化方法的话，子类再复写的话就不用加 override 关键字了.. 参考地址:1 - Initialization - Required Initializers #Swift 官方的说明 Q: ViewController 的初始化方法应该怎么写？为啥下面这种方式会报错？ 12345class TTViewController: UIViewController &#123; init() &#123; super.init() #CompileError:Must call a designated initializer of the superclass &apos;UIViewController&apos; &#125;&#125; A: 我觉得首先看下面这种 case 自定制视图控制器(从代码模板生成，别的啥都不动)调用 init() 方法就不行.为啥呢? 12UIViewController.init() #CompileOKTTViewController.init() #CompileError Missing argument for parameter &apos;coder&apos; in call 因为 swift 里默认是不继承初始化方法的，只是在一些 case 里才会继承。Swift 也没有提供默认的初始化方法。那么就引入了当前问题，如何自定制初始化方法呢？继承 UIViewController 的 TTViewController 默认没有 init 方法，所以我们可以自定制 Init 方法方法一直接实现 init() 方法并在里面调用 init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) 方法，API 说明里表示这个方法是 designated initializer 方法 123init() &#123; super.init(nibName: nil, bundle: nil)&#125; 方法二 #网上提供的一种方法，但是亲测会报错 123convenience init() &#123; self.init(nibName:nil, bundle:nil) #CompilerError:Ambiguous reference to member &apos;init()&apos;&#125; 然后子类就可以愉快的通过 TTViewController.init() 这种方式初始化视图控制器了… 要不然还得 TTViewController.init(nib:nil, bundle:nil)… Note1 - init 方法在 UIViewController 的子类里属于自定制方法，并不属于默认方法. 参考地址:1 - Fatal error: use of unimplemented initializer ‘init(coder:)‘ for class2 - Why can’t I call the default super.init() on UIViewController in Swift?3 - How does UIViewController manage to have a default no-args initializer in Swift? Q: initWithCoder 是啥初始化方法? 为啥自定制 UIViewController init 方法必须实现这个方法，不实现就报错..A: 自定制 UIViewController 初始化方法必须调用它提供的 designated initializer -&gt; init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) 而这个方法本质是通过 coder 实现的，所以必须实现 initWithCoder 方法。尽管我们自定制以及使用 UIViewController 的时候是从代码直接初始化的，并没有用到 nib 文件，但是为了保证实现的完整性，需要默认实现这个方法 When instantiating a view controller from a storyboard, iOS initializes the new view controller by calling its init(coder:) method instead of this method and sets the nibName property to a nib file stored inside the storyboard. 系统提供的默认试下如下，大概意思是如果你有一天通过 nib 初始化了，就必须要在这个里面做点事儿，否则就崩给你看。 123required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;)&#125; 参考地址:1 - UIViewController and required init?(coder: )]]></content>
  </entry>
  <entry>
    <title><![CDATA[App Store 隐私政策网址]]></title>
    <url>%2F2019%2F12%2F29%2FApp-Store-%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。 1.适用范围 a)在您使用本软件网络服务，本软件自动接收并记录的您的手机上的信息，包括但不限于您的健康数据、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据； 2.信息的使用 a)在获得您的数据之后，本软件会将其上传至服务器，以生成您的排行榜数据，以便您能够更好地使用服务。 3.信息披露 a)本软件不会将您的信息披露给不受信任的第三方。 b)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； c)如您出现违反中国有关法律、法规或者相关规则的情况，需要向第三方披露； 4.信息存储和交换 本软件收集的有关您的信息和资料将保存在本软件及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本软件收集信息和资料所在地的境外并在境外被访问、存储和展示。 5.信息安全 a)在使用本软件网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，请您立即联络本软件客服，以便本软件采取相应措施。]]></content>
  </entry>
  <entry>
    <title><![CDATA[macOS XPC 上手]]></title>
    <url>%2F2018%2F05%2F30%2FmacOS-XPC-%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[XPC 是 macOS 里经常用到的进程间通信机制。本文不关注 XPC 的内部机制，而是一篇教你如何上手 XPC 的文章。 创建 macOS 工程 FRTestXPC，选择 Cocoa App Template。 在工程 FRTestXPC 里点击增加 Target，在弹出框搜索 XPC, 选择搜索结果中的 XPC Service，然后命名 Target 为 FRTestXPC_Helper 并将 target 对应的 info.plist 文件中 bundle id 修改为 ‘com.frank.xpchelper’ 选择 FRTestXPC Target -&gt; Build Phases 然后新增 CopyFiles 项目，将刚刚的 FRTestXPC_Helper.xpc 加进去，注意 Destination 必须要选择 XPC Services。否则后续主程序和 XPC 会无法建立连接。 回过头来看工程目录里 FRTestXPC_Helper -&gt; main.m 文件，这里 main 函数是 XPC 程序的入口函数。可以看到 Xcode 已经帮助生成很多 demo code。我们已经不需要做太多。 在主程序的窗口里增加一个 button,在点击方法里实现如下代码 1234567NSXPCConnection *con = [[NSXPCConnection alloc] initWithServiceName:@&quot;com.frank.xpchelper&quot;];NSXPCInterface *remoteInterface = [NSXPCInterface interfaceWithProtocol:@protocol(FRTestXPC_HelperProtocol)];con.remoteObjectInterface = remoteInterface;[[con remoteObjectProxy] upperCaseString:@&quot;hello&quot; withReply:^(NSString *reply) &#123;NSLog(@&quot;reply = %@&quot;,reply); &#125;];[con resume]; 启动程序，点击 button，观察终端输出为 HELLO 一些说明 Tips :作为 demo 可以删除掉 Project 里的各种 Test Target 和 Test 文件，保持工程清爽直观。 我用的是 Xcode9.1版本，创建好的 XPC 中的代码完全为 Xcode 自动生成的，(void)upperCaseString:(NSString *)aString withReply:(void (^)(NSString *))reply; 这个协议也是 Xcode 生成的，所以看上面代码不要太突兀，你自己试试就知道了。 初始化主程序 NSXPCConnection 的时候必须写正确 XPC 的 service name. 一些 QAQ: 什么场景下会用到 XPC? 具体到项目中说一下。A: 我觉得用到 XPC 的地方主要还是希望让别的进程分担自己的任务，同时又能够及时的和主进程进行通信。(比如一些网络处理的服务) Apple WWDC 的讲解也是这么说的 So if you just have some background piece of work that needs to happen every so often, you can use XPC to talk to it, initiate it, and get it running. 其次是考虑一些其他因素，比如 增加程序稳定性(XPC Service crash 但主程序不 crash). XPC 服务处理一些不够安全的东西，这时候我们不提供 XPC 任何权限，比如网络访问，文件访问等，但是主程序还是保留所有的权限。 相当于让小弟干活儿，但是不给小弟太多权利，干的了就干，干不了就别干….. 很重要一点：是这是 App Store 允许的多进程的方式。 Q: XPC 服务有界面吗?A: 一般都是后台进程。没见过有人用 XPC 搭建界面的。 Q: 系统是怎么通过以下这些 API 方法找到 XPC 服务的 ？ NSXPCInterface *myCookieInterface = [NSXPCInterfaceinterfaceWithProtocol:@protocol(XPC_HelperProtocol)]; NSXPCConnection *myConnection = [[NSXPCConnection alloc] initWithServiceName:@&quot;com.frank.xpchelper&quot;];A: 当 app 启动的时候，系统自动注册 app 中可见的 XPC 服务，当 app 与某个 XPC 服务建立连接，然后向他发送包含事件服务的消息。 When the app is launched, the system automatically registers each XPC service it finds into the namespace visible to the app. An app establishes a connection with one of its XPC services and sends it messages containing events that the service then handles 一个 Demo以上的 demo 是最简单的，一般 XPC 用来做后台下载处理比较合适，所以写了一个比上面代码复杂一点点(不过还是很简单)的 demo 放到 github 上，这个 demo 是 XPC 双向同步的。即 XPC Service 可以不依赖于代理方法的回调而是直接给 Client app 发送消息。 NSXPCConnection 是最主要的 API，其余的 API 比如 NSXPCInterface，都是依附于 Connection。构建双向通信的 XPC Demo 在 ClientApp 和 XPC 里有一些代码非常相似。即互相暴露接口，互相暴露交接的对象。Demo 也提供了一些非常实用的构建 XPC 时用的 API。 Demo 地址: https://github.com/fanxiushan/Demo.XPCTestDemo 参考地址Creating XPC ServicesMac Technology Overview -&gt; Kernel and Device Drivers Layer -&gt; High-Level Features -&gt; XPC Interprocess Communication and ServicesWWDCXPC]]></content>
  </entry>
  <entry>
    <title><![CDATA[Block 理解]]></title>
    <url>%2F2018%2F04%2F07%2FBlock-%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文将按照如下顺序逐个说明 Block 的本质 Block 捕获成员变量 Block 的存储域以及内存生命周期分析 Block 捕获成员变量的生命周期 GCD 里面的 Block 分析 MRC &amp; ARC 下 Block 内存管理区别 Block __weak 分析 / __strongSelf 分析 一些常问的关于 Block 的面试题回答 本文不关注 Block 的语法，只尝试说明 Block 捕获变量的方式，Block 捕获的变量的生命周期以及 Block 自身的生命周期。最后对一些常见的自己的疑问进行一些梳理归纳。 Block 的本质使用 clang -rewrite-objc main.m 编译如下代码 12345int main(int argc, const char * argv[]) &#123; void(^block)(void) = ^() &#123; NSLog(@&quot;hello world&quot;); &#125;; block(); return 0;&#125; 得到结果是 12345678910111213141516171819202122232425262728293031323334struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;//---struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;//---static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;//---int main(int argc, const char * argv[]) &#123; //初始化 block void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); //执行 block 对应方法 ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125;//---static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_aef28d_mi_0);&#125; 从上面编译后的文件里可以看到一些信息block实现的主体就是__main_block_impl_0，这个结构体里面嵌套了一个名字为__block_impl的结构体以及名为__main_block_desc_0的结构体指针。闭包里面的代码部分被抽出来生成了一个 C 语言的函数实现 __main_block_func_0，注意的是这个函数的参数就是结构体本身，这么做有啥用呢？方法实现里根本没用到 block 实例啊，后面会用到的… 说明一下这个 __block_impl 结构体: __block_impl结构体里面有void *isa成员变量，很眼熟对不对，这个就是Objective-C对象实现中的对象指针，所以我们通常认为block也算是Objective-C对象。 __main_block_impl_0初始化方法impl.isa = &amp;_NSConcreteStackBlock; Demo 里的 block 类型属于 _NSConcreteStackBlock。 __block_impl结构体里有函数指针 FuncPtr，在 __main_block_impl_0 初始化的时候指向block闭包里面函数的实现。 Block 捕获变量Block 捕获普通类型自动变量Block 的一个强大之处在于能捕获变量，在执行闭包方法的时候利用外部捕获的变量得到一些想要的结果，这是怎么做到的？将 demo 稍作改动，添加一个自动变量，如下： 123456789int main(int argc, const char * argv[]) &#123; int a = 0; void(^block)(void) = ^() &#123; NSLog(@&quot;hello world a = %d&quot;,a); &#125;; a = 3; block(); return 0;&#125;//执行结果如下hello world a = 0; 继续使用 clang -rewrite-objc main.m 进行编译，得到如下结果（已精简） 12345678910111213141516171819202122struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_473c35_mi_0,a);&#125;int main(int argc, const char * argv[]) &#123; int a = 0; void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a)); a = 3; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 这次跟没有捕获成员变量时候比，在 __main_block_impl_0 结构体里多了一个成员变量 a，结合 main.m 实现以及 __main_block_impl_0() 的初始化方法可以看到这个成员变量 a 的初始化是依靠外部同名自动变量 a 的赋值，所以打印的时候会打印初始化 block 时候外部变量的 a 的值。如果在 block 初始化之后再次对外部自动变量 a 进行了修改，则 block 自动变量不会被修改。参考上面 demo 的执行结果。 Block 捕获并修改普通类型自动变量/__block 修饰符分析有一个值得思考的问题，如果我想要在 block 的闭包函数里修改外部变量的值该怎么做？目前的实现只是打印了 block 成员变量a的值，如果修改的话，我们也仅仅只能修改成员变量a的值，而没有途径修改外部变量的值。怎么办？一个方法就是在 block 内部做一个指针，指向外部自动变量 a,这样就能在执行方法的时候通过指针去修改外部变量的值。怎么样才能实现我们这个方案呢，block 提供了一个修饰符 __block 去修饰外部成员变量，当 block 捕获了带有 __block 修饰的外部成员变量的时候会自动在结构体内部生成一个引用外部变量的指针变量。如下 demo 所示： 12345678910int main(int argc, const char * argv[]) &#123; __block int a = 0; ① void(^block)(void) = ^() &#123; NSLog(@&quot;hello world a = %d&quot;,a); ②&#125;; ③ a = 3; block(); return 0;&#125;//执行结果是hello world a = 3 注：①②③ 处分别打印 a 的内存地址，在 ARC/MRC 下会有不同的结果，在 MRC 下内存地址打印都是一样的，但是在 ARC 下，①和②③打印的地址不一样，①打印的是栈上地址，②③打印的是堆上的地址，原因是在 ARC 下向 block 赋值的时候，会自动将 block 从栈上拷贝到堆上。这个现象和后面说到的像 strong 修饰符修饰的 block 属性赋值是一个道理。 编译后的结果为 12345678910111213141516171819202122232425262728293031323334353637383940414243struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; int __flags; int __size; int a;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_bd6f8c_mi_0,(a-&gt;__forwarding-&gt;a)); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123; _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123; _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, const char * argv[]) &#123; __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 0&#125;; void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); (a.__forwarding-&gt;a) = 3; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 根据编译后的结果来看，block 捕获了带有 __block 的自动变量之后生成的代码变的很多，而且出现了很多新的方法，比如 __main_block_dispose_0 和 __main_block_copy_0。同时 block 对应的结构体 __main_block_impl_0 里多出来一项 __Block_byref_a_0 *a;，这个跟我们之前预想的并不一样，我们之前预想的就是多出来一个 int *a 应该就好了，但是这里多出了一个 __Block_byref_a_0 结构体类型的指针，来看一下定义 ： 1234567struct __Block_byref_a_0 &#123; void *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a;&#125;; 包含 void *__isa 成员变量，__Block_byref_a_0 这个也算是一个对象类型，里面包含了一个 int a 的成员变量，以及一个指向自己的指针。被 __block 修饰符修饰的成员变量被编译器转化为 __Block_byref_a_0 类型的变量。初始化的时候将外部的 __Block_byref_a_0 变量地址赋值给 block 结构体成员变量里的 __Block_byref_a_0 指针。在 block 闭包函数执行的时候通过这个指针来去修改外部变量的值。 但是有个问题，为啥不直接生成一个 int *a 这样的指针，而去生成一个那么麻烦的类型呢？后面详细说明 思考一下，为什么block捕获带有 __block 修饰符的时候，闭包执行永远输出外部变量a的当前值？ Block 捕获对象先上个 demo 1234567int main(int argc, const char * argv[]) &#123; NSString * a = @&quot;hello&quot;; void(^block)(void) = ^() &#123; NSLog(@&quot;hello world a = %@&quot;,a); &#125;; a = @&quot;world&quot;; block(); return 0;&#125; 编译后 123456789101112131415161718192021222324struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;//int main(int argc, const char * argv[]) &#123; NSString * a = (NSString *)&amp;__NSConstantStringImpl__var_folders_r4_93dvjwh16d17_brzl2bv_xb40000gn_T_main_0c7a66_mi_0; void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, 570425344)); a = (NSString *)&amp;__NSConstantStringImpl__var_folders_r4_93dvjwh16d17_brzl2bv_xb40000gn_T_main_0c7a66_mi_2; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125;//static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; NSString *a = __cself-&gt;a; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_r4_93dvjwh16d17_brzl2bv_xb40000gn_T_main_0c7a66_mi_1,a);&#125; block实现的结构体__main_block_impl_0里多了一个 NSString *a，貌似和捕获正常的自动变量没什么差别。从 mian.m 方法里的 block 初始化过程里可以看到，这个结构体成员变量的具体的赋值过程其实就是外部字符串对象 a 直接赋值给了 block 结构体成员变量 a，具体的 block 闭包实现中也是直接从 block 结构体中取出 a 直接进行的访问。所以其实闭包里面可以修改对象指针的话也丝毫不会影响外部的同名自动变量 a（这俩根本就不是一个对象指针…），但是如果直接在里面修改的话，编译器是不支持的，会报错（跟捕获普通自动变量时候报一个错）如下： 1Error:Variable is not assignable (missing __block type specifier) 但是，如果不是对捕获的外部变量进行指针修改的话，是可以对这些外部变量进行一些操作的，比如说我们捕获的变量是一个可变数组，demo 如下: 12345678910111213int main(int argc, const char * argv[]) &#123; NSMutableArray *muarr = [NSMutableArray arrayWithCapacity:0]; void(^block)(void) = ^() &#123; [muarr addObject:@&quot;1&quot;]; NSLog(@&quot;muarr = %@&quot;,muarr); &#125;; block(); return 0;&#125;//执行结果如下:BlockDemo[1088:31899] muarr = ( 1) 可以看到我们在不改变外部对象指针的情况下，对外部对象进行了操作。 写到这儿不知道为啥想起来，其实跟字符串对象用 strong 修饰还是 copy 修饰有异曲同工之妙了，一般面试题问起来的话，字符串都是用 copy 修饰的，原因是如果字符串 NSString 类型指向了一个 NSMutableString 类型，那当可变字符串的字符更改的时候，看起来就是虽然 NSString 指针没变，但是内容发生了改变，会引起使用上的一些矛盾之处。所以尽量会使用 copy 修饰符修饰。 同理，想要修改对象指针的话，还是要加上 __block 修饰符。可以自己使用 clang -rewrite-objc main.m 的方式生成一下源代码分析一下。需要注意在 block 闭包实现的时候对变量访问的方式。 看编译后的代码被捕获的__block变量是在栈上__Block_byref_fan_0 object，初始化Block对象的时候使用object-&gt;forwarding指针去初始化Block内部对应生成的 __Block_byref_fan_0 *指针，而object-&gt;forwarding这个指针是指向object自身的内存地址。这块儿的分析有助于我们后面对__block修饰的变量内存进行分析。 Block 的存储域以及内存生命周期分析Block 存储域Block 存储域分为三种类型：栈上(_NSConcreteStackBlock)，堆上(_NSConcreteMallocBlock)和数据区(_NSConcreteGlobalBlock)。上面的例子中Block都是存在栈上的，和普通的变量一样声明在函数外的话Block就是存在数据区中，比如下面这种 case: 1234567void(^block)(void) = ^() &#123; NSLog(@&quot;hello world&quot;);&#125;;int main(int argc, const char * argv[]) &#123; block(); return 0;&#125; Block 就是存储在数据区，clang -rewrite-objc main.m 之后生成的代码中，Block 初始化方法中有这样一行 impl.isa = &amp;_NSConcreteGlobalBlock;，说明 Block 所属的类是 _NSConcreteGlobalBlock。 值得分析的是，Block 存储域存在堆上的情况，&lt;OC 高级编程&gt; 一书举了如下的例子 123456789typedef int(^blk_t)(int);blk_t func(int rate) &#123; return ^(int count) &#123; return rate *count; &#125;;&#125;int main(int argc, const char * argv[]) &#123; blk_t blk = func(5); NSLog(@&quot;%d&quot;,blk(10)); return 0;&#125; func()方法中Block作为了返回值返回，按道理来讲 Block 超出其函数作用域之后就会被销毁，但是在 ARC 环境下这个 main.m 能正常输出执行结果。当我们修改 main.m 文件的编译选项为 -fno-objc-arc 的时候编译器会报错： 1Error&quot;Returning block that lives on the local stack 说明是 ARC 下编译器帮我们做了一些事情，避免了 block 在栈上不能返回的问题。将非 ARC 下的代码修改为 123blk_t func(int rate) &#123; return [^(int count) &#123; return rate *count; &#125; copy];&#125; 才能避免编译失败问题，并正确得到执行结果。 书上给出的在 ARC 下func方法编译完后大致的代码如下 12345blk_t func(int rate) &#123; blk_t tmp = ((int (*)(int))&amp;__func_block_impl_0((void *)__func_block_func_0, &amp;__func_block_desc_0_DATA, rate)); tmp = objc_retainBlock(tmp); return objc_autoreleaseReturnValue(tmp);&#125; 即 ARC 下编译器对本身是存在于栈上的Block对象执行了一次copy操作，转移到堆上。 运行时库中 NSObject.mm 文件中可以看到objc_retainBlock就是_Block_copy方法。 123id objc_retainBlock(id x) &#123; return (id)_Block_copy(x);&#125; 大部分情况下编译器都会处理将栈上的Block复制到堆上的 case. Block 内存分析存在栈上的Block，如果所属的作用域结束，该Block就被废弃，由于__block修饰的变量也在栈上那么__block修饰的变量也会被废弃。 使用栈来存储变量的优点是内存是自动为你管理的。你无需手动分配内存，或者在你不再需要时释放内存。参考地址 刚才说过在 ARC 下，编译器会自动将 Block 从栈上复制到堆上，使用的方法为 _Block_copy 下面是官方的的 API 说明 123456// Create a heap based copy of a Block or simply add a reference to an existing one. This must be paired with Block_release to recover memory, even when running under Objective-C Garbage Collection.BLOCK_EXPORT void *_Block_copy(const void *aBlock) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);//Lose the reference, and if heap based and last reference, recover the memoryBLOCK_EXPORT void _Block_release(const void *aBlock) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2); 即使用 _Block_copy 可以创建基于堆上的一份儿Block的复制，同时_Block_copy一定是配合_Block_release使用，否则会造成内存泄漏。 Block 捕获成员变量的生命周期Block 捕获普通对象的生命周期分析捕获普通自动变量对象 A 的话，Block 会影响普通自动变量的生命周期，即自动变量作用域结束，A 并不会被立即释放。而是跟捕获了它的 Block 的生命周期同步。原因是为了捕获自动变量 A，Block 对象内部会生成一个捕获对象的同类型的对象 A’ 来对捕获对象进行持有，即使得 A 的引用计数加一。所以当 A 的作用域结束之后 A 依然能存活，直到 Block 被释放，A 跟着一起被释放。 1234567891011int main(int argc, const char * argv[]) &#123; blk_t blk; &#123; Fan *fan = [[Fan alloc] init]; blk = ^() &#123; NSLog(@&quot;a = %@&quot;,fan); &#125;; &#125; blk(); return 0;&#125; 我们编译完的这部分代码中包含如下代码，这是为了管理__block结构体中捕获的对应外部变量的fan的内存而生。 123456789struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; Fan *fan; ...&#125;;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;fan, (void*)src-&gt;fan, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;fan, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125; 编译后的代码中这两个方法并没有被调用，而是当Block被从栈上拷到堆上，以及在堆上被释放的时候才会被调用。如图： 但是实践中很奇怪的一点是在 ARC 环境下，对Block对象进行了 copy 操作还是没能触发_Block_object_assign这个方法的执行，但是在 MRC 环境下同样条件就能触发_Block_object_assign这个方法。这里 ARC 编译后的代码应该是做了一些额外的操作。 Block 捕获带有 __block 修饰符对象的声明周期分析如果被__block修饰的对象是自动变量，而且Block并没有执行从栈拷贝到堆上的操作，那和普通的自动变量对象一样并没有什么区别，__block修饰的对象也是跟着Block对象一起释放。 但是实际情况里__block修饰对象可能存在栈上，可能存在堆上，而Block对象也有可能从栈上被复制到堆上，这些场景下，__block修饰对象的生命周期是什么样的？ 当Block捕获带有__block修饰符的自动变量的时候，编译后代码出现下面的一些源码，即 Block对象除了管理自己的内存之外还要额外操心__block修饰变量的内存了。 这里 __block变量对象内存管理和普通的引用计数管理思想基本一致了，即哪个Block对象持有了__block变量，则该Block对象有义务对__block变量进行释放。当所有Block都被释放的时候__block变量也跟着一起释放掉。 GCD 里面的 Block 分析GCD 提供的 API 里大量使用了 Block 作为参数，比如我们常用的 API dispatch_async(queue, ^(void){}) 等，通常来说，我们并不需要过分关注 API 中 Block 的内存管理。因为 GCD 会自动帮我们处理，参考 dispatch_async API 的官方说明(其实 dispatch_after API 里也是这么说的) dispatch_async 参数 block 的解释The block to submit to the target dispatch queue. This function performs Block_copy and Block_release on behalf of callers. This parameter cannot be NULL.即这个方法会自动在合适的时机执行 Block_Copy 和 Block_release 两个方法。这样就保证了在执行 Block 之前不会因为 Block 的作用域的原因而是的 Block 提前被释放，将 Block 放到堆上是比较安全的做法。 现在有个问题，Block 被谁持有了？通过写 demo 打符号断点 _Block_copy，跟到了其上一步调用 _dispatch_Block_copy ，然后在 GCD 的 queue.c 源码中找到了答案，是一个 dispatch_block_t 的类型的变量持有了 Block 对象。 关于 GCD 里面的 Block 里面是否应该使用 self，YYKit 的一个 issue 里讨论的比较火热。但是很多评论都是有问题的，包括 YY 的理解都是有问题的，YY 对 block 的理解就是「self-&gt;_queue-&gt;block-&gt;self 这不是循环引用吗」但是根据我们刚才的分析，其实 GCD 的 queue 并没有持有 block，GCD 的 Block 内存管理跟当前执行所在的类没有任何关系，系统负责Block_Copy和Block_release，我理解这种 case 算不上循环引用。所以可以放心的在 GCD 里面使用 self，而不需要 weak dance. Block_Copy 内部的实现机制可以参考这篇文章 还有一个 GCD 中应该注意的内存问题，即 ARC 和 dispatch queues 以及 GCD Block 内存管理之间的关系。需要分类讨论 If your deployment target is lower than iOS 6.0 or Mac OS X 10.8 You need to use dispatch_retain and dispatch_release on your queue. ARC does not manage them. If your deployment target is iOS 6.0 or Mac OS X 10.8 or later ARC will manage your queue for you. You do not need to (and cannot) use dispatch_retain or dispatch_release if ARC is enabled. 参考地址 - Does ARC support dispatch queues? 在 MRC 下 GCD 也会自动执行 Block_Copy 和 Block_Release 方法，所以在 MRC 下的 GCD Block 里面继续使用 self 也不会产生内存的问题。 总结就是在古老的系统中，即使编译器开启了 ARC 也不一定能管理 dispatch_object 对象，还好我们现在早已经过了兼容的那个阶段。 MRC &amp; ARC 下 Block 内存管理区别MRC 和 ARC 下 Block 内存管理的区别主要在于 MRC 下并不会对Block进行主动 copy 操作。举个例子： 123456789101112blk returnblk() &#123; int a = 0; blk tempblk = ^()&#123; NSLog(@&quot;hello world,a = %d&quot;,a); &#125;; return tempblk;&#125;int main(int argc, const char * argv[]) &#123; blk newblk = returnblk(); newblk(); ① return 0;&#125; MRC 下在 ① 的位置打断点，观察 newblk 的类型为 __NSStackBlock__，同样断点ARC 下观察到 newblk 的类型为 __NSMallocBlock__。说明在 ARC 下 tempblk 在返回的时候自动执行了一次 copy 操作。 还有一个更经典的例子 12345678910111213@interface Fan : NSObject &#123; dispatch_queue_t queue; Blk blk;&#125;@end- (instancetype)init &#123; self = [super init]; if (self) &#123; blk = ^() &#123;NSLog(@&quot;self %@&quot;,self);&#125;; ① &#125; return self;&#125; MRC 下在①处打断点，blk 的类型为 __NSStackBlock__，同样断点ARC 下观察到 blk 的类型为 __NSMallocBlock__。ARC 自动在给成员变量 blk 赋值的时候进行了一次 copy 操作。上面这个例子还引出了一个循环引用的问题，我们下面说。 MRC 下 retain 方法使用注意MRC 下还需要注意的是，如果Block在栈上的话，对Block进行 retain 操作没有任何意义。必须对其进行 copy 操作才能将其从栈上复制到堆上。如果Block在堆上的话，对其进行 retain 操作，Block对象的引用计数会加一。 在对 Block 对象进行 copy 操作的时候，Block_copy 方法和 copy 方法执行的效果是一样的，同理，Block_release 和 release 方法效果也一样。 MRC 下破解循环引用的方式对于 MRC 下，为了防止循环引用，我们使用__block来修饰在Block中使用的对象。 原因是在当 Block 被从栈拷贝到堆上的时候，不会对带有__block修饰符的自动变量对象进行 retain 操作，不带有 __block修饰符的自动变量对象会被 retain 操作。所以上面的例子需要现用 __block id temp = self; 也对 self 进行一次引用，然后在 block 里面使用 temp. 对于 ARC 下，为了防止循环引用，我们使用__weak来修饰在Block中使用的对象。 Block __weak 分析 / __strongSelf 分析关于Block weak 和 strong 的说明，这两个配合使用存在的意义就是让 block 避免循环引用。举个例子，在视图控制器 (VC) 的 viewDidLoad 方法里执行如下代码 ,FRButton 内部持有了这个点击 block。 1234567__weak typeof(self) weakSelf = self;[button setClickBlk:^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;strongSelf = %@&quot;,strongSelf); &#125;);&#125;]; 当 dismiss 的时候，VC 并没有被释放，而是等 dispatch_after 的 block 执行之后 VC 才被释放。分析在 button 赋值 block 对象时候 __weak 和 __strong 的用法，通过引用计数和持有关系进行内存分析。 首先在 button block 的外部使用 __weak 对 self 进行持有，并没有增加 self 的引用计数。 在 button block 内部进行对 weakSelf 进行 __strong 修饰符的 strongSelf 持有，增加了 self 的引用计数 分析一下引用关系啊， VC 持有了 button，button 内部持有了 block，block 捕获的是 VC 的 weakSelf。 Block 里面的 strongSelf 仅仅是个自动变量而已（看上面 clang 编译出来的代码就知道，strongSelf 应该是在编译后的闭包函数对应的内联方法里声明的），不用分析其引用关系。但是 strongSelf 增加了 VC 的引用计数。 当点击之后，然后用另外的方法让 VC 迅速(3秒) dismiss，这个时候 VC 并没有被释放，因为 strongSelf 增加了 VC 的引用计数。而 dispatch_after 的 block 持有了 strongSelf，dispatch_after 的 block 在延时 3秒后执行，执行完之后 dispatch_after 的 strongSelf 也被释放(自动变量作用域结束自动被回收)，这个时候 VC 的引用计数变为 0 才会被释放。此时 weakSelf 被置为了 nil，第 3 步里面的引用关系断掉了，即 Block 不再持有 VC 了。所以不会出现循环引用的问题。 释放顺序是：1、 VC; 2、Button;3、Block。 误区一，Block捕获__weak修饰符的对象，虽然我们不能通过执行 clang -rewrite-objc BlockDemo/main.m 来看最后的编译结果（会报错，cannot create __weak reference because the current deployment target does not support weak references），但我猜原理是Block对象结构体内部直接生成一个 __weak修饰的成员变量指向__weak修饰的对象，而不是生成__block修饰的那种结构来，这样才能保证Block不会对self进行强持有来增加引用计数。误区二，另外一个之前分析时候陷入误区的点是，总会纠结block里面的代码会不会执行，其实执行与否都不会影响当前这种结构的的内存分析，执行匿名函数代码的话strongSelf到最后会被释放，block跟着一起释放。不执行的话self其实也没有强持有block，所以不会造成内存引用问题。 正是因为误区二，我们引出另外一个问题，即在下面的①的位置添加了一个判断，有必要吗？ 12345678__weak typeof(self) weakSelf = self;[networkManager fetchFinishBlk:^(response)&#123; __strong typeof(weakSelf) strongSelf = weakSelf; if (nil == strongSelf) &#123; ① return; &#125; [strongSelf xxx];&#125;]; 之前总是觉得 strongSelf 会强引用 self，所以 self 在执行 block 闭包函数之前不会被释放，其实有可能在执行 block 之前，self 已经被释放掉了，则 weakSelf 为 nil, 这个时候 strongSelf 还没有来得及增加的引用计数呢… 所以加上这个判断是必要的。 那又引出一个问题，如果我一定想要执行 block 闭包函数里的方法呢，可以参考这篇文章里的做法，大体思路是先触发循环引用，然后在 block 执行完毕之后再将循环引用破解掉。 再进一步思考，如果是下面这种情况，会造成循环引用吗？ 12345678__weak typeof(self) weakSelf = self;[cell setEditPressedBlk:^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; ① [strongSelf pickerCancel]; strongSelf.textFiledView = [TFAlertView Title:@&quot;Title&quot; message:@&quot;&quot; complete:^(NSString *text, TFAlertView *alertview) &#123; [strongSelf modifyNameWithValue:text]; ② &#125;];&#125;]; 一些常见的关于 Block 的面试题Q: Block 作为对象的属性应该用 copy 修饰还是 strong 修饰??A: 在 MRC 下的话，必须用 copy 修饰，用 retain 修饰的话，栈上的 Block 无法被拷贝对堆上，导致使用的时候可能出问题。 在 ARC 下用 strong 即可，当给 block 属性赋值的时候会自动将栈上的 block 拷贝到堆上，用 copy 的话效果是一样的，但是苹果的官方文档还是建议我们即使是在 ARC 上也使用 copy 修饰符，因为 copy 会显式地说明我们对 block 的操作。同时，我们的工程偶尔也会看到给 block 属性进行赋值的时候，手动添加了一个 copy 方法，比如 self.block = [blk copy]; 其实是完全没有必要的。官方地址 - Objects Use Properties to Keep Track of Blocks #参考地址#WWDC_712Blocks Programming TopiciOS 中的 block 是如何持有对象的深入研究Block捕获外部变量和__block实现原理A look inside blocks: Episode 3 (Block_copy)OC高级编程学习总结之GCDweak与block修饰符到底有什么区别Block在ARC和MRC下的使用分析深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用循环引用的破局法门深入分析 Objective-C block、weakself、strongself 实现原理 最后送上两个关于 block 的语法说明 https://weibo.com/1765732340/GfRtraOYj?type=comment http://fuckingblocksyntax.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 里的拷贝]]></title>
    <url>%2F2018%2F03%2F05%2FObjective-C-%E9%87%8C%E7%9A%84%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[Objective-C 语言里的拷贝就是对象拷贝，即创建一个跟之前的实例对象一模一样的对象。一般来说数据模型类是需要支持拷贝的。Objective-C 里拷贝又分为浅拷贝（shallow-copy）和深拷贝（deep-copy）。 浅拷贝和深拷贝区别浅拷贝只是复制一下对象指针，但是拷贝前和拷贝后的对象指针均指向同一内存区域，只不过是对象的内存引用计数加一。深拷贝为拷贝前和拷贝后的对象指针指向不同的内存区域，即会创建一个新的对象。下图比较直观清楚。 一个非常容易产生的误区就是，遵从了 NSCopying 协议的对象都会执行深拷贝。其实不然，Foundation 框架里大部分类执行的还是浅拷贝。比如 NSString 等。举个例子： 123456NSString *str = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;hello&quot;];NSString *copyStr = [str copy];NSLog(@&quot;str = %p,copyStr = %p&quot;,str ,copyStr);---&gt; str = 0x6f6c6c656855,copyStr = 0x6f6c6c656855&gt; str 在 copy 前后指向的内存地址都一模一样。 还有一点注意的是，虽然有浅拷贝和深拷贝的概念，但是并没有专门定义深拷贝的协议。这点很关键，这意味着除非有文档是写用深拷贝实现 NSCopying 协议的，否则深拷贝的实现都是需要开发者自己去手写实现，而不能依赖于系统框架的实现。 Copy 实例方法和 NSCopying 协议NSObject 有名为 copy 和 mutableCopy 的实例方法。 12- (id)copy;- (id)mutableCopy; NSCopying 协议的方法为 -(id)copyWithZone:(nullable NSZone *)zone。（zone 目前没有任何意义） 123@protocol NSCopying- (id)copyWithZone:(nullable NSZone *)zone;@end 这个实例方法和协议方法有啥关联呢？其实调用 NSObject 的 copy 实例方法就是调用 NSCopying 协议约定的 copyWithZone 方法。同理的，调用 NSObject 的 mutableCopy 实例方法就是调用 NSMutableCopying 协议的 mutableCopyWithZone 方法。 需要注意的是，因为 NSObject 类并不支持 NSCopying 协议，所以继承 NSObject 的子类如果不实现 NSCopying 协议的 copyWithZone 方法会导致应用异常。 见下面 demo 12345678@interface FRModel : NSObject@end@implementation FRModel@end---FRModel *model = [[FRModel alloc] init];[model copy];&gt; -[FRModel copyWithZone:]: unrecognized selector sent to instance 0x1004004c0 copy API 说明Returns the object returned by copyWithZone:. 因为 NSObject 并没有实现 NSCopying 协议，即没有实现 copyWithZone: 方法，所以 FRModel 需要单独实现 copyWithZone: 方法。有一个误区是子类直接复写 copy 方法，这是不正确的操作方式，要避免。 Copy 和 MutableCopy上面说了 NSObject 有 copy 和 mutableCopy 两个实例方法。对应的也有两个协议， NSCopying(copyWithZone:) 和 NSMutableCopying(mutableCopyWithZone:)。虽然名字比较像但是这是两个不同的类，即如果你的类只实现了 NSCopying 协议，这时候给你发 mutableCopy 方法的话还是照样会异常，这两个也没有任何包含关系，把这两个类理解为单独的协议就好了。 1234567FRModel *model = [[FRModel alloc] init];model.name = @&quot;Frank&quot;;FRModel *copyModel = [model mutableCopy];NSLog(@&quot;model = %p,copymodel = %p&quot;,model,copyModel);NSLog(@&quot;model.name = %p,copymodel.name = %p&quot;,model.name,copyModel.name);---&gt; FRCopyDemo *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[FRModel mutableCopyWithZone:]: unrecognized selector sent to instance 0x100532040&apos; 什么时候用 Copy 什么时候用 MutableCopy?我们可以看下 NSMutableCopying 的协议说明 The NSMutableCopying protocol declares a method for providing mutable copies of an object.Only classes that define an “immutable vs. mutable” distinction should adopt this protocol. Classes that don’t define such a distinction should adopt NSCopying instead. NSMutableCopying 声明了提供可对象可变副本的方法，只有区分可变和不可变的类应该遵守这个协议，不区分可变不尅版的话就直接用 NSCopying 方法就好了。 举个例子，我们日常使用的包括可变类型的类是 NSString(NSMutableString)，NSArray(NSMutableArray)，NSDictionary(NSMutableDictionary)以及NSSet(NSMutableSet) 这些类都是同时遵守了 NSCopying 和 NSMutableCopying 协议的。一般来说，我们自己用到的类很少有是可变类型的，所以也很少看到有自己的类实现 NSMutableCopying 协议。 如果要实现的话基本遵守如下原则： 向可变(mutable)或者不可变(immutable)对象发送 copy 消息，得到的都是不可变(immutable)对象。 向可变(mutable)或者不可变(immutable)对象发送 mutableCopy 消息，得到的都是可变(mutable)对象。举个例子验证一下 12345678910NSString *str = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;hello&quot;];NSMutableString *copyStr = [str mutableCopy]; //得到可变对象.[copyStr appendString:@&quot; world&quot;];NSLog(@&quot;str = %p,copyStr = %p&quot;,str ,copyStr);NSLog(@&quot;str class = %@,copyStr class = %@&quot;,NSStringFromClass([str class]) ,NSStringFromClass([copyStr class]));NSLog(@&quot;str = %@,copyStr = %@&quot;,str ,copyStr);---&gt; FRCopyDemo str = 0x6f6c6c656855, copyStr = 0x10044a960&gt; FRCopyDemo str class = NSTaggedPointerString, copyStr class = __NSCFString&gt; FRCopyDemo str = hello, copyStr = hello world 通过输出结果基本上验证了以上的结论。这儿还有一点比较有意思的事儿是，关于 mutableCopy 和深拷贝的关系。我们看到 mutableCopy 之后对象的指针发生了变化，内容并没有发生变化。但其实对象指针类型已经发生了变化。所以跟我们之前说的拷贝多少还是有区别的（正常的拷贝指针类型是不会发生变化的）。只要搞清楚这些不同的概念，就能理解这些概念的区别所在。 怎样让我们的对象支持 copy完整的回答应该是：让类实现 NSCopying 协议里的 copyWithZone: 方法，如果对象是可变的应该同时实现 NSMutableCopying 的 mutableCopyWithZone: 方法。 copyWithZone: 方法的最佳实践一般开发者自己实现 copyWithZone: 方法的时候通常都是实现深拷贝，而非浅拷贝。因为浅拷贝确实没啥好实现的。深拷贝的实现需要考虑其父类是否也遵守了 NSCopying 协议，实现了 copyWithZone: 方法。比如继承自 NSObject 的 FRModel 类按如下方式实现 copyWithZone: 方法，这样显然是会异常的（实际上连编译都不会编译过去）。 12345678@interface FRModel : NSObject&lt;NSCopying&gt;@end@implementation FRModel- (id)copyWithZone:(NSZone *)zone &#123; FRModel *frmodel = [[super allocWithZone:zone] init]; return frmodel;&#125;@end 稍作修改，如果父类没有实现的话子类直接重新创建一个就好了 12345678@interface FRModel : NSObject&lt;NSCopying&gt;@end@implementation FRModel- (id)copyWithZone:(NSZone *)zone &#123; FRModel *frmodel = [[[self class] allocWithZone:zone] init]; return frmodel;&#125;@end 如果该类还有属性或者成员变量的话，可以直接对成员变量执行 copy 操作。参考如下 demo: 12345678910111213141516171819@interface FRModel : NSObject&lt;NSCopying&gt;@property (nonatomic,strong) NSString *name;@end@implementation FRModel- (id)copyWithZone:(NSZone *)zone &#123; FRModel *frmodel = [[FRModel allocWithZone:zone] init]; if (frmodel) &#123; frmodel.name = [_name copyWithZone:zone]; &#125; return frmodel;&#125;@endFRModel *model = [[FRModel alloc] init];model.name = @&quot;Frank&quot;;FRModel *copyModel = [model copy];NSLog(@&quot;model = %p,copymodel = %p&quot;,model,copyModel);NSLog(@&quot;model.name = %p,copymodel.name = %p&quot;,model.name,copyModel.name);---&gt; FRCopyDemo model = 0x102803520,copymodel = 0x102803530&gt; FRCopyDemo model.name = 0x1000010d0,copymodel.name = 0x1000010d0 注意因为 NSString 类型本身 copyWithZone: 属性为浅拷贝，所以最后输出结果两个类的 name 属性的指针指向相同。 Best practice when implementing copywithzone 集合类型拷贝Foundation 框架中所有集合类型在默认情况下都执行浅拷贝，也就是说，只拷贝容器对象本身，而不复制其中数据。这样做的原因在于，容器内的对象未必能拷贝，而且调用者也未必想在拷贝容器时一并拷贝其中每一个对象。 集合类型的浅拷贝和深拷贝的概念和普通对象的深浅拷贝略有不同。 集合类型的浅拷贝是指，当执行浅拷贝的时候，原始集合类型里的对象都收到一个 retain 消息，对象指针被复制到新的集合类型里。 集合类型的深拷贝是指，当执行深拷贝的时候，原始集合里的对象都会收到一个 copyWithZone:，即集合里的对象需要实现 NSCopying 协议来实现深拷贝。如果集合里的对象并没有实现 NSCopying 则程序会异常。如图所示浅拷贝 demo: 12345678NSObject *obj = [[NSObject alloc] init];NSArray *arr = [NSArray arrayWithObject:obj];NSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:NO];NSLog(@&quot;arr = %p,copyArr = %p&quot;,arr ,copyArr);NSLog(@&quot;arr model = %p,copyArr model = %p&quot;,[arr objectAtIndex:0],[copyArr objectAtIndex:0]);---&gt; FRCopyDemo arr = 0x100462b40,copyArr = 0x100461400&gt; FRCopyDemo arr model = 0x100400640,copyArr model = 0x100400640 里面使用了 initWithArray:copyItems: 这个方法，传入 NO 即为浅拷贝。通过打印日志可以看到集合对象指针虽然发生了变化，但是集合内部元素的对象指针还是指向同样的内存区域。 深拷贝 demo: (将 initWithArray:copyItems: 方法第二个参数传入 YES 即为深拷贝) 12345678NSObject *obj = [[NSObject alloc] init];NSArray *arr = [NSArray arrayWithObject:obj];NSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:YES];NSLog(@&quot;arr = %p,copyArr = %p&quot;,arr ,copyArr);NSLog(@&quot;arr model = %p,copyArr model = %p&quot;,[arr objectAtIndex:0],[copyArr objectAtIndex:0]);---&gt; FRCopyDemo -[NSObject copyWithZone:]: unrecognized selector sent to instance 0x100688490&gt; FRCopyDemo *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[NSObject copyWithZone:]: unrecognized selector sent to instance 0x100688490&apos; 因为 NSObject 没有实现 NSCopying 协议，所以集合类型深拷贝时，集合元素 NSObject 对象收到 copyWithZone: 之后异常了。我们将 NSObject 类型修改为 NSMutableString 再次运行 12345678NSMutableString *obj = [NSMutableString stringWithFormat:@&quot;hello world&quot;];NSArray *arr = [NSArray arrayWithObject:obj];NSArray *copyArr = [[NSArray alloc] initWithArray:arr copyItems:YES];NSLog(@&quot;arr = %p,copyArr = %p&quot;,arr ,copyArr);NSLog(@&quot;arr model = %p,copyArr model = %p&quot;,[arr objectAtIndex:0],[copyArr objectAtIndex:0]);---&gt; FRCopyDemo arr = 0x100406dc0,copyArr = 0x100403fb0&gt; FRCopyDemo arr model = 0x100406780,copyArr model = 0x100405260 可以看到集合内的元素执行了不同的内存地址，因为 NSMutableString 收到 copyWithZone: 消息会生成一个不可变的 NSString 对象。initWithArray:copyItems: API 说明 copyItems: 参数 flagIf YES, each object in array receives a copyWithZone: message to create a copy of the object—objects must conform to the NSCopying protocol. In a managed memory environment, this is instead of the retain message the object would otherwise receive. The object copy is then added to the returned array.If NO, then in a managed memory environment each object in array simply receives a retain message when it is added to the returned array. 单层复制和完全复制？思考这样一种情况，即数组套数组，这种深拷贝是怎么做？我们刚使用 initWithArray:copyItems: 方法进行的拷贝只是元素拷贝。即如果是两层数组的话，内层数组里的元素其实并没有机会执行 copyWithZone: 方法。苹果官方称这种拷贝为 one-level-deep copy，即单层复制。 完全复制是指，不管嵌套多少层集合，每层的的元素都有机会执行 copyWithZone: 方法。 Copy 和 NSCoding如何实现完全复制呢？让对象实现 NSCoding 协议，然后将对象归档到文件里再从文件中归档出来，即需要进行两次 I/O 操作。举个例子： 1234567891011121314//NSArray 和 NSString 都支持 NSCoding 协议NSString *path = @&quot;/Users/xiushan.fan/Desktop/arrfile&quot;;NSArray *subArray1 = @[[NSMutableString stringWithString:@&quot;1&quot;]];NSArray *subArray2 = @[[NSMutableString stringWithString:@&quot;2&quot;]];NSArray *wholeArr = @[subArray1,subArray2];[NSKeyedArchiver archiveRootObject:wholeArr toFile:path];NSLog(@&quot;wholeArr = %@,wholeArr = %p,subArr1 = %p,elemement = %p&quot;,wholeArr,wholeArr,[wholeArr objectAtIndex:0],[[wholeArr objectAtIndex:0] objectAtIndex:0]);NSArray *unarchivedArray = [NSKeyedUnarchiver unarchiveObjectWithFile:path];//NSArray *unarchivedArray = [[NSArray alloc] initWithArray:wholeArr copyItems:YES];NSLog(@&quot;unarchivedArray = %@, unarchivedArray = %p ,subArr1 = %p,elemement = %p&quot;,unarchivedArray,unarchivedArray,[unarchivedArray objectAtIndex:0],[[unarchivedArray objectAtIndex:0] objectAtIndex:0]);---&gt; FRCopyDemo wholeArr = ( ( 1 ),( 2 ) ),wholeArr = 0x100422c60,subArr1 = 0x100406930,elemement = 0x100422580&gt; FRCopyDemo unarchivedArray = ((1 ), ( 2 )), unarchivedArray = 0x1004273a0 ,subArr1 = 0x1004039c0,elemement = 0x100424230 可以看到 NSCoding 进行转化之后所有的元素的内存地址均不相同。 Copy 和属性被 copy attribute 修饰的属性，在被赋值的时候，新值其实是会收到一个 copyWithZone: 的消息 1234567891011121314151617181920@interface FRObj : NSObject&lt;NSCopying&gt;@end@implementation FRObj- (id)copyWithZone:(NSZone *)zone &#123; FRObj *obj = [[FRObj allocWithZone:zone] init]; NSLog(@&quot;FRObj copy with zone self %@&quot;,self); return obj;&#125;@end@interface FRModel : NSObject&lt;NSCopying&gt;@property (nonatomic,copy) FRObj *name;@endFRModel *model = [[FRModel alloc] init];FRObj *obj = [[FRObj alloc] init];NSLog(@&quot;obj %@&quot;,obj);model.name = obj;---&gt; FRCopyDemo obj &lt;FRObj: 0x1004001c0&gt;&gt; FRCopyDemo FRObj copy with zone self &lt;FRObj: 0x1004001c0&gt; 可以看到 FRObj 赋值的时候自己收到了一条 copyWithZone: 的消息。具体的底层实现可以参考 属性 attribute 总结 里的 copy attribute 部分 一些 QAQ: copy 关键字一般在哪些场景下使用？A: 1.NSString/NSArray/NSDictionary 这些类使用，因为这些类都有对应的可变类型。 2. MRC 下修饰 block 属性需要使用 copy。ARC 下可以使用 copy/strong 去修饰 block，一般也使用 copy,给人感觉比较直观。 这个的对应的问题是，NSString 使用什么修饰符修饰？为什么？答案是使用 copy 修饰符，原因是 NSString 用 strong 修饰符的时候如果指向自己的可变类型，当可变类型内容修改的时候，NSString 属性也会跟着一起修改，这不是我们希望看到的。同时根据刚才的分析，使用 copy 修饰并不会给 NSString 造成额外的负担，因为仅仅是浅拷贝而已。 Q: 这个写法会出什么问题： @property (copy) NSMutableArray *array;A: 当给 array 赋值的时候可变对象会变为不可变对象，其实是向被赋值的对象发送了一个 copy 消息， copy 的默认实现就是将可变对象变为不可变对象。属性里也没有 mutablecopy 这种修饰符，所以只能手动发送 mutableCopy 消息达到目的。Property of mutable type ‘NSMutableDictionary’ has ‘copy’ attribute; an immutable object will be stored instead Q: 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？A: 实现 NSCopying 协议，实现 copyWithZone: 方法. 直接发送 copy 消息就好了 参考地址Collections Programming Topics - Copying CollectionsCocoa Core Competencies - Object copyingEffective Objective-C 2.0 - 理解 NSCopying 协议Advanced Memory Management Programming Guide - About Memory ManagementiOS 集合的深复制与浅复制Objective-C copy，看我就够了Objective-C copy那些事儿]]></content>
  </entry>
  <entry>
    <title><![CDATA[IP 地址获取小集(iOS+macOS)]]></title>
    <url>%2F2018%2F02%2F28%2FIP%20%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96%E5%B0%8F%E9%9B%86(iOS%2BmacOS)%2F</url>
    <content type="text"><![CDATA[iOS 和 macOS 上获取 IP 地址方法方法一通用的做法是使用 getifaddrs 方法获取到指向本机网络接口信息的一个链表,然后通过遍历该链表拿到当前的网卡对应的 IP 地址。iPhone 上的无线网卡是 en0 ，所以拿到 ifaddrs 结构体后去判断其 name 成员变量的时候，判定 name 是否等于 en0。 如果是运行 iPhone 模拟器的话 en0 是代表当前电脑上 en0 对应的网卡地址。 12345678910111213141516171819202122232425#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;ifaddrs.h&gt;#include &lt;arpa/inet.h&gt;...struct ifaddrs *address = NULL;struct ifaddrs *temp = NULL;if (0 != getifaddrs(&amp;address)) &#123; NSLog(@&quot;getifaddrs error = %s&quot;,strerror(errno)); return;&#125;temp = address;while (temp-&gt;ifa_next != NULL) &#123; NSString *if_name = [NSString stringWithUTF8String:temp-&gt;ifa_name]; if ([if_name isEqualToString:@&quot;en0&quot;]) &#123; struct sockaddr *ifa_addr = temp-&gt;ifa_addr; if (ifa_addr-&gt;sa_family == AF_INET) &#123; struct sockaddr_in *in_address = (struct sockaddr_in *)ifa_addr; char *ip_str = inet_ntoa(in_address-&gt;sin_addr); NSLog(@&quot;ip %@&quot;,[NSString stringWithFormat:@&quot;%s&quot;,ip_str]); &#125; &#125; temp = temp-&gt;ifa_next;&#125;freeifaddrs(address); 方法二iOS 上还有一种方式来获取，拿到通过解析当前机器的 hostname 返回地址链表中的第一个地址作为主 IP。但是这种方法并不适用于 macOS. 12345678910111213141516171819+ (NSString *)hostname &#123; char baseHostName[256]; int success = gethostname(baseHostName, 255); if (success != 0) return nil; baseHostName[255] = &apos;\0&apos;;#if !TARGET_IPHONE_SIMULATOR return [NSString stringWithFormat:@&quot;%s.local&quot;, baseHostName];#else return [NSString stringWithFormat:@&quot;%s&quot;, baseHostName];#endif&#125;// return IP Address+ (NSString *)localIPAddress &#123; struct hostent *host = gethostbyname([[self hostname] UTF8String]); if (!host) &#123;herror(&quot;resolv&quot;); return nil;&#125; struct in_addr **list = (struct in_addr **)host-&gt;h_addr_list; return [NSString stringWithCString:inet_ntoa(*list[0]) encoding:NSUTF8StringEncoding];&#125; 方法三macOS 不能使用第二种方法，但是可以使用第一种的方法，但是有一个问题，在带有网口的 Mac 电脑上，en0 是代表以太网网卡地址，你获取到的 IP 也是该网卡地址，若想要只获取 WIFI 的对应网卡地址，则需要使用别的关键词，通常是 en1 去筛选。 可以使用 networksetup -listallhardwareports 命令来查看当前的网络硬件配置。 12345678Hardware Port: EthernetDevice: en0Ethernet Address: 68:5b:35:a5:a2:d5Hardware Port: Wi-FiDevice: en1Ethernet Address: c8:e0:eb:4c:f9:bf.... 所以想获取 WIFI 的网卡地址话需要将 en0 替换为 en1，但是这并不是通用的方案，因为在 Mac Air 上 en0 再次代表了 WIFI，enX 这种判断方式不够靠谱，我们想要一个更加通用的解决方案。 通用的解决方案如下，获取系统配置，通过匹配 AirPort 关键字来进行匹配，里面的关键字参考 System Configuration Programming Guidelines 123456789101112131415161718192021//1. 创建 dynamic store.SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, (__bridge CFStringRef)@&quot;example&quot;, NULL, NULL);//2. 通过 keystore 从 dynamic store 中获取数据.NSString *keyStr = @&quot;Setup:/Network/Global/IPv4&quot;;NSDictionary *global = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)keyStr);//3. 根据 IPv4 的全局数据拿所有 servicesNSArray *services = [global objectForKey:@&quot;ServiceOrder&quot;];//4. 取出 wifi 相关 service.//Note: wifi serviceId 和 &apos;/Library/Preferences/SystemConfiguration/preferences.plist&apos; 里 wifi serviceID 一样.for (NSString *serviceID in services) &#123; NSString *serviceKeyStr = [NSString stringWithFormat:@&quot;State:/Network/Service/%@/IPv4&quot;,serviceID]; NSDictionary *serviceInfo = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)serviceKeyStr); if (serviceInfo) &#123; NSString *interfaceKeyStr = [NSString stringWithFormat:@&quot;Setup:/Network/Service/%@/Interface&quot;,serviceID]; NSDictionary *globalInterface = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)interfaceKeyStr); if ([[globalInterface objectForKey:@&quot;Hardware&quot;] isEqualToString:@&quot;AirPort&quot;] ) &#123; NSString *wifiAddress = [[serviceInfo objectForKey:@&quot;Addresses&quot;] objectAtIndex:0]; return wifiAddress; &#125; &#125;&#125; 但是这个方法并不适用于 iOS，因为 iOS 不支持上面的 API 获取空闲端口大概思路： 创建套接字。 1int local_sock = socket(temp_addr-&gt;ifa_addr-&gt;sa_family,SOCK_DGRAM, 0); 构建本地 sockaddr 的时候 sin_port 变量传入 0 。 12345struct sockaddr_in local_addr;bzero(&amp;local_addr, sizeof(local_addr));local_addr.sin_family = AF_INET;local_addr.sin_port = 0;local_addr.sin_addr.s_addr = htonl(INADDR_ANY); 然后 bind 这个套接字到本地 sockaddr 地址。 1result = bind(local_sock, (struct sockaddr *)&amp;local_addr, sizeof(local_addr)); 如果 bind 成功，接下来通过 getsockname 方法来获取 sockaddr 地址。这时候 sockaddr 里的 sin_port 即为没有被占用的端口。 1getsockname(local_sock, (struct sockaddr *)&amp;sin, &amp;len) 有点空手套白狼的意思。 macOS 上监听 WIFI 切换引起 IP 变化的方法之前使用的 AFNetworkReachabilityManager 不太符合要求，有的时候切换了 WIFI 也不能及时进行变化。 CoreWLAN 框架提供了一个监听的方法 1- (BOOL)startMonitoringEventWithType:(CWEventType)type error:(out NSError * _Nullable *)error; 不幸的是，这个方法不能再沙盒之外使用。 经过搜索发现一个方法能完整实现改功能，其实就是上面的获取 IP 的第三个方法，只不过需要增加点东西。具体可以参考下面代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static NSString *wifiServiceKeyStr;//监听 WIFI 变化的回调方法void dynamicStoreChange(SCDynamicStoreRef store,CFArrayRef changedKeys, void * __nullable info) &#123; NSLog(@&quot;store %@,changedKeys %@,info %s&quot;,store,changedKeys,info); for (NSString *changeKey in (__bridge NSArray *)changedKeys) &#123; if ([changeKey isEqualToString:wifiServiceKeyStr]) &#123; NSDictionary *serviceInfo = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)changeKey); NSLog(@&quot;now server info %@&quot;,serviceInfo); &#125; &#125;&#125;//1. 创建 dynamic store.SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, (__bridge CFStringRef)@&quot;example&quot;, dynamicStoreChange, NULL);NSString *interfaceKey = @&quot;State:/Network/Interface&quot;;NSDictionary *interfaces = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)interfaceKey);NSLog(@&quot;interfaces = %@&quot;,interfaces);//2. 通过 keystore 从 dynamic store 中获取数据.NSString *keyStr = @&quot;Setup:/Network/Global/IPv4&quot;;NSDictionary *global = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)keyStr);//3. 根据 IPv4 的全局数据拿所有 servicesNSArray *services = [global objectForKey:@&quot;ServiceOrder&quot;];//4. 取出 wifi 相关 service.//Note: wifi serviceId 和 &apos;/Library/Preferences/SystemConfiguration/preferences.plist&apos; 里 wifi serviceID 一样.//注意不能用 en0 和 en1 进行判断。en0 和 en1 在 iMac 和 macAir 上有对应不同的网卡。for (NSString *service in services) &#123; NSString *serviceKeyStr = [NSString stringWithFormat:@&quot;State:/Network/Service/%@/IPv4&quot;,service]; NSDictionary *serviceInfo = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)serviceKeyStr); if (serviceInfo) &#123; NSString *interfaceKeyStr = [NSString stringWithFormat:@&quot;Setup:/Network/Service/%@/Interface&quot;,service]; NSDictionary *globalInterface = (__bridge NSDictionary *)SCDynamicStoreCopyValue(store, (__bridge CFStringRef)interfaceKeyStr); if ([[globalInterface objectForKey:@&quot;Hardware&quot;] isEqualToString:@&quot;AirPort&quot;] ) &#123; NSLog(@&quot;service info = %@&quot;,serviceInfo); wifiServiceKeyStr = serviceKeyStr; &#125; &#125;&#125;//5. 监听 wifi 相关 service 的变化.if (wifiServiceKeyStr) &#123; SCDynamicStoreSetNotificationKeys(store, NULL,(__bridge CFArrayRef)@[wifiServiceKeyStr]); CFRunLoopAddSource(CFRunLoopGetCurrent(), SCDynamicStoreCreateRunLoopSource(NULL, store, 0), kCFRunLoopCommonModes);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[AutoreleasePool 理解]]></title>
    <url>%2F2018%2F01%2F15%2FAutoreleasePool-%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[从一些问题开始 什么是 AutoreleasePool ? 说明一下 NSAutoreleasePool 具体机制? ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？ AutoreleasePool 的实现机制? AutoreleasePool 和 NSRunloop 有什么关系？ AutoreleasePool 和线程有什么关系? 什么时候需要我们手动创建 AutoreleasePool ? 什么是 AutoreleasePool ? 如何理解 NSAutoreleasePool?NSAutoreleasePool 对象的官方说明是一个支持 Cocoa 引用计数式内存管理的一个对象。 当池子排掉的时候向池子内存储的对象发送 release 消息。 An object that supports Cocoa’s reference-counted memory management system.An autorelease pool stores objects that are sent a release message when the pool itself is drained. 具体机制说明：在引用计数式的内存管理中，NSAutoreleasePool 对象包含了收到了 _autorelease 消息的对象，这些 autorelease 对象（我们称被标记了 __autorelease 的对象为 autorelease 对象）的生命周期被延长到了这个 NSAutoreleasePool drain 的时候。也可以这么说 autorelease 和 release 的区别仅仅是 autorelease 是延时释放(即等待 AutoreleasePool drain) 而 release 是立即释放。 感觉说到这儿，其实我们可以说 NSAutoreleasePool 就是一个帮助我们管理内存的一个工具。 其实不光是我们自己可以手动创建 NSAutoreleasePool 对象，系统也帮我们维护了一个 NSAutoreleasePool 对象，在 runloop 迭代中不断 Push 和 Pop，从而不会堆积过多的 autorelease 对象引起内存疯长。你可能会好奇，哪会有那么多 autorelease 对象？举个例子来看一下： 123456- (void)viewDidLoad &#123; [super viewDidLoad]; // str 其实是一个 autorelease 对象 NSString *str = [NSString stringWithFormat:@&quot;sunnyxx&quot;]; reference = str;&#125; 题外话：为啥 str 是一个 autorelease 对象呢？这个就需要知道下内存管理的知识了，使用 alloc,new,copy和mutableCopy这些关键字生成的对象是自己持有，反之不是（参考 Memory Management Policy）。使用 stringWithFormat: 类方法生成的 str 没有持有它的对象，只能通过 autorelease 这种方式来延长它的生命周期。具体 autorelease 的时机是在 stringWithFormat 内部做的。 Cocoa 的 Framework 里大量生成了 autorelease 的对象，所以官方说明里 Cocoa 代码执行是预期在一个 autorelease 环境中。 ARC 时代和 MRC 时代的 AutoreleasePool 机制有什么区别？没啥根本区别，只是写法稍有不同。看两个 ARC 和 MRC 时代 autorelease 的两个经典写法。 MRC 的 case: 1234NSAutoreleasePool *pool = [[NSAutorelease alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];[pool drain]; ARC 的 case(注:其实 MRC 也可以这么写): 1234@autoreleasepool &#123; //_autorelease 为所有权修饰符。 id _autorelease obj = [[NSObject alloc] init];&#125; ARC 中的几点变化： ARC 中是不能使用 autorelease 方法，也不能使用 NSAutoreleasePool 类。 ARC 系统提供了 @autoreleasepool 块来替代 NSAutoreleasePool 对象的生成持有以及废弃的功能。 通过将对象赋值给附加了 __autoreleaseing 修饰符变量来替代调用 autorelease 方法。即 12id obj = [[NSObject alloc] init];[obj autorelease]; 等价于 1id _autorelease obj = [[NSObject alloc] init]; 一般我们不会显式的去使用 __autorelease 修饰符，因为ARC 下编译器帮我们做了一些工作，即编译器会检查方法是否以 alloc/new/copy/mutableCopy 开始，如果不是的话将返回的值对象注册到 autoreleasePool。 不需要显式地写 __autorelease 的几种场景 自动释放池随意生成对象，不需要显式地添加 autorelease。 1234@autoreleasepool &#123; //默认的 strong 修饰符会自动处理这种情况. id obj = [[NSObject alloc] init]; &#125; 函数返回值的场景 1234+ (NSArray *)array &#123; id obj = [[NSMutableArray alloc] init]; return obj;&#125; 在 MRC 时代，obj 是需要被发送 autorelease 方法的，ARC 时代不需要这么做，这个对象作为函数的返回值会自动被注册到 autoreleasePool 中 访问 weak 变量的时肯定会涉及到 autoreleasePool 因为 weak 对对象是弱引用，对象随时会被释放，但是使用 autoreleasePool 会延时释放，保证 weak 访问过程中不会出现对象被释放这种状况。 NSObject **obj 其实就是 NSObject *_autorelease * obj。 因为我们不持有通过引用返回的对象。这种情况只能是 autorelease。 AutoreleasePool 的实现机制?分析过程对以下代码所在文件执行 clang -rewrite-objc xx.m 重写命令，可以看到 OC 对应的 C++ 的源码。 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 转换后的 C++ 代码。 123456int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0); &#125; return 0;&#125; 可以看到 @autoreleasepool 被转换为一个名为 __AtAutoreleasePool 的数据结构。 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; main 函数其实可以理解为 12345678int main(int argc, const char * argv[]) &#123; &#123; void *atautoreleasepoolobj = objc_autoreleasePoolPush(); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_9w_q4lvthyn17v0cxxm5s7fsb500000gn_T_main_1280f1_mi_0); objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; 具体 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的实现在 runtime 源码 NSObject.mm中可以找到。 1234567void * objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; AutoreleasePoolPage 的介绍这里涉及到了 AutoreleasePoolPage 这个数据结构，接下来就看下 AutoreleasePoolPage 这个数据结构是啥样的？AutoreleasePoolPage 是个 C++ 的类 123456789class AutoreleasePoolPage &#123; magic_t const magic; //magic 用于对当前 AutoreleasePoolPage 完整性的校验 id *next; //当前 autoreleasePoolPage 最上层的对象的指针。 pthread_t const thread; //thread 保存了当前页所在的线程 AutoreleasePoolPage * const parent;//指向上一个 AutoreleasePoolPage 对象. AutoreleasePoolPage *child; //指向下一个 AutoreleasePoolPage 对象. uint32_t const depth; uint32_t hiwat;&#125; 关于 AutoreleasePoolPage 的说明 可以看到其实并没有一个整体的自动释放池对象，自动释放池是由一个双向链表构成。当一个 AutoreleasePoolPage 的空间被占满之后继续创建新的 AutoreleasePoolPage 对象。 1234567891011121314151617181920//child 指向的是下一个 AutoreleasePoolPage 对象的指针// 这个方法是当前 page 如果满的情况下创建新的 page.id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); .... return page-&gt;add(obj);&#125;// 初始化 pool 的方法 在这个里面对 parent 和 child 进行了赋值.AutoreleasePoolPage(AutoreleasePoolPage *newParent) : magic(), next(begin()), thread(pthread_self()), parent(newParent), child(nil), depth(parent ? 1+parent-&gt;depth : 0), hiwat(parent ? parent-&gt;hiwat : 0) &#123; if (parent) &#123; parent-&gt;child = this; &#125;&#125; 每个 AutoreleasePoolPage 对象都存储着当前的线程 id 参考上面的 AutoreleasePoolPage 的初始化方法。使用 pthread_self() 拿到当前的线程 id 然后保存到 thread 成员变量里。 AutoreleasePoolPage 的内存大小是 4096 个字节。是 80386 机器上的每页的字节数。 1234//初始化 AutoreleasePoolPage 的方法,size 是个宏定义的 4096static void * operator new(size_t size) &#123; return malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);&#125; AutoreleasePoolPage 存储 autorelease 对象是通过自己内部的 next 指针去实现。从实现上可以看到 AutoreleasePoolPage 还是从低内存地址向高内存地址增长。 12345id *add(id obj) &#123; id *ret = next; // faster than `return next-1` because of aliasing *next++ = obj; return ret;&#125; 由此大致能得到 AutoreleasePoolPage 的内存结构如图（来自 Sunny 大神博客） autorelease 消息调用栈了解了这个数据结构后看下 autorelease 消息的调用栈。 我们看下 AutoreleasePoolPage 中 autorelease 方法实现其实就是将 autorelease 对象存储到 AutoreleasePoolPage 的过程。下面是大致实现的代码 12345678910111213141516171819202122static inline id autorelease(id obj) &#123; ... id *dest __unused = autoreleaseFast(obj); ... return obj;&#125;//这个是将 obj 存入 AutoreleasePoolPage 的方法。static inline id *autoreleaseFast(id obj) &#123; //hotPage 应该是去 TLS(线程本地存储) 中获取 AutoreleasePoolPage。 //如果是程序刚启动的话，这儿肯定拿到的空。 AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; // AutoreleasePoolPage 不满的时候直接往进加 return page-&gt;add(obj); //绝大多数情况我们走的都是这个分支。 &#125; else if (page) &#123; // AutoreleasePoolPage 满了，则创建新的 page，将 obj 放到新的 page 里去. return autoreleaseFullPage(obj, page); &#125; else &#123; // 创建新的 page. return autoreleaseNoPage(obj); &#125;&#125; autorelease pop 消息对应 push 的是 pop，pop 即为将存储到 AutoreleasePoolPage 的对象释放对应原型为 123void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 注意的是这里并没有直接传入对象，而是传入了一个 ctxt 的指针，根据内部实现来看，自动释放池根据 ctxt 拿到它当前所在的 AutoreleasePoolPage ，然后将 AutoreleasePoolPage 的 ctxt 的位置开始到到最新的 AutoreleasePoolPage 存储的 autorelease 对象全部释放。即我们可以理解为自动释放池代码块儿开始的时候会在 AutoreleasePoolPage 进行一个占位，然后将后续的 autorelease 对象都放到占位后，这样就能确定当前自动释放池块儿里的对象是从哪到哪，理解了这一点也就能理解 autorelease 的嵌套实现了。 1234567891011121314151617181920212223242526272829static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; .. page = pageForPointer(token); //拿到 token 所在的 AutoreleasePoolPage stop = (id *)token; if (*stop != POOL_BOUNDARY) &#123; if (stop == page-&gt;begin() &amp;&amp; !page-&gt;parent) &#123; // Start of coldest page may correctly not be POOL_BOUNDARY: // 1. top-level pool is popped, leaving the cold page in place // 2. an object is autoreleased with no pool &#125; else &#123; return badPop(token); &#125; &#125; if (PrintPoolHiwat) printHiwat(); page-&gt;releaseUntil(stop); //一直释放对象到 token 的位置.&#125;//一直释放对象的函数void releaseUntil(id *stop) &#123; while (this-&gt;next != stop) &#123; AutoreleasePoolPage *page = hotPage(); //拿到当前的 page. id obj = *--page-&gt;next; memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); if (obj != POOL_BOUNDARY) &#123; objc_release(obj); //取出对象不断发送 relesse 消息.. &#125; &#125; setHotPage(this);&#125; AutoreleasePool 和 NSRunloop 有什么关系？先来个实例看下 Runloop 是什么东西。建一个普通的 Single View App 工程。点击按钮然后在按钮点击事件里打印 12345678910- (void)btnPressed:(id)sender &#123; NSRunLoop *runloop = [NSRunLoop currentRunLoop]; //在这里打断点然后 po runloop 得到下面结果。（省略大部分无关内容）&#125;(lldb) po runloop common mode items = &lt;CFBasicHash 0x604000249360 [0x110875bb0]&gt; 1 : &lt;CFRunLoopObserver 0x6040001370c0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), .... ...... 4 : &lt;CFRunLoopObserver 0x604000136ee0 [0x110875bb0]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x110a24276), .... 注意看上面的 activities,它对应的定义是这里 12345678910/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; 可以确定 Autorelease 机制在 Runloop 进入和退出(和休眠前触发) CommonMode 的时候进行观察，当 Runloop 运行到指定的时机的时候回触发 _wrapRunLoopWithAutoreleasePoolHandler 回调方法。 _wrapRunLoopWithAutoreleasePoolHandler 这个方法的实现其实我们并不清楚，网上没有找到对应的实现，不过我们可以打下符号断点来看看有没有线索。果然应用刚启动就执行了这些方法。看左侧的调用栈确实是从 Observer 的回调执行过来的。下面两个是我们熟悉的 Pop 和 Push 操作，基本上可以确认，Autorelease 机制是在进入 Runloop 的时候就创建了一个新的 AutoreleasePoolPage。退出或者休眠的的时候回收 AutoreleasePoolPage。 AutoreleasePool 和线程有什么关系?Cocoa 应用程序里的每个线程会自动维护一个释放池，就是通过上面 Runloop 的方式。但是如果没有 Runloop 呢？ 之前看到有人问了一个问题：子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？答案是不会。 具体 demo 如下 参考 123456789- (void)viewDidLoad &#123; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(test) object:nil]; [thread start];&#125;-(void)test &#123; MyClass *my = [[[MyClass alloc] init] autorelease]; NSLog(@&quot;%@&quot;,[my description]);&#125; 最后的结果是 MyClass 实例被释放掉了。理论上来说子线程并没有 Runloop 也就没有自动释放池观察 Runloop 状态，也就不会自动去执行对应的 autorelease 的方法。根据引用计数来看的话，autorelease 方法和 AutoreleasePool 在一起才能发生作用，而目前又没有 AutoreleasePool，所以那是咋回事？ 事实上即使没有 Runloop，线程和 AutoreleasePool 也能直接发生关系。向某个对象发送 autorelease 消息后，会自动创建 AutoreleasePoolPage。autorelease 消息的调用栈可以参考上面的说明。最终 TLS(线程本地存储)会存储 AutoreleasePoolPage 对象。大致代码如下： 12AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);tls_set_direct(key, (void *)page); 这里具体实现比较复杂，而且根据是这种情况并不适用于主线程。可以看 StackOverflow 的相关回答。这里不具体贴了。 我个人觉得为了程序可读性还有稳定性，还是加上 @autoreleasepool 更妥。说稳定性是因为不能过度依赖于 runtime 的底层机制，万一 runtime 底层机制后续有变化可能会造成程序的异常。 什么时候需要我们手动创建 AutoreleasePool? 如果工程只是 Foundation-Only(命令行那种),而不是 Cocoa application。那需要手动创建自动释放池。 如果程序存活时间长，而且可能生成大量临时对象（比如循环里创建了一堆）那应该在合适地方（比如循环里）手动释放池，降低内存峰值（不用担心嵌套使用 AutoreleasePool 的问题） 你创建了一个新线程，需要创建自动释放池。这个跟我们上面一小节说的是略微冲突，但是在上面已经说过了，添加 AutoreleasePool 是最佳实践。 参考地址黑幕背后的Autorelease自动释放池的前世今生 —- 深入解析 autoreleasepool深入理解RunLoopiOS中autorelease的那些事儿Transitioning to ARC Release NotesNSAutoreleasePoolUsing Autorelease Pool BlocksiOS ARC 内存管理要点各个线程 Autorelease 对象的内存管理]]></content>
  </entry>
  <entry>
    <title><![CDATA[属性自动合成]]></title>
    <url>%2F2018%2F01%2F11%2F%E5%B1%9E%E6%80%A7%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[Clang 编译器提供了 OC 自动合成属性的功能。如果一个属性没有被声明为 @dynamic 或者开发者没有自定制它的 getter 或者 setter 方法实现。那 Clang 会自动为你合成 getter 和 setter 方法的实现同时生成对应的成员变量，检查 Clang 编译器是否支持自动合成使用__has_feature(objc_default_synthesize_properties) 这个条件判断。举例 12345#if __has_feature(objc_default_synthesize_properties) //support autosynthesis#else //not support#endif 当编译器不能自动为你合成属性的时候，需要开发者手动进行。其实也可以换个说法，什么时候需要开发者手动 @synthesize。 举个例子，开发中偶尔会遇到这种报错的情况： 12345678910@property (nonatomic,strong) NSString *name;.....@implementation- (void)setName:(NSString *)name &#123; _name = name; #编译错误:Use of undeclared identifier &apos;_name&apos;; did you mean &apos;name&apos;?&#125;- (NSString *)name &#123; return @&quot;&quot;;&#125;@end 这个时候需要我们手动的添加一行代码 @synthesize name = _name; 编译错误就会消失。或者你把编译错误的那行去掉，然后使用命令 clang -rewrite-objc main.m 编译原文件，发现生成的对象结构体中并没有 name 对应的成员变量。 接下来就是总结什么场景下需要我们手动添加 @synthesize。 就是我们上面 demo 展示的这种可读写的属性，但是开发者自定义了 getter 和 setter 方法，注意必须是同时复写，如果只复写 setter 或者 getter 的话是不会出现问题的。这也是 clang 编译器不支持的自动合成的场景。 只读属性，开发者自定义了 getter 方法。 @dynamic 修饰的属性，@dynamic 本质是告诉编译器 setter 与 getter 方法由开发者自己定义，不自动合成。 在协议 @protocol 中声明的属性。 在类别 @category 中声明的属性。这是因为类别不支持自动添加成员变量，需要手动进行引用关联。 如果你复写了父类的属性，你也需要显式地添加 @synthesize 如果你想手动修改成员变量名的话，可以使用 @synthesize 修改，比如默认成员变量名是 _name 使用 @synthesize name = yname; 修改成员变量名为 yname，但是不建议这么做。 2018-03-23 补充一些关于第 6 点的说明。 如果父类自动生成属性成员变量和 getter, setter 方法。子类对父类的属性重新进行了 @synthesize 那将会生成新的实例变量。 1234567891011121314151617@interface Fan : NSObject@property (nonatomic, strong) NSString *name;@end//父类 Fan 并没有 @synthesize 而且没有复写 getter 和 setter 方法.......@interface FanSub : Fan@property (nonatomic, strong) NSString *name;....@implementation FanSub@synthesize name = fname;- (void)setName:(NSString *)name &#123; fname = name;&#125;- (NSString *)name &#123; return fname;&#125;@end 注意的是此时子类中的 name 属性对应的实例变量其实是 fname. 即它自己生成的实例变量，而不是父类的 _name 了。可以通过查看编译后的选项来验证 clang -rewrite-objc main.m。结合编译后对应的结构体看一下，确实是成员变量发生了变化。所以这个时候要注意，不能把子类的属性成员变量和父类的成员变量混为一谈。 123456789//编译后的结构体.struct Fan_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; NSString *_name;&#125;;struct FanSub_IMPL &#123; struct Fan_IMPL Fan_IVARS; NSString *fname;&#125;; 一点总结： 所以子类合成和使用属性对应自动变量的两个原则： 不允许合成和父类名字一样自动变量 如果在子类中有用到父类属性对应的成动变量，则需要显式地在父类头文件的成员变量区域去进行自动变量的声明。 一些 QAQ:@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？A: 默认合成带属性名字前面带下划线的成员变量。如果这个下划线的成员变量已经存在，就不会合成新的成员变量了。即上面问题答案是不会合成新的成员变量了。 #参考地址#When should I use @synthesize explicitly?Objective-C Autosynthesis of Properties@synthesize 和 @dynamic 的作用]]></content>
  </entry>
  <entry>
    <title><![CDATA[属性 attribute 总结]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%B1%9E%E6%80%A7-attribute-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[@property 和 attribute 的中文翻译都是属性，所以本文就只用英文做区分了。property 的不同 attribute 大致包含下面这些 strong //default weak copy assign //default unsafe_unretained atomic &amp; nonatomic //default atomic readonly &amp; readwrite //default readwrite 接下来依次说一下这些 attribute 的用处，使用方法还有使用时的可能注意事项 strongstrong 是 ARC 引入的方便内存管理的一种 attribute，跟 MRC 属性中的retain 效果基本是一样的。区别在于编译器遇到 strong 修饰的变量的时候会自动为其在合适的地方插入一条 release 语句。相同的地方就是为了强引用属性。强引用的意思就是当前对象持有自己的属性对象，如果当前对象不释放的话这个属性也不会被释放，而当对象释放的时候，ARC 也会自动为我们处理属性的释放，不需要开发者关心。strong 是我们最常用的一个 attribute。 几个说明： strong attribute 和变量前的修饰符 __strong 在 ARC 里的作用是一样的。只不过一个修饰属性一个修饰变量而已。参考 Property declarations strong 不能用来修饰非对象。否则编译器会报错 1Property with retain(or strong) attribute must be object type 一般如果某个属性前面不需要显式地写出 strong 编译器会自动认为这是 strong 类型的属性。 strong 修饰符会自动处理以下两种 case,而引用计数不会出现异常。 123456&#123;// 自己生成并持有对象 id __strong obj = [[NSObject alloc] init];&#125;&#123; // 非自己生成并持有对象. id __strong obj = [NSMutableArray array];&#125; objc_storeStrong 方法的说明，当向一个 __strong 修饰符修饰的对象赋值的时候跟执行下面代码是一样的效果。说白了就是执行了 objc_storeStrong 的方法。 12345678//Precondition: object is a valid pointer to a __strong object which //is adequately aligned for a pointer. value is null or a pointer to a valid object.void objc_storeStrong(id *object, id value) &#123; id oldValue = *object; value = [value retain]; *object = value; [oldValue release];&#125; 值得说明的是 FRObject *obj = [FRObject frobj]; 和 FRObject *obj = temp; 这两句代码编译器的处理是不一样的。第二句会执行如上 objc_storeStrong 的方法，但是第一句不会。我个人理解原因是 obj 初始化的时候并没有 oldValue，所以没有必要这么做。 weakweak 也是 ARC 引入的方便内存管理的一种 attribute，跟 assign 效果基本是一样的。区别在于在对象被释放的时候，weak 机制会自动将对象置为 nil,保证后续访问这个对象不会因为野指针闪退。 真正引入 weak 的原因是 weak 能解决引起内存泄露的循环引用问题。 几个说明： weak 和 strong 一样只能用来修饰对象。 weak attribute 和变量前的修饰符 __weak 在 ARC 里的作用是一样的。 copycopy 要求它修饰的属性必须实现 NSCopy 协议。本质上，当 copy 修饰的属性被赋值的时候，新值会收到一个 copyWithZone 方法，旧的值会被 release。 1234567//clang 编译后的源码 static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Fan, _name), (id)name, 1, 1); &#125; //runtime 里的对应方法 void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) //reallySetProperty 有对应 copy 属性的具体实现. copy 的使用场景通常是你希望属性在赋值后一直保持值不变，而不是跟着它指向的对象一直变。讨论比较多的是 NSString 是应该用 copy 还是用 strong 去修饰 1234567891011@property (atomic) NSString *name;NSMutableString *nameString = [NSMutableString stringWithString:@&quot;John&quot;];Fan *fan = [[Fan alloc] init];fan.name = nameString;NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);[nameString appendString:@&quot;ny&quot;];NSLog(@&quot;fan.name = %@ %p&quot;,fan.name,fan.name);//输出结果如下2018-01-11 20:35:18.763988+0800 TTTTT[71790:3384299] fan.name = John 0x10051e9c02018-01-11 20:35:18.764449+0800 TTTTT[71790:3384299] fan.name = Johnny 0x10051e9c0 可以看到 fan.name 在没有显式修改的时候被改掉了，这种情况出现在 NSString 指针子类 NSMutableString 的情况下，而 NSMutablString 的修改不会对本身地址产生影响。使用 copy 可以避免。个人觉得使用 copy 还是 strong 还是根据实际情况，如果出了问题知道为什么就好了。 assign值得注意的是 MRC 时代和 ARC 时代的 assign 使用多少有点区别的。MRC 的 assign 是可以修饰对象还有普通基本类型，因为你根本也没得选。但是 ARC 下虽然 assgin 也都可以修饰基本类型和对象，但是通常修饰对象的话不会用 assign ，因为缺少了 weak 修饰变量被释放时候置为 nil 的特性，很有可能出现内存问题。所以我们现在用 assign 修饰基本类型就好了，需要弱引用的时候用 weak 用来修饰对象。规则也比较明确。 unsafe_unretainedunsafe_unretained 其实就是阉割版本的 weak 实现，它缺少正是对象释放时候置为 nil 的特性。但是 unsafe_unretained 还能修饰基本数据类型，weak 不行。 看起来，我们使用 weak 就好了为啥要用 unsafe_unretained 这个属性呢。答案是因为 __weak 只支持 iOS 5.0 和 OS X Mountain Lion 作为部署版本，如果是想要兼容更低的支持 ARC 的版本，比如你想部署回 iOS 4.0 和 OS X Snow Leopark 就不得不使用 unsafe_unretained。 还有一种说法是 weak 底层实现比较繁琐消耗性能，我认为与 weak 带来的好处相比，这点消耗可以忽略。 atomic &amp; nonatomicatomic 和 nonatomic 区别在于向属性对应成员变量赋值的时候是否为原子写入，即能不能够保证安全写入，从这一点上 atomic 确实是安全的。但是 atomic 并非是线程安全的，因为 atomic 控制的粒度太细了。 举个例子，A 线程向属性写入一个值，A 线程后续再次读这个值之前，可能 B 线程也向同样的属性里写入另外一个值，这样 A 线程读取的时候并非读到的是自己刚写入的值而是一个预期之外的值。 从这一点上看 atomic 似乎用处不是很大，同时 atomic 底层是用锁实现的，频繁写入会影响性能。个人认为最好的实践是，使用 nonatomic 然后自己去处理线程相关的东西。 几个说明： atomic 是默认属性。比如 @property NSString *name; 这种属性默认就是 atomic 修饰的。 atomic 的底层实现里，赋值和读取值都有锁的保护，而且使用的都是一个锁。 atomic 不允许开发者自己复写其 getter 方法，强制复写会得到一个警告。 1#Writable atomic property &apos;name&apos; cannot pair a synthesized setter with a user defined getter readonly &amp; readwritereadonly 和 readwrite 其实就是编译器级别帮你做了只读和读写的处理。readonly 是告诉编译器不用生成 setter 方法，同时如果你对这个 readonly 属性赋值的时候编译器会报错 1#Assignment to readonly property readwrite 是默认的属性，它会告诉编译器自动生成 setter 和 getter 方法。开发者可以随意复写这两个方法来满足自己的时机情况。 补充关于自动合成属性的声明。Clang 提供了对已声明属性自动合成的支持。这个功能提供了没有被 @dynamic 修饰的属性的 getter 和 setter 方法，而不用用户手动添加。 Clang provides support for autosynthesis of declared properties. Using this feature, clang provides default synthesis of those properties not declared @dynamic and not having user provided backing getter and setter methods. __has_feature(objc_default_synthesize_properties) checks for availability of this feature in version of clang being used. 一些面试时常遇到的 QAQ: assign, weak 和 unsafe_unretained 的区别?A: assign 和 unsafe_unretained 是等价的。weak 和它们区别是在对象释放的时候增加了将其置为 nil 的功能。 Q: atomic 是不是线程安全的？A: 参考上面说明. Q: @property NSString *name; 这个属性的 attribute 是?A: strong,atomic,readwrite. 参考Transitioning to ARC Release NotesObjective-C Automatic Reference Counting (ARC)property属性修饰符总结Objective-C: Property Attribute Reference GuideEncapsulating DataVariable property attributes or Modifiers in iOS]]></content>
  </entry>
  <entry>
    <title><![CDATA[属性和运行时]]></title>
    <url>%2F2018%2F01%2F06%2F%E5%B1%9E%E6%80%A7%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%2F</url>
    <content type="text"><![CDATA[@property 的本质是什么? @property 和运行时有什么关系? @property 一个 demo property 的本质是什么@property 的本质就是成员变量加 getter 和 setter 方法。getter 和 setter 方法是编译器自动为我们生成的。我们也可以尝试去复写 getter 和 setter 方法，在设置成员变量前后增加一些我们想要的业务逻辑。 @property 有不同的 attribute : readonly,atomic,nonatomic 等等。编译器会根据不同的 attribute 生成不同的 getter 和 setter 方法 property 和运行时有什么关系?来看下运行时系统对 property 相关类型的定义 123456789101112131415template &lt;typename Element, typename List, uint32_t FlagMask&gt;struct property_list_t : entsize_list_tt&lt;property_t, property_list_t, 0&gt; &#123;&#125;;typedef struct property_t *objc_property_t;struct property_t &#123; const char *name; const char *attributes;&#125;;/// Defines a property attributetypedef struct &#123; const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; entsize_list_tt 是通过 C++ 的容器类，提供了容器类的基本方法，通过这些基本方法可以管理数据并以遍历的方式获取容器内的数据。property_list_t 是管理 property_t 的一个属性类型。 了解了基本数据类型之后，我们来讨论几个问题 类是怎么获取到 @property 的?看源码及注释 12345678910111213141516objc_property_t class_getProperty(Class cls, const char *name)&#123; ....... //依次遍历父类 for ( ; cls; cls = cls-&gt;superclass) &#123; //遍历当前类的属性列表 for (auto&amp; prop : cls-&gt;data()-&gt;properties) &#123; //比较字符串如果相等就返回当前的 property if (0 == strcmp(name, prop.name)) &#123; return (objc_property_t)&amp;prop; &#125; &#125; &#125; return nil;&#125; 类是怎么增加 property 的?看源码及注释 12345678910111213141516171819202122232425262728293031323334static bool _class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attrs, unsigned int count, bool replace)&#123; if (!cls) return NO; if (!name) return NO; //先从当前类获取指定名称的 property，如果有而且 caller 不想替换则直接返回 property_t *prop = class_getProperty(cls, name); if (prop &amp;&amp; !replace) &#123; // already exists, refuse to replace return NO; &#125; //替换当前 property 流程，其实就是把 property 相关的 attributes 进行替换。 else if (prop) &#123; // replace existing rwlock_writer_t lock(runtimeLock); try_free(prop-&gt;attributes); //参数 count 是 attrs 的数量。 prop-&gt;attributes = copyPropertyAttributeString(attrs, count); return YES; &#125; else &#123; //为新的 property 分配空空间。值得注意的是这里并不是直接分配的 property 而是通过 property_list 进行操作的。 property_list_t *proplist = (property_list_t *)malloc(sizeof(*proplist)); proplist-&gt;count = 1; proplist-&gt;entsizeAndFlags = sizeof(proplist-&gt;first); proplist-&gt;first.name = strdupIfMutable(name); proplist-&gt;first.attributes = copyPropertyAttributeString(attrs, count); //cls-&gt;data() 拿到 class_rw_t 结构体，结构体里的 properties 是 property_array_t 类型，将新的 property 加入到 property 数组中。 cls-&gt;data()-&gt;properties.attachLists(&amp;proplist, 1); return YES; &#125;&#125; property 和成员变量是怎么对应起来的？其实是在编译这一步就做好了。 1234@interface Fan : NSObject@property (nonatomic,strong) NSString *name;@end..... 编译 clang -rewrite-objc main.m 之后结果 12345678910typedef struct objc_object Fan;extern &quot;C&quot; unsigned long OBJC_IVAR_$_Fan$_name;struct Fan_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; NSString *_name;&#125;;// @property (atomic,strong) NSString *name;/* @end */... 可以看到 name 属性变成了成员变量 _name。 property 一个 demo我们之前猜测不同 property 的 attribute 会对编译器造成影响，即生成出来的 setter 和 getter 方法可能不同，比如 atomic 的 setter 方法可能会有锁的实现，于是我补充了上面源码的 getter 和 setter 实现： 12static NSString * _I_Fan_name(Fan * self, SEL _cmd) &#123; return (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)); &#125;static void _I_Fan_setName_(Fan * self, SEL _cmd, NSString *name) &#123; (*(NSString **)((char *)self + OBJC_IVAR_$_Fan$_name)) = name; &#125; 发现 setter 并没有什么特别的地方… 难道我的验证有问题吗？感觉不应该。我尝试在 demo 中给 name 属性赋值，并打了个符号断点 objc_setProperty_atomic 发现这个方法确实走了，所以 clang 出来的结果应该是有问题的。怎么生成更准确的编译结果我也不清楚。。 你也许会问 objc_setProperty_atomic 这个是干什么用的，翻源码到 objc-accessors.mm 这个文件看，可以看到不同的修饰符走了不同的设置属性的方法比如 objc_setProperty_nonatomic，objc_setProperty_atomic，objc_setProperty_atomic_copy 最终他们都调用了 reallySetProperty 这个方法接收了众多参数，根据不同的参数，走了不同的执行流。 123456789101112131415161718192021222324252627282930static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)&#123; if (offset == 0) &#123; object_setClass(self, newValue); return; &#125; id oldValue; //这里的 offset 其实就是上一步编译时候确定的。 id *slot = (id*) ((char*)self + offset); if (copy) &#123; newValue = [newValue copyWithZone:nil]; &#125; else if (mutableCopy) &#123; newValue = [newValue mutableCopyWithZone:nil]; &#125; else &#123; if (*slot == newValue) return; newValue = objc_retain(newValue); &#125; if (!atomic) &#123; oldValue = *slot; *slot = newValue; &#125; else &#123; //在这里看到 atomic 确实是使用自旋锁来对赋值进行了保护。 spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); &#125; objc_release(oldValue);&#125; 可以看到，属性机制的实现不仅靠编译时，运行时也起了很大的作用。 一个思考，能否在运行时候动态添加属性呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[NSError 最佳实践]]></title>
    <url>%2F2017%2F12%2F29%2FNSError-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[NSError 的使用访问系统的一些资源的时候，不可避免的会遇到一些错误，我们需要告诉用户或者提醒我们自己遇到什么问题了，方便定位解决。比如移除指定路径文件或者目录的时候，可能文件不存在或者路径有问题等等，我们需要知道究竟为什么不能成功移除，这时候错误信息就很重要了，看下系统是怎么设计这类 API 的。- (BOOL)removeItemAtPath:(NSString *)path error:(NSError * _Nullable *)error; 使用类似 API 的时候通常都是传递 NSError * _Nullable * 这种参数，目的是为了延长 error 的初始化时机，让 error 在执行任务的时候再初始化并赋予错误信息。 NSError 里面包含的信息很丰富。主要是三个，domain，code 和错误相关的信息。code 是和 domain 相关的。 一个 NSError 的最佳实践是是使用倒序域名方式，这样可以有效避免 NSError 的域名重复。然后根据倒序域名定义错误 code，域名不重复的话，这些 code 可以随意定制，是不会和别的域名下的 code 冲突的。具体看下面 demo 1234567891011121314151617181920212223242526272829static NSString *const kUserInfoDomain = @&quot;com.app.userinfo&quot;;typedef enum : NSUInteger &#123; AUIUserNotExist = 0, AUIUserNameEmpty,&#125; AUIErrorCode;@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self fetchUserInfoWithError:&amp;error];&#125;- (NSString *)fetchUserInfoWithError:(NSError **)error &#123; NSDictionary *errInfo =@&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;; - (void)btnPressed:(id)sender &#123; NSError *error = nil; [self fetchUserInfoWithError:error]; NSLog(@&quot;error = %@&quot;,error);&#125;//模拟一次错误获取- (NSString *)fetchUserInfoWithError:(NSError **)error &#123; NSDictionary *errInfo = @&#123;NSLocalizedDescriptionKey:@&quot;用户不存在&quot;&#125;; if(error != NULL)&#123; *error = [NSError errorWithDomain:kUserInfoDomain code:AUIUserNotExist userInfo:errInfo]; &#125; return nil;&#125; 以上错误处理代码中需要注意的一点就是 error 的判断 if(error != NULL) 加这一行的作用是区分一下两种调用方式 [self fetchUserInfoWithError:nil]; NSError *error = nil; [self fetchUserInfoWithError:error]; 如果是像前者一样调用的话，是不会走进这个 if(error != NULL)分支判断，我们没必要为这种情况单独初始化一个 error 实例。 以上，在帮别的同事封装可调用 API 的时候增加必要的 NSError 参数，不仅方便别人，其实也是方便自己。 参考NSErrorBest Practice - NSError domains and codes for your own project/app]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bonjour 的理解]]></title>
    <url>%2F2017%2F12%2F28%2FBonjour-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[先提问几个问题 什么是 Bonjour？ Bonjour 提供了哪些服务？ Bonjour 的工作机制是什么样子的? Bonjour 实践 Bonjour 异常分析 什么是 BonjourBonjour 被认为是 0 网络配置，自动发现 PC，普通设备和 IP 网络服务的协议。Bonjour 使用工业标准的 IP 协议，允许一台设备在不需要输入对方 IP 地址或配置 DNS 服务器的情况下自动发现其他设备。特别是 Bonjour 不需要 DHCP 服务器就能使 IP 自动分配，同时无需 DNS 服务器能给 IP 命名，发现服务不需要额外的服务器。同时它是个开放的协议。 Bonjour, also known as zero-configuration networking, enables automatic discovery of computers, devices, and services on IP networks. Bonjour uses industry standard IP protocols to allow devices to automatically discover each other without the need to enter IP addresses or configure DNS servers. See the Bonjour Protocol Specifications section for more details on the underlying standards. Technical Q&amp;A QA1690 Common QA for Bonjour 一个实际场景是，我的电脑想用使用打印机打印一些资料，Bonjour 可以使打印机自动连接到网络，同时给打印机分配一个 IP 地址，无需任何配置，相同网络下的电脑就可以发现这台打印机，并识别到打印机的 IP 地址，进而建立连接完成打印工作。而且如果你以后地址被动态分配的地址被改变了，Bonjour 还能继续发现新的地址。 Bonjour 提供了哪些服务？ addressing (向 host 分配 IP 地址) naming （使用名字代表 host 而不是 IP 地址） service discovery （自动发现网络中的服务） Bonjour 的工作机制是什么样子的?其实就是说一下上面三个服务的实现机制 分配 IP 的原理，使用链路本地地址（link-local address） 来解决。 IPv6 协议包含了这种技术。IPv4 是使用另外的实现来达到这个目的，IPv4 的实现原理是在本地链路中随机取一个地址然后测试是不是被占用，如果没有占用则分配其为本地链路地址，否则重新生成并继续测试占用情况。 link-local address 这项技术被绝大多数操作系统实现，如果硬件厂商想要使用 Bonjour 服务也必须在自己的设备里实现这项技术。 对 link-local address 有兴趣的可以看下它的 wiki 在本地网络中解决 IP 到名字的转换的合适方案是使用 Multicast DNS (mDNS)。 具体实现原理是使用 IP 多播的方式在本地网络中发送 DNS 格式的查询，因为没有一个统一的 DNS 服务器去响应这些查询，所以每个设备或者服务都会去返回自己的 DNS 响应 可以通过 Bonjour 提供的 API 注册服务，Bonjour 可以自动广播你的服务，任何查询你的服务的请求都会直接被转到正确的 IP 和端口。 每个服务和设备都应该只有一个名字，这个名字只在当前的网络环境下起作用。这个起名字的过程大概是这样的 硬件厂商的设备通过发送带有自己名字（XYZ-LaserPrinter.local）的查询来看下是否当前网络中有一样的，如果有响应那就应该重新起个名字（XYZ-LaserPrinter-1.local 这个名字是在原来名字的基础上继续拼接了一个数字）如果没有则继续之前的操作。直到新的名字的查询没有响应。 软件服务是当注册的时候自己起一个名字，如果名字已经被使用了，则 Bonjour 协议会重新给它起一个。 为了向系统表明 local host，macOS 上会在 local host 后面再加个点,比如 Steve.local.。 这部分命名规则比较复杂，这里不赘述了。 通过 DNS 发现服务的过程称为 DNS-SD（DNS Service Discovery）。发现服务这部分的内容还是建立在前面两部的基础上，一个指定服务类型和域名的 mDNS 查询发出去后，有符合条件的服务会返回它们的名字，结果包含了你可选择的一系列服务。和传统的查询服务不同，Bonjour 的服务更类似于询问「我想要的打印服务有没有」，而不是询问每个设备你在运行什么服务（Apple 官方对后者的的说明是，这种询问是以设备为中心的，而前者是以服务为中心）前者相比后者来说对 Client 更加有意义，Client 并不关心其他设备是干嘛的，不断询问只会造成网络压力。 Bonjour 实践macOS 系统提供了一个名为 dns-sd 的 Multicast DNS (mDNS) 和 DNS Service Discovery (DNS-SD) 测试工具。 一个例子，我想查看当前网络下能提供打印的服务 1234567➜ ~ dns-sd -B _printerBrowsing for _printer._tcpDATE: ---Thu 28 Dec 2017---19:45:30.989 ...STARTING...Timestamp A/R Flags if Domain Service Type Instance Name19:45:30.990 Add 3 5 local. _printer._tcp. Brother MFC-8510DN [30055c9332be] (2)19:45:30.990 Add 2 5 local. _printer._tcp. Brother MFC-8510DN [30055c92a583] (2) 我啥都不指定是默认会列出当前提供 http 的服务 1234567➜ ~ dns-sd -B Browsing for _http._tcpDATE: ---Thu 28 Dec 2017---19:45:49.802 ...STARTING...Timestamp A/R Flags if Domain Service Type Instance Name19:45:49.803 Add 3 8 local. _http._tcp. webserver (5)19:45:49.804 Add 3 8 local. _http._tcp. bxxx 还有一个 Bonjour Browser 的软件(如图)来提供可视化的 Bonjour 服务浏览 为啥有的时候连不上 Bonjour? 确认路由器开启了组播模式，某些路由器（如思科）默认关闭了「组播模式」，故无法在此网络下搜索到设备. 跟二次认证网络应该也没有关系. 如果是用 iPhone 设备有的时候跟 iOS 系统版本也有关系，参考 这里 参考Technical Q&amp;A QA1690 Common QA for BonjourBonjour Overviewdns-sd]]></content>
  </entry>
  <entry>
    <title><![CDATA[GCD 的理解]]></title>
    <url>%2F2017%2F12%2F21%2FGCD-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[GCD 的理解Grand Central Dispatch (GCD or libdispatch) 为多核上的并行程序执行上的提供了全面支持。GCD 的出现就是系统帮助开发者管理了一些线程方面的工作让开发者将重心放入自己的业务。减轻了开发者的负担，同时也保证了并行执行的高效。 GCD 中线程和队列的关系首先要明确一下这俩完全不一样的东西，GCD 的线程管理是系统帮助维护了一个线程池，系统自己会去根据当前负载去决定调用线程池的哪个线程去执行对应队列里的 block 任务。 对于 GCD 本身而言，GCD 本身是需要关注线程的管理，开发者使用 GCD 的时候，可以不那么关心线程的知识，省去自己创建线程，管理线程等一系列繁琐的事情，而是专心使用 GCD 提供的队列的功能。 之前看微博上有 iOS 开发小集的知识点，有一点是说如何「判断是否在主队列运行」。当时特别好奇什么情况下会用到这种判断呢？后来在一个 issue 里发现了这种判断的使用场景。 说明这个场景之前问个问题，主线程和主队列是什么关系？答案：主队列一定位于主线程，但是主线程可能包含别的队列。可以写个 demo 测试一下： 12345678int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;hello world&quot;); &#125;); &#125; return 0;&#125; 运行结果如图， 而在主线程的主队列里执行的话断点应该是这样的 好，明确了这一点后我们继续说一下什么场景会用到判断当前是否在主队列？即当执行一些 UI 操作的时候我们不仅仅需要判断是否是主线程，还要判断是否是主队列。 诶？难道 UI 操作放到主线程还不够安全吗？是的。相关问题： http://www.openradar.me/24025596 https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083 我们之前被 Apple 教育：UI 操作要放到主线程中执行，但是现在发现放到主线程中执行的时候，因为 Apple 的不靠谱，我们只能自己动手去做个判断。判断主线程的方式就和 iOS 知识小集里的说的一样使用如下代码，通过 key/value 的方式来设置和获取指定的 queue. 12345678910BOOL RCTIsMainQueue()&#123; static void *mainQueueKey = &amp;mainQueueKey; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; dispatch_queue_set_specific(dispatch_get_main_queue(), mainQueueKey, mainQueueKey, NULL); &#125;); return dispatch_get_specific(mainQueueKey) == mainQueueKey;&#125; 补充一点：上面有个 demo 没有说明的是 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ xxx }); } 这个方法为什么会在主线程执行呢？可以看下 dispatch_sync 的官方 API 说明 As an optimization, this function invokes the block on the current thread when possible. GCD 的 API 设计GCD 里的 API 设计打都是为了保证多线程下任务的执行顺序。GCD 队列(FIFO)这个概念本身也是为了连续执行 block 而生。这里不打算详细说明具体 API 的使用方法。比如 dispatch_group 相关的 API 是封装了一组任务保证该组任务执行完之后执行某个特定任务，dispatch_semaphore 相关的 API 是等某个任务执行完了再执行某个别的任务。特别说明一下 dispatch_semaphore 这个 API 非常好用，我们经常在业务中比如执行某个网络业务的时候，顺序执行 N 个网络请求来保证业务执行成功，我们会在一个网络请求的异步回调里继续调用另外一个请求的方法，通常的做法是不断的嵌套调用函数，这样是能解决问题，但是不够优雅。但是有了 dispatch_semaphore 我们就可以新的方式去执行这种操作，上个 demo 模拟一下顺序执行一系列异步操作的方法: 1234567891011121314151617int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; dispatch_semaphore_t sem = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;first block&quot;); dispatch_semaphore_signal(sem); &#125;); dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;second block&quot;); dispatch_semaphore_signal(sem); &#125;); dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); NSLog(@&quot;this is end&quot;); &#125; return 0;&#125; 还有 dispatch_barrier_async 控制队列中哪些 block 先执行，哪些后执行。在某种程度上和 dispatch_group 挺像。还有一些是通过控制 queue 的优先级来控制任务的执行顺序的，参考 dispatch_set_target_queue 相关用法。 以上都是我们经常用的 gcd 的方法，通过 GCD 提供的 API 来控制队列中 block 的执行。当然 GCD 还提供了很多别的功能，比如通过 dispatch_source_create 创建定时器等等这里就不列举了。 总结：理清楚线程，队列还有 block 三者的关系就能对 GCD 的使用游刃有余。 参考地址 https://developer.apple.com/documentation/dispatch http://blog.krzyzanowskim.com/2016/06/03/queues-are-not-bound-to-any-specific-thread/ http://blog.benjamin-encz.de/post/main-queue-vs-main-thread/ https://github.com/southpeak/iOS-tech-set/blob/master/2017/10.md#判断是否在主队列运行]]></content>
  </entry>
</search>
